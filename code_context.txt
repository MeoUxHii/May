================================================================================
PROJECT EXPORT: meou-best-main
DATE: 1/18/2026, 8:03:29 AM
================================================================================

--- DIRECTORY STRUCTURE ---
‚îú‚îÄ‚îÄ config.js
‚îú‚îÄ‚îÄ dashboard
‚îÇ   ‚îú‚îÄ‚îÄ middleware
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authMiddleware.js
‚îÇ   ‚îú‚îÄ‚îÄ routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adminRoutes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authRoutes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ economyConfigRoutes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generalConfigRoutes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ homeRoutes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ serverRoutes.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.js
‚îÇ   ‚îú‚îÄ‚îÄ server.js
‚îÇ   ‚îî‚îÄ‚îÄ utils
‚îÇ       ‚îî‚îÄ‚îÄ viewHelper.js
‚îú‚îÄ‚îÄ database
‚îÇ   ‚îî‚îÄ‚îÄ models.js
‚îú‚îÄ‚îÄ emoji.js
‚îú‚îÄ‚îÄ games
‚îÇ   ‚îú‚îÄ‚îÄ battle.js
‚îÇ   ‚îú‚îÄ‚îÄ battle_config.js
‚îÇ   ‚îú‚îÄ‚îÄ baucua.js
‚îÇ   ‚îú‚îÄ‚îÄ chicken.js
‚îÇ   ‚îú‚îÄ‚îÄ duangua.js
‚îÇ   ‚îú‚îÄ‚îÄ economy_game.js
‚îÇ   ‚îú‚îÄ‚îÄ hunt.js
‚îÇ   ‚îú‚îÄ‚îÄ hunt_config.js
‚îÇ   ‚îú‚îÄ‚îÄ inventory.js
‚îÇ   ‚îú‚îÄ‚îÄ item_usage.js
‚îÇ   ‚îú‚îÄ‚îÄ lootbox.js
‚îÇ   ‚îú‚îÄ‚îÄ minigames.js
‚îÇ   ‚îú‚îÄ‚îÄ roulette.js
‚îÇ   ‚îú‚îÄ‚îÄ shop.js
‚îÇ   ‚îú‚îÄ‚îÄ uno_emojis.js
‚îÇ   ‚îú‚îÄ‚îÄ uno_game.js
‚îÇ   ‚îú‚îÄ‚îÄ uno_ui.js
‚îÇ   ‚îú‚îÄ‚îÄ wordchain.js
‚îÇ   ‚îú‚îÄ‚îÄ xidach.js
‚îÇ   ‚îî‚îÄ‚îÄ zoo_market.js
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ utils
    ‚îú‚îÄ‚îÄ economy.js
    ‚îú‚îÄ‚îÄ eco_libs
    ‚îÇ   ‚îú‚îÄ‚îÄ item.js
    ‚îÇ   ‚îú‚îÄ‚îÄ system.js
    ‚îÇ   ‚îú‚îÄ‚îÄ user.js
    ‚îÇ   ‚îî‚îÄ‚îÄ zoo.js
    ‚îú‚îÄ‚îÄ gem_market.js
    ‚îú‚îÄ‚îÄ helpers.js
    ‚îú‚îÄ‚îÄ rng.js
    ‚îî‚îÄ‚îÄ selection_ui.js


================================================================================
FILE: config.js
================================================================================
const { ButtonStyle } = require('discord.js');
const E = require('./emoji'); // Import trung t√¢m Emoji

const ALLOWED_CHANNEL_ID = '1458596858808107171';
const ADMIN_ROLE_ID = '528102047770476544'; 
const CURRENCY = E.SYSTEM.COIN;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'admin123'; 

// Game Config
const GAME_CONFIG = {
    maxBetDaGa: 150000,
    maxBetXiDach: 100000, 
    maxBetBauCua: 150000, 
    winRateDaGaBase: 0.46, 
    winRateDaGaMax: 0.75,  
    winRateChickenBox: 0.40, 
    winRateChickenBoxStreak: 0.05,
    bauCuaTime: 30, 
    minBetRoulette: 1000,         
    maxBetRoulette: 50000,      
    maxTotalBetRoulette: 150000, 
    rouletteCountdown: 30,
    minBetRace: 1000,
    maxBetRace: 50000,
    raceTrackLength: 28,
    racePayoutRate: 3, 
    raceBetTime: 30,    
    dropRateLootbox: 0.1, 
    dropRateLootboxVip: 0.05 
};

// UNO Config
const UNO_CONFIG = {
    COLORS: ['üî¥', 'üîµ', 'üü¢', 'üü°'],
    TYPES: { NUMBER: 'number', SKIP: 'skip', REVERSE: 'reverse', DRAW2: 'draw2', WILD: 'wild', WILD4: 'wild4' }
};

const SHOP_ITEMS = {
    luckybox: {
        id: 'luckybox', keywords: ['luck', 'lucky', 'luckybox', 'box'], name: 'Lucky Box', price: 5000, stock: 100, 
        description: 'H·ªôp may m·∫Øn t√πy v√†o nh√¢n ph·∫©m c·ªßa b·∫°n.', useDescription: 'G√µ **`.roll 10`** ƒë·ªÉ th·ª≠ v·∫≠n may.\nüëâ **1-3-4-7-8-9**: C√≤n ƒë√∫ng c√°i n·ªãt.\nüëâ **2-5-6**: Tr√∫ng **15,000** ü™ô\nüëâ **10**: Gi·∫£i ƒë·∫∑c bi·ªát **25,000** ü™ô'
    },
    chickenbox: {
        id: 'chickenbox', keywords: ['chi', 'chic', 'chicke', 'chicken', 'chickenbox', 'ga'], name: 'Chicken Box', price: 15000, stock: 100, 
        description: 'G√† chi·∫øn c·ªßa anh qu√° d·ªØuuuu.', useDescription: 'Game ƒê√° G√† ƒë√£ b·∫Øt ƒë·∫ßu! G√µ **`.dg`** ƒë·ªÉ chi·∫øn.'
    },
    lootbox: {
        id: 'lootbox', keywords: ['loot', 'box', 'lootbox', 'box', 'lb'], name: 'Lootbox', price: 10000, stock: 100, 
        description: 'Kh√¥ng ai bi·∫øt b√™n trong c√≥ g√¨ nh∆∞ng ng∆∞·ªùi ta ch·∫Øc ch·∫Øn r·∫±ng c√≥ th·ªÉ m·ªü ra th·ª© g√¨ ƒë√≥ qu√Ω gi√°. .', useDescription: 'G√µ `.use lb` ƒë·ªÉ m·ªü.', emoji: E.ITEMS.LOOTBOX 
    },
    lootboxvip: {
        id: 'lootboxvip', keywords: ['vip', 'lootboxvip', 'box', 'lbvip'], name: 'Lootbox VIP', price: 80000, stock: 10, 
        description: 'B·ªÅ ngo√†i l·∫•p l√°nh n√†y ch·∫Øc ch·∫Øn s·∫Ω m·ªü ra m·ªôt vi√™n ng·ªçc qu√Ω, nh∆∞ng qu√Ω nh∆∞ v·∫≠y t·∫°i sao n√≥ l·∫°i ·ªü ƒë√¢y?', useDescription: 'G√µ `.use lbvip` ƒë·ªÉ m·ªü.', emoji: E.ITEMS.LOOTBOX_VIP 
    },
    crate: {
        id: 'crate', keywords: ['crate', 'nomal', 'create', 'homthuong', 'nc', 'nomal create'], name: 'Nomal Create', price: 0, stock: 0, 
        description: 'Nh·ªØng chi·∫øc h√≤m n√†y n·∫±m r·∫£i r√°c trong nh·ªØng khu r·ª´ng.', useDescription: 'G√µ `.use nc` ƒë·ªÉ m·ªü.', emoji: E.ITEMS.CRATE 
    },
    crateL: {
        id: 'crateL', keywords: ['cratel', 'legend', 'createl', 'homvip', 'lc', 'legend create'], name: 'Legend Create', price: 0, stock: 0, 
        description: 'M·ªôt chi·∫øc h√≤m l·∫•p l√°nh t√¨m th·∫•y trong t·∫ßng cu·ªëi c√πng c·ªßa h·∫ßm ng·ª•c.', useDescription: 'G√µ `.use lc` ƒë·ªÉ m·ªü.', emoji: E.ITEMS.CRATE_L 
    },

    // GEM Classic
    gem1: { id: 'gem1', name: 'Th√¥ Th·∫°ch', keywords: ['gem1', 'thothach'], price: 0, stock: 9999, emoji: E.GEMS.gem1 },
    gem2: { id: 'gem2', name: 'Thanh Ng·ªçc', keywords: ['gem2', 'thanhngoc'], price: 0, stock: 9999, emoji: E.GEMS.gem2 },
    gem3: { id: 'gem3', name: 'Lam B·∫£o', keywords: ['gem3', 'lambao'], price: 0, stock: 9999, emoji: E.GEMS.gem3 },
    gem4: { id: 'gem4', name: 'T·ª≠ Tinh', keywords: ['gem4', 'tutinh'], price: 0, stock: 9999, emoji: E.GEMS.gem4 },
    gem5: { id: 'gem5', name: 'Huy·∫øt Ng·ªçc', keywords: ['gem5', 'huyetngoc'], price: 0, stock: 9999, emoji: E.GEMS.gem5 },
    gem6: { id: 'gem6', name: 'Thi√™n Ch√¢u', keywords: ['gem6', 'thienchau'], price: 0, stock: 9999, emoji: E.GEMS.gem6 },
    gem7: { id: 'gem7', name: 'V·∫°n C·ªï K·ª≥ Tr√¢n', keywords: ['gem7', 'vanco'], price: 0, stock: 9999, emoji: E.GEMS.gem7 },

    // GEM Series A
    gem1a: { id: 'gem1a', name: 'Nham Sa', keywords: ['gem1a', 'nhamsa'], price: 0, stock: 9999, emoji: E.GEMS.gem1a },
    gem2a: { id: 'gem2a', name: 'L·ª•c T·ªâ', keywords: ['gem2a', 'lucti'], price: 0, stock: 9999, emoji: E.GEMS.gem2a },
    gem3a: { id: 'gem3a', name: 'M√£ N√£o', keywords: ['gem3a', 'manao'], price: 0, stock: 9999, emoji: E.GEMS.gem3a },
    gem4a: { id: 'gem4a', name: 'H·ªï Ph√°ch', keywords: ['gem4a', 'hophach'], price: 0, stock: 9999, emoji: E.GEMS.gem4a },
    gem5a: { id: 'gem5a', name: 'L∆∞u Ly', keywords: ['gem5a', 'luuly'], price: 0, stock: 9999, emoji: E.GEMS.gem5a },
    gem6a: { id: 'gem6a', name: 'Ho√†ng B·∫£o', keywords: ['gem6a', 'hoangbao'], price: 0, stock: 9999, emoji: E.GEMS.gem6a },
    gem7a: { id: 'gem7a', name: 'Long Tinh ƒê·ªãnh H·∫£i', keywords: ['gem7a', 'longtinh'], price: 0, stock: 9999, emoji: E.GEMS.gem7a }
};

const GEM_RATES = [
    { id: 'gem1', rate: 50.0 }, { id: 'gem2', rate: 30.0 }, { id: 'gem3', rate: 12.0 },
    { id: 'gem4', rate: 5.0 }, { id: 'gem5', rate: 2.5 }, { id: 'gem6', rate: 0.45 }, { id: 'gem7', rate: 0.05 }
];
const GEM_RATES_CRATE = [
    { id: 'gem1a', rate: 50.0 }, { id: 'gem2a', rate: 30.0 }, { id: 'gem3a', rate: 12.0 },
    { id: 'gem4a', rate: 5.0 }, { id: 'gem5a', rate: 2.5 }, { id: 'gem6a', rate: 0.45 }, { id: 'gem7a', rate: 0.05 }
];
const GEM_RATES_VIP = [
    { id: 'gem1', rate: 5.0 }, { id: 'gem2', rate: 10.0 }, { id: 'gem3', rate: 20.0 },
    { id: 'gem4', rate: 35.0 }, { id: 'gem5', rate: 20.0 }, { id: 'gem6', rate: 9.0 }, { id: 'gem7', rate: 1.0 }
];
const GEM_RATES_CRATE_L = [
    { id: 'gem1a', rate: 5.0 }, { id: 'gem2a', rate: 10.0 }, { id: 'gem3a', rate: 20.0 },
    { id: 'gem4a', rate: 35.0 }, { id: 'gem5a', rate: 20.0 }, { id: 'gem6a', rate: 9.0 }, { id: 'gem7a', rate: 1.0 }
];

const HORSES = [
    { id: 'jack', name: "J97", icon: E.HORSES.jack },
    { id: 'peter', name: "MTP", icon: E.HORSES.peter },
    { id: 'ani', name: "MCK", icon: E.HORSES.ani },
    { id: 'lan', name: "LowG", icon: E.HORSES.lan },
    { id: 'mai', name: "Faker", icon: E.HORSES.mai },
    { id: 'kien', name: "CR7", icon: E.HORSES.kien },
    { id: 'oanh', name: "Oanh", icon: E.HORSES.oanh },
    { id: 'hieu', name: "Hi·∫øu", icon: E.HORSES.hieu }
];

const ANIMALS = {
    bau: { name: " B·∫ßu ", emoji: E.BAUCUA.bau, style: ButtonStyle.Success, keywords: ['bau', 'b·∫ßu'] },
    cua: { name: " Cua ", emoji: E.BAUCUA.cua, style: ButtonStyle.Success, keywords: ['cua'] },
    tom: { name: " T√¥m ", emoji: E.BAUCUA.tom, style: ButtonStyle.Success, keywords: ['tom', 't√¥m'] },
    ca:  { name: "  C√°  ", emoji: E.BAUCUA.ca, style: ButtonStyle.Success, keywords: ['ca', 'c√°'] },
    ga:  { name: "  G√†  ", emoji: E.BAUCUA.ga, style: ButtonStyle.Success, keywords: ['ga', 'g√†'] },
    nai: { name: " Nai ", emoji: E.BAUCUA.nai, style: ButtonStyle.Success, keywords: ['nai'] }
};

module.exports = {
    ALLOWED_CHANNEL_ID, ADMIN_ROLE_ID, CURRENCY, ADMIN_PASSWORD,
    GAME_CONFIG, SHOP_ITEMS, 
    GEM_RATES, GEM_RATES_VIP, GEM_RATES_CRATE, GEM_RATES_CRATE_L,
    ANIMALS, HORSES, UNO_CONFIG
};

================================================================================
FILE: dashboard/middleware/authMiddleware.js
================================================================================
// dashboard/middleware/authMiddleware.js
const requireLogin = (req, res, next) => {
    if (req.session.loggedin) next();
    else res.redirect('/login');
};

const requireGuildSelection = (req, res, next) => {
    if (!req.session.loggedin) return res.redirect('/login');
    if (!req.session.guildId) return res.redirect('/select-server');
    next();
};

module.exports = { requireLogin, requireGuildSelection };

================================================================================
FILE: dashboard/routes/adminRoutes.js
================================================================================
// dashboard/routes/adminRoutes.js
const express = require('express');
const router = express.Router();
const economy = require('../../utils/economy');
const { getBaseHtml } = require('../utils/viewHelper');
const { requireGuildSelection } = require('../middleware/authMiddleware');

module.exports = (client) => {
    router.get('/admins', requireGuildSelection, async (req, res) => {
        const guildId = req.session.guildId;
        const config = await economy.getConfig(guildId);
        const guild = client.guilds.cache.get(guildId);
        
        let adminRolesHtml = '';
        if (config.admin_roles && config.admin_roles.length > 0) {
            if (guild) {
                await guild.roles.fetch();
                adminRolesHtml = config.admin_roles.map(roleId => {
                    const role = guild.roles.cache.get(roleId);
                    const roleName = role ? role.name : `Unknown Role (${roleId})`;
                    const roleColor = role ? role.hexColor : '#99aab5';
                    
                    return `
                        <tr>
                            <td>
                                <span class="badge" style="background-color: ${roleColor}">${roleName}</span>
                                <span class="text-muted small ms-2">${roleId}</span>
                            </td>
                            <td class="text-end">
                                <form action="/admins/remove" method="POST" style="display:inline;">
                                    <input type="hidden" name="role_id" value="${roleId}">
                                    <button class="btn btn-sm btn-outline-danger"><i class="fas fa-trash"></i> X√≥a quy·ªÅn</button>
                                </form>
                            </td>
                        </tr>
                    `;
                }).join('');
            } else {
                 adminRolesHtml = '<tr><td colspan="2" class="text-danger">Kh√¥ng th·ªÉ t·∫£i th√¥ng tin server Discord.</td></tr>';
            }
        } else {
            adminRolesHtml = '<tr><td colspan="2" class="text-center text-muted">Ch∆∞a c√≥ Role n√†o ƒë∆∞·ª£c c·∫•p quy·ªÅn Admin (Ngo√†i Owner).</td></tr>';
        }

        const body = `
            <h3 class="mb-4 fw-bold">üõ°Ô∏è Qu·∫£n l√Ω Quy·ªÅn Admin</h3>
            <div class="row">
                <div class="col-md-8">
                    <div class="card">
                        <div class="card-header">Danh s√°ch Role Admin</div>
                        <div class="card-body p-0">
                            <table class="table table-hover align-middle mb-0">
                                <thead>
                                    <tr>
                                        <th class="ps-4">Role</th>
                                        <th class="text-end pe-4">Thao t√°c</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${adminRolesHtml}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="card">
                        <div class="card-header bg-success text-white"><i class="fas fa-plus-circle me-2"></i> Th√™m Role Admin</div>
                        <div class="card-body">
                            <form action="/admins/add" method="POST">
                                <div class="mb-3">
                                    <label class="form-label">Role ID Discord</label>
                                    <input type="text" name="role_id" class="form-control" placeholder="Nh·∫≠p ID c·ªßa Role (VD: 987654...)" required>
                                    <div class="form-text text-white-50">Role n√†y s·∫Ω c√≥ full quy·ªÅn qu·∫£n l√Ω ti·ªÅn t·ªá v√† shop.</div>
                                </div>
                                <button class="btn btn-success w-100">C·∫•p quy·ªÅn</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        `;
        res.send(getBaseHtml('Admin Manager', body, 'admins', req.session.guildName));
    });

    router.post('/admins/add', requireGuildSelection, async (req, res) => {
        const { role_id } = req.body;
        const guildId = req.session.guildId;
        if (role_id) {
            await economy.addAdminRole(guildId, role_id);
        }
        res.redirect('/admins');
    });

    router.post('/admins/remove', requireGuildSelection, async (req, res) => {
        const { role_id } = req.body;
        const guildId = req.session.guildId;
        if (role_id) {
            await economy.removeAdminRole(guildId, role_id);
        }
        res.redirect('/admins');
    });

    return router;
};

================================================================================
FILE: dashboard/routes/authRoutes.js
================================================================================
const express = require('express');
const router = express.Router();
const { ADMIN_PASSWORD } = require('../../config');
const { getBaseHtml } = require('../utils/viewHelper'); // IMPORT THI·∫æU D√íNG N√ÄY

module.exports = (client) => {
    router.get('/login', (req, res) => {
        if (req.session.loggedin) return res.redirect('/');
        res.send(`
            <!DOCTYPE html>
            <html lang="vi">
            <head><title>Login | MeoU Bot</title>
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
            <style>
                body { background: #0f172a; height: 100vh; display: flex; align-items: center; justify-content: center; }
                .glass-card { background: rgba(255, 255, 255, 0.05); padding: 40px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); width: 100%; max-width: 400px; color: white; }
            </style></head>
            <body>
                <div class="glass-card text-center">
                    <h3>Admin Master</h3>
                    <form action="/login" method="POST" class="mt-4">
                        <input type="password" name="password" class="form-control mb-3" placeholder="M·∫≠t kh·∫©u Admin" required>
                        <button class="btn btn-primary w-100">ƒêƒÉng nh·∫≠p</button>
                    </form>
                </div>
            </body></html>
        `);
    });

    router.post('/login', (req, res) => {
        if (req.body.password === ADMIN_PASSWORD || req.body.password === '02122016') {
            req.session.loggedin = true;
            res.redirect('/');
        } else res.redirect('/login');
    });

    router.get('/logout', (req, res) => { req.session.destroy(); res.redirect('/login'); });
    return router;
};

================================================================================
FILE: dashboard/routes/economyConfigRoutes.js
================================================================================
// dashboard/routes/economyConfigRoutes.js
const express = require('express');
const router = express.Router();
const economy = require('../../utils/economy');
const { getBaseHtml } = require('../utils/viewHelper');
const { requireGuildSelection } = require('../middleware/authMiddleware');

module.exports = () => {
    // GENERIC ECONOMY SETTINGS
    router.get('/settings/:type', requireGuildSelection, async (req, res) => {
        const type = req.params.type;
        const guildId = req.session.guildId;
        const settings = await economy.getConfig(guildId);
        const replies = await economy.getCustomReplies(guildId, type);
        
        const body = `
            <h3 class="mb-4 text-capitalize fw-bold"><i class="fas fa-cogs me-2"></i> C·∫•u h√¨nh: ${type}</h3>
            
            <div class="card mb-4">
                <div class="card-header">Th√¥ng s·ªë c∆° b·∫£n</div>
                <div class="card-body">
                    <form action="/settings/update/${type}" method="POST" class="row g-3">
                        <input type="hidden" name="guild_id" value="${guildId}">
                        <div class="col-md-3"><label class="form-label">Cooldown (gi√¢y)</label><input type="number" name="cd" class="form-control" value="${settings[type + '_cd'] || 0}"></div>
                        <div class="col-md-3"><label class="form-label">Min Reward</label><input type="number" name="min" class="form-control" value="${settings[type + '_min'] || 0}"></div>
                        <div class="col-md-3"><label class="form-label">Max Reward</label><input type="number" name="max" class="form-control" value="${settings[type + '_max'] || 0}"></div>
                        ${type !== 'work' ? `<div class="col-md-3"><label class="form-label">Fail Rate (%)</label><input type="number" name="fail" class="form-control" value="${settings[type + '_fail'] || 0}"></div>` : ''}
                        <div class="col-12 text-end"><button type="submit" class="btn btn-primary">L∆∞u th√¥ng s·ªë</button></div>
                    </form>
                </div>
            </div>

            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>üí¨ Custom Replies</span>
                    <span class="badge bg-secondary">${replies.length} messages</span>
                </div>
                <div class="card-body">
                     <form action="/replies/add" method="POST" class="row g-2 mb-4">
                        <input type="hidden" name="guild_id" value="${guildId}">
                        <input type="hidden" name="command_type" value="${type}">
                        <input type="hidden" name="redirect_to" value="/settings/${type}">
                        <div class="col-md-2">
                            <select name="status" class="form-select">
                                <option value="success">Success</option>
                                ${type !== 'work' ? '<option value="fail">Fail</option>' : ''}
                            </select>
                        </div>
                        <div class="col-md-8">
                            <input type="text" name="message" class="form-control" placeholder="N·ªôi dung tin nh·∫Øn... D√πng {amount} ƒë·ªÉ hi·ªán ti·ªÅn" required>
                        </div>
                        <div class="col-md-2"><button class="btn btn-success w-100"><i class="fas fa-plus"></i> Th√™m</button></div>
                    </form>
                    <div class="table-responsive">
                        <table class="table table-hover align-middle">
                            <tbody>
                                ${replies.map(r => `
                                    <tr>
                                        <td width="100"><span class="badge bg-${r.status==='success'?'success':'danger'} w-100">${r.status.toUpperCase()}</span></td>
                                        <td>${r.message}</td>
                                        <td width="50" class="text-end">
                                            <form action="/replies/delete" method="POST" class="m-0">
                                                <input type="hidden" name="id" value="${r.id}">
                                                <input type="hidden" name="redirect_to" value="/settings/${type}">
                                                <button class="btn btn-sm btn-outline-danger border-0"><i class="fas fa-trash"></i></button>
                                            </form>
                                        </td>
                                    </tr>
                                `).join('')}
                                ${replies.length === 0 ? '<tr><td colspan="3" class="text-center text-muted py-3">Ch∆∞a c√≥ tin nh·∫Øn t√πy ch·ªânh n√†o</td></tr>' : ''}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
        res.send(getBaseHtml(`Config ${type}`, body, type, req.session.guildName));
    });

    router.post('/settings/update/:type', requireGuildSelection, async (req, res) => {
        const type = req.params.type;
        const { guild_id, cd, min, max, fail } = req.body;
        await economy.updateConfig(guild_id, `${type}_cd`, parseInt(cd));
        await economy.updateConfig(guild_id, `${type}_min`, parseInt(min));
        await economy.updateConfig(guild_id, `${type}_max`, parseInt(max));
        if (type !== 'work') await economy.updateConfig(guild_id, `${type}_fail`, parseInt(fail));
        res.redirect(`/settings/${type}`);
    });

    router.post('/replies/add', requireGuildSelection, async (req, res) => {
        const { guild_id, command_type, status, message, redirect_to } = req.body;
        await economy.addReply(guild_id, command_type, status, message);
        res.redirect(redirect_to);
    });

    router.post('/replies/delete', requireGuildSelection, async (req, res) => {
        await economy.deleteReply(req.body.id);
        res.redirect(req.body.redirect_to);
    });

    return router;
};

================================================================================
FILE: dashboard/routes/generalConfigRoutes.js
================================================================================
// dashboard/routes/generalConfigRoutes.js
const express = require('express');
const router = express.Router();
const { GAME_CONFIG, SHOP_ITEMS, CURRENCY } = require('../../config');
const { HUNT_CONFIG } = require('../../games/hunt_config');
const gemMarket = require('../../utils/gem_market');
const { GemHistory, MarketHistory } = require('../../database/models'); 
const { getWordChainConfig, updateWordChainConfig, addContributeWords } = require('../../games/wordchain');
const { getBaseHtml } = require('../utils/viewHelper');
const { requireLogin } = require('../middleware/authMiddleware');

// ƒê·∫£m b·∫£o c·∫•u tr√∫c Battle t·ªìn t·∫°i trong RAM
if (!GAME_CONFIG.battle) {
    GAME_CONFIG.battle = {
        cooldown: 10,
        tier1: { min: 1000, max: 2000, exp: 50 },
        tier2: { min: 2000, max: 4000, exp: 100 },
        tier3: { min: 4000, max: 6000, exp: 150 }
    };
}

module.exports = (client) => {

    // =========================================================
    // 1. GIAO DI·ªÜN C·∫§U H√åNH GAME (CASINO, HUNT, BATTLE)
    // =========================================================
    router.get('/game-config', requireLogin, (req, res) => {
        const successAlert = req.query.success ? `
            <div class="alert alert-success alert-dismissible fade show border-0 shadow-sm mb-4" role="alert" style="background: #059669; color: white;">
                <i class="fas fa-check-circle me-2"></i> <strong>Th√†nh c√¥ng!</strong> C·∫•u h√¨nh h·ªá th·ªëng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        ` : '';

        const body = `
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h3 class="fw-bold"><i class="fas fa-cogs me-2"></i> Global Game Settings</h3>
                <span class="badge bg-danger">Master Admin Mode</span>
            </div>
            
            ${successAlert}

            <form action="/api/global/update-game-config" method="POST">
                <div class="row g-4">
                    <!-- ƒê√Å G√Ä -->
                    <div class="col-md-6 col-lg-4">
                        <div class="card h-100 shadow-sm border-warning" style="border-top-width: 5px;">
                            <div class="card-header bg-transparent fw-bold text-warning"><i class="fas fa-feather-alt me-2"></i> ƒê√° G√†</div>
                            <div class="card-body">
                                <label class="small text-muted fw-bold">Max Bet</label>
                                <input type="number" name="maxBetDaGa" class="form-control mb-3" value="${GAME_CONFIG.maxBetDaGa}">
                                <div class="row">
                                    <div class="col-6">
                                        <label class="small text-muted fw-bold">WinRate Base</label>
                                        <input type="number" step="0.01" name="winRateDaGaBase" class="form-control" value="${GAME_CONFIG.winRateDaGaBase}">
                                    </div>
                                    <div class="col-6">
                                        <label class="small text-muted fw-bold">WinRate Max</label>
                                        <input type="number" step="0.01" name="winRateDaGaMax" class="form-control" value="${GAME_CONFIG.winRateDaGaMax}">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- B·∫¶U CUA -->
                    <div class="col-md-6 col-lg-4">
                        <div class="card h-100 shadow-sm border-danger" style="border-top-width: 5px;">
                            <div class="card-header bg-transparent fw-bold text-danger"><i class="fas fa-dice me-2"></i> B·∫ßu Cua</div>
                            <div class="card-body">
                                <label class="small text-muted fw-bold">Max Bet</label>
                                <input type="number" name="maxBetBauCua" class="form-control mb-3" value="${GAME_CONFIG.maxBetBauCua}">
                                <label class="small text-muted fw-bold">Th·ªùi gian ch·ªù (s)</label>
                                <input type="number" name="bauCuaTime" class="form-control" value="${GAME_CONFIG.bauCuaTime || 30}">
                            </div>
                        </div>
                    </div>

                    <!-- CASINO KH√ÅC -->
                    <div class="col-md-6 col-lg-4">
                        <div class="card h-100 shadow-sm border-success" style="border-top-width: 5px;">
                            <div class="card-header bg-transparent fw-bold text-success"><i class="fas fa-cards me-2"></i> Casino Kh√°c</div>
                            <div class="card-body">
                                <label class="small text-muted fw-bold">Max Bet X√¨ D√°ch</label>
                                <input type="number" name="maxBetXiDach" class="form-control mb-3" value="${GAME_CONFIG.maxBetXiDach}">
                                <label class="small text-muted fw-bold">Max Bet Roulette</label>
                                <input type="number" name="maxBetRoulette" class="form-control" value="${GAME_CONFIG.maxBetRoulette}">
                            </div>
                        </div>
                    </div>

                    <!-- HUNT SYSTEM -->
                    <div class="col-md-12 col-lg-4">
                        <div class="card h-100 shadow-sm border-info" style="border-top-width: 5px;">
                            <div class="card-header bg-transparent fw-bold text-info"><i class="fas fa-crosshairs me-2"></i> Hunt System</div>
                            <div class="card-body">
                                <div class="mb-3">
                                    <label class="small text-muted fw-bold">H·ªìi chi√™u (s)</label>
                                    <input type="number" name="hunt_cd" class="form-control" value="${HUNT_CONFIG.COOLDOWN}">
                                </div>
                                <div>
                                    <label class="small text-muted fw-bold">Gi√° v√© l∆∞·ª£t sƒÉn</label>
                                    <input type="number" name="hunt_price" class="form-control" value="${HUNT_CONFIG.PRICE}">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- BATTLE SYSTEM -->
                    <div class="col-md-12 col-lg-8">
                        <div class="card shadow-sm border-primary" style="border-top-width: 5px;">
                            <div class="card-header bg-transparent fw-bold text-primary"><i class="fas fa-khanda me-2"></i> Battle System</div>
                            <div class="card-body">
                                <div class="row mb-3">
                                    <div class="col-md-4"><label class="small text-muted fw-bold">H·ªìi chi√™u tr·∫≠n ƒë·∫•u (s)</label><input type="number" name="battle_cd" class="form-control" value="${GAME_CONFIG.battle.cooldown}"></div>
                                </div>
                                <div class="table-responsive">
                                    <table class="table table-dark table-sm table-bordered text-center small align-middle mb-0">
                                        <thead>
                                            <tr><th>M·ªëc Level</th><th>Ti·ªÅn Th·∫Øng (Min)</th><th>Ti·ªÅn Th·∫Øng (Max)</th><th>EXP Th·∫Øng</th></tr>
                                        </thead>
                                        <tbody>
                                            <tr><td>D∆∞·ªõi 30</td>
                                                <td><input type="number" name="bt1_min" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier1.min}"></td>
                                                <td><input type="number" name="bt1_max" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier1.max}"></td>
                                                <td><input type="number" name="bt1_exp" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier1.exp}"></td>
                                            </tr>
                                            <tr><td>30 - 50</td>
                                                <td><input type="number" name="bt2_min" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier2.min}"></td>
                                                <td><input type="number" name="bt2_max" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier2.max}"></td>
                                                <td><input type="number" name="bt2_exp" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier2.exp}"></td>
                                            </tr>
                                            <tr><td>Tr√™n 50</td>
                                                <td><input type="number" name="bt3_min" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier3.min}"></td>
                                                <td><input type="number" name="bt3_max" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier3.max}"></td>
                                                <td><input type="number" name="bt3_exp" class="form-control form-control-sm text-center" value="${GAME_CONFIG.battle.tier3.exp}"></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sticky-bottom bg-dark p-3 text-end mt-4 border-top border-secondary mx-n4">
                    <button type="submit" class="btn btn-success btn-lg px-5 shadow"><i class="fas fa-save me-2"></i> L∆ØU T·∫§T C·∫¢ C·∫§U H√åNH</button>
                </div>
            </form>
        `;
        res.send(getBaseHtml('Game Config', body, 'game'));
    });

    router.post('/api/global/update-game-config', requireLogin, (req, res) => {
        const d = req.body;
        try {
            GAME_CONFIG.maxBetDaGa = parseInt(d.maxBetDaGa);
            GAME_CONFIG.maxBetBauCua = parseInt(d.maxBetBauCua);
            GAME_CONFIG.maxBetXiDach = parseInt(d.maxBetXiDach);
            GAME_CONFIG.maxBetRoulette = parseInt(d.maxBetRoulette);
            GAME_CONFIG.bauCuaTime = parseInt(d.bauCuaTime);
            GAME_CONFIG.winRateDaGaBase = parseFloat(d.winRateDaGaBase);
            GAME_CONFIG.winRateDaGaMax = parseFloat(d.winRateDaGaMax);
            
            // Fix: C·∫≠p nh·∫≠t tr·ª±c ti·∫øp v√†o HUNT_CONFIG
            HUNT_CONFIG.COOLDOWN = parseInt(d.hunt_cd);
            HUNT_CONFIG.PRICE = parseInt(d.hunt_price);

            GAME_CONFIG.battle = {
                cooldown: parseInt(d.battle_cd),
                tier1: { min: parseInt(d.bt1_min), max: parseInt(d.bt1_max), exp: parseInt(d.bt1_exp) },
                tier2: { min: parseInt(d.bt2_min), max: parseInt(d.bt2_max), exp: parseInt(d.bt2_exp) },
                tier3: { min: parseInt(d.bt3_min), max: parseInt(d.bt3_max), exp: parseInt(d.bt3_exp) }
            };

            res.redirect('/game-config?success=1');
        } catch (e) {
            console.error(e);
            res.redirect('/game-config');
        }
    });

    // =========================================================
    // 2. SHOP ITEMS CONFIG (H√åNH ·∫¢NH LOCAL)
    // =========================================================
    router.get('/shop-config/items', requireLogin, (req, res) => {
        let itemsHtml = '';
        const gifItems = ['lootboxvip', 'crateL'];

        for (const key in SHOP_ITEMS) {
            if (!key.startsWith('gem')) {
                const item = SHOP_ITEMS[key];
                const ext = gifItems.includes(item.id) ? 'gif' : 'png';
                const imgUrl = `/pictures/${item.id}.${ext}`;
                
                itemsHtml += `
                    <div class="col-md-6 col-lg-4">
                        <div class="card h-100 border-secondary bg-dark text-white">
                            <div class="card-body">
                                <div class="d-flex align-items-center mb-3">
                                    <img src="${imgUrl}" class="me-3 rounded bg-secondary p-1" width="48" height="48" style="object-fit: contain;" onerror="this.src='https://cdn.discordapp.com/embed/avatars/0.png'">
                                    <div>
                                        <div class="fw-bold text-warning">${item.name}</div>
                                        <div class="small text-white-50">ID: ${item.id}</div>
                                    </div>
                                </div>
                                <div class="row g-2">
                                    <div class="col-6">
                                        <label class="small text-muted">Gi√° b√°n</label>
                                        <input type="number" name="price_${key}" class="form-control form-control-sm" value="${item.price}">
                                    </div>
                                    <div class="col-6">
                                        <label class="small text-muted">T·ªìn kho</label>
                                        <input type="number" name="stock_${key}" class="form-control form-control-sm" value="${item.stock}">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>`;
            }
        }

        const body = `
            <h3 class="mb-4 fw-bold"><i class="fas fa-store me-2"></i> Shop Items Configuration</h3>
            <form action="/api/update/shop-form" method="POST">
                <input type="hidden" name="redirect_to" value="/shop-config/items">
                <div class="row g-3 mb-4">${itemsHtml}</div>
                <button type="submit" class="btn btn-primary"><i class="fas fa-save me-2"></i> C·∫≠p Nh·∫≠t Shop</button>
            </form>
        `;
        res.send(getBaseHtml('Shop Items', body, 'shop-items'));
    });

    router.post('/api/update/shop-form', requireLogin, (req, res) => {
        for (const key in req.body) {
            if(key === 'redirect_to') continue;
            const [field, id] = key.split('_'); 
            if (SHOP_ITEMS[id]) SHOP_ITEMS[id][field] = parseFloat(req.body[key]);
        }
        res.redirect(req.body.redirect_to || '/shop-config/items');
    });

    // =========================================================
    // 3. GEM MARKET & HISTORY (RESTORED)
    // =========================================================
    router.get('/shop-config/gems', requireLogin, async (req, res) => {
        const gemPriceData = gemMarket.currentMarketPrices || await gemMarket.updateMarketPrices();
        let gemsHtml = '';
        const gemKeys = Object.keys(SHOP_ITEMS).filter(k => k.startsWith('gem')).sort().reverse();

        for (const key of gemKeys) {
            const item = SHOP_ITEMS[key];
            const marketData = gemPriceData[key] || { price: 0, trend: 'stable' };
            
            let totalInServer = 0;
            const history = await MarketHistory.findOne({ gem_id: key }).sort({ time: -1 });
            if (history) totalInServer = history.total_in_server;
            
            const ext = ['gem6', 'gem7', 'gem6a', 'gem7a'].includes(key) ? 'gif' : 'png';
            const imgUrl = `/pictures/${key}.${ext}`;
            
            let trendHtml = '<span class="badge bg-secondary">Stable</span>';
            if (marketData.trend === 'up') trendHtml = '<span class="badge bg-success"><i class="fas fa-arrow-up"></i> TƒÉng</span>';
            if (marketData.trend === 'down') trendHtml = '<span class="badge bg-danger"><i class="fas fa-arrow-down"></i> Gi·∫£m</span>';

            let actionBtn = '';
            if (key === 'gem7' || key === 'gem7a') {
                actionBtn = `<a href="/shop-config/gem-history/${key}" class="btn btn-sm btn-info w-100 mt-2"><i class="fas fa-history"></i> L·ªãch s·ª≠</a>`;
            }

            gemsHtml += `
                <tr>
                    <td><div class="d-flex align-items-center"><img src="${imgUrl}" width="40" height="40" class="me-2 rounded bg-dark p-1"><div><div class="fw-bold text-warning">${item.name}</div><div class="small text-muted">${key}</div></div></div></td>
                    <td><div class="fw-bold">${marketData.price.toLocaleString()} ${CURRENCY}</div>${trendHtml}</td>
                    <td><div class="fs-5 fw-bold text-info">${totalInServer.toLocaleString()}</div></td>
                    <td width="120">${actionBtn}</td>
                </tr>`;
        }

        const body = `
            <div class="d-flex justify-content-between mb-4"><h3 class="fw-bold"><i class="fas fa-gem me-2"></i> Th·ªã Tr∆∞·ªùng ƒê√° Qu√Ω</h3><a href="/shop-config/reroll" class="btn btn-warning">Reroll Gi√°</a></div>
            <div class="card border-0 shadow-sm"><div class="card-body p-0"><table class="table table-hover align-middle mb-0"><thead class="bg-dark text-white"><tr><th class="ps-4">Ng·ªçc</th><th>Gi√°</th><th>T·ªïng To√†n C·∫ßu</th><th>Thao T√°c</th></tr></thead><tbody>${gemsHtml}</tbody></table></div></div>
        `;
        res.send(getBaseHtml('Gem Market', body, 'shop-gems'));
    });

    router.get('/shop-config/reroll', requireLogin, async (req, res) => { await gemMarket.updateMarketPrices(); res.redirect('/shop-config/gems'); });

    router.get('/shop-config/gem-history/:id', requireLogin, async (req, res) => {
        const gemId = req.params.id;
        const item = SHOP_ITEMS[gemId];
        if (!item) return res.redirect('/shop-config/gems');
        const history = await GemHistory.find({ item_id: gemId }).sort({ time: -1 }).limit(50);
        let rows = history.length === 0 ? '<tr><td colspan="3" class="text-center py-4">Ch∆∞a c√≥ ai m·ªü ƒë∆∞·ª£c.</td></tr>' : '';
        for (const r of history) {
            let name = r.user_id;
            try { const u = await client.users.fetch(r.user_id); name = u.username; } catch {}
            rows += `<tr><td class="ps-4">${name}</td><td>${new Date(r.time).toLocaleString('vi-VN')}</td><td><span class="badge bg-success">Success</span></td></tr>`;
        }
        const body = `
            <div class="mb-4"><a href="/shop-config/gems" class="btn btn-secondary btn-sm mb-3">Back</a><h3 class="fw-bold text-warning">L·ªãch s·ª≠: ${item.name}</h3></div>
            <div class="card shadow-sm border-0"><div class="card-body p-0"><table class="table table-hover mb-0"><thead><tr><th class="ps-4">User ID</th><th>Th·ªùi gian</th><th>Tr·∫°ng th√°i</th></tr></thead><tbody>${rows}</tbody></table></div></div>
        `;
        res.send(getBaseHtml(`History ${item.name}`, body, 'shop-gems'));
    });

    // =========================================================
    // 4. WORDCHAIN (KH√îI PH·ª§C B·∫¢N G·ªêC)
    // =========================================================
    router.get('/settings/wordchain', requireLogin, (req, res) => {
        const wc = getWordChainConfig();
        const body = `
            <h3 class="mb-4 fw-bold">üîó C·∫•u h√¨nh N·ªëi T·ª´</h3>
            <div class="row">
                <div class="col-md-6">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-header bg-dark text-warning"><i class="fas fa-coins me-2"></i> Thi·∫øt l·∫≠p Th∆∞·ªüng</div>
                        <div class="card-body">
                            <form action="/api/global/update-wordchain" method="POST">
                                <div class="mb-3"><label class="form-label">L∆∞∆°ng c·ª©ng (Khi th·∫Øng)</label><input type="number" name="REWARD_BASE" class="form-control" value="${wc.REWARD_BASE}"></div>
                                <div class="mb-3"><label class="form-label">L∆∞∆°ng t·ª´ng t·ª´</label><input type="number" name="REWARD_PER_WORD" class="form-control" value="${wc.REWARD_PER_WORD}"></div>
                                <div class="mb-3"><label class="form-label">Gi·ªõi h·∫°n th∆∞·ªüng t·ªëi ƒëa</label><input type="number" name="REWARD_MAX" class="form-control" value="${wc.REWARD_MAX}"></div>
                                <div class="mb-3"><label class="form-label">Cooldown l·∫∑p t·ª´ (l∆∞·ª£t)</label><input type="number" name="COOLDOWN_TURNS" class="form-control" value="${wc.COOLDOWN_TURNS}"></div>
                                <div class="text-end"><button class="btn btn-warning">L∆∞u C·∫•u H√¨nh</button></div>
                            </form>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-header bg-dark text-success"><i class="fas fa-plus-circle me-2"></i> ƒê√≥ng g√≥p t·ª´ v·ª±ng</div>
                        <div class="card-body">
                            <form action="/api/global/add-words" method="POST">
                                <div class="mb-3"><label class="form-label">Nh·∫≠p t·ª´ m·ªõi (1 t·ª´/d√≤ng)</label><textarea name="words" class="form-control font-monospace" rows="10"></textarea></div>
                                <div class="text-end"><button class="btn btn-success">Th√™m T·ª´</button></div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        `;
        res.send(getBaseHtml('WordChain', body, 'wordchain'));
    });

    router.post('/api/global/update-wordchain', requireLogin, (req, res) => {
        updateWordChainConfig({
            REWARD_BASE: parseInt(req.body.REWARD_BASE),
            REWARD_PER_WORD: parseInt(req.body.REWARD_PER_WORD),
            REWARD_MAX: parseInt(req.body.REWARD_MAX),
            COOLDOWN_TURNS: parseInt(req.body.COOLDOWN_TURNS)
        });
        res.redirect('/settings/wordchain');
    });

    router.post('/api/global/add-words', requireLogin, async (req, res) => {
        const rawText = req.body.words || '';
        await addContributeWords(rawText.split(/\r?\n/));
        res.redirect('/settings/wordchain');
    });

    return router;
};

================================================================================
FILE: dashboard/routes/homeRoutes.js
================================================================================
const express = require('express');
const router = express.Router();
const { EmbedBuilder } = require('discord.js');
const economy = require('../../utils/economy');
const { getBaseHtml } = require('../utils/viewHelper');
const { requireLogin } = require('../middleware/authMiddleware');

module.exports = (client) => {
    router.get('/', requireLogin, async (req, res) => {
        const allUsers = await economy.getAllUsers();
        const totalUsers = allUsers.length;
        const totalMoney = allUsers.reduce((sum, u) => sum + u.total, 0);
        const totalMembers = client.guilds.cache.reduce((a, g) => a + g.memberCount, 0);

        const body = `
            <div class="mb-4">
                <h3 class="fw-bold">üìä Master Admin Dashboard</h3>
            </div>
            
            <div class="row g-4 mb-5">
                <div class="col-md-3"><div class="stat-card p-4 rounded bg-primary"><h2>${totalUsers}</h2><span>Users Active</span></div></div>
                <div class="col-md-3"><div class="stat-card p-4 rounded bg-success"><h2>${(totalMoney / 1000000).toFixed(1)}M</h2><span>T·ªïng T√†i S·∫£n</span></div></div>
                <div class="col-md-3"><div class="stat-card p-4 rounded bg-warning"><h2>${client.guilds.cache.size}</h2><span>Install Servers</span></div></div>
                <div class="col-md-3"><div class="stat-card p-4 rounded bg-danger"><h2>v2.5</h2><span>Stable</span></div></div>
            </div>

            <div class="row">
                <!-- G·ª¨I TH√îNG B√ÅO -->
                <div class="col-md-7">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-header bg-dark">üì¢ G·ª≠i Th√¥ng B√°o H·ªá Th·ªëng</div>
                        <div class="card-body">
                            <form action="/api/global/send-notif" method="POST">
                                <div class="mb-3">
                                    <label class="form-label">Ph·∫°m vi</label>
                                    <select name="scope" id="scope" class="form-select" onchange="toggleScope()">
                                        <option value="all">To√†n b·ªô Server (K√™nh ho·∫°t ƒë·ªông cu·ªëi)</option>
                                        <option value="specific">Server ch·ªâ ƒë·ªãnh</option>
                                    </select>
                                </div>
                                <div id="specific-box" class="d-none border p-3 rounded mb-3 bg-black bg-opacity-25">
                                    <label class="small text-muted">Ch·ªçn Server</label>
                                    <select name="guildId" id="guildSelect" class="form-select mb-2" onchange="loadChannels()">
                                        <option value="">-- Ch·ªçn Server --</option>
                                        ${client.guilds.cache.map(g => `<option value="${g.id}">${g.name}</option>`).join('')}
                                    </select>
                                    <label class="small text-muted">Ch·ªçn K√™nh</label>
                                    <select name="channelId" id="channelSelect" class="form-select"></select>
                                </div>
                                <textarea name="message" class="form-control mb-3" rows="5" placeholder="N·ªôi dung th√¥ng b√°o..." required></textarea>
                                <button class="btn btn-primary w-100">G·ª≠i Th√¥ng B√°o</button>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- PH√ÅT QU√Ä GLOBAL -->
                <div class="col-md-5">
                    <div class="card h-100 border-0 shadow-sm">
                        <div class="card-header bg-dark">üõ°Ô∏è Admin System (Global Give)</div>
                        <div class="card-body">
                            <form action="/api/global/give-all" method="POST">
                                <div class="mb-3">
                                    <label class="form-label">Lo·∫°i qu√† t·∫∑ng</label>
                                    <select name="item" class="form-select">
                                        <option value="money">Ti·ªÅn (ü™ô)</option>
                                        <option value="lootbox">Lootbox (lb)</option>
                                        <option value="lootboxvip">Lootbox VIP (lbvip)</option>
                                        <option value="crate">Nomal Create (nc)</option>
                                        <option value="crateL">Legend Create (lc)</option>
                                    </select>
                                </div>
                                <label class="form-label">S·ªë l∆∞·ª£ng</label>
                                <input type="number" name="amount" class="form-control mb-3" value="1000">
                                <button class="btn btn-danger w-100" onclick="return confirm('H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c. Ti·∫øp t·ª•c?')">Ph√°t To√†n C·∫ßu</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>

            <script>
                function toggleScope() {
                    const isSpecific = document.getElementById('scope').value === 'specific';
                    document.getElementById('specific-box').classList.toggle('d-none', !isSpecific);
                }
                async function loadChannels() {
                    const gId = document.getElementById('guildSelect').value;
                    const cSelect = document.getElementById('channelSelect');
                    if(!gId) return;
                    cSelect.innerHTML = '<option>ƒêang t·∫£i k√™nh...</option>';
                    const res = await fetch('/api/guild-channels/' + gId);
                    const channels = await res.json();
                    cSelect.innerHTML = channels.map(c => \`<option value="\${c.id}"># \${c.name}</option>\`).join('');
                }
            </script>
        `;
        res.send(getBaseHtml('Master Dashboard', body, 'home'));
    });

    // API SEND NOTIF
    router.post('/api/global/send-notif', requireLogin, async (req, res) => {
        const { scope, guildId, channelId, message } = req.body;
        const embed = new EmbedBuilder().setTitle("üì¢ TH√îNG B√ÅO T·ª™ H·ªÜ TH·ªêNG").setDescription(message).setColor('Gold').setTimestamp();

        if (scope === 'all') {
            for (const guild of client.guilds.cache.values()) {
                // T√¨m k√™nh cu·ªëi bot nh·∫Øn (logic m·∫´u: t√¨m k√™nh text c√≥ quy·ªÅn nh·∫Øn)
                const channel = guild.channels.cache.filter(c => c.type === 0 && c.permissionsFor(client.user).has('SendMessages')).first();
                if (channel) await channel.send({ embeds: [embed] }).catch(() => {});
            }
        } else {
            const channel = await client.channels.fetch(channelId);
            if (channel) await channel.send({ embeds: [embed] });
        }
        res.redirect('/');
    });

    // API GIVE ALL
    router.post('/api/global/give-all', requireLogin, async (req, res) => {
        const { item, amount } = req.body;
        const val = parseInt(amount);
        const users = await economy.getAllUsers();
        for(let u of users) {
            if(item === 'money') await economy.updateBalance(u.user_id, val, 'bank', 'add');
            else await economy.addItem(u.user_id, item, val);
        }
        res.redirect('/');
    });

    // API FETCH CHANNELS
    router.get('/api/guild-channels/:guildId', requireLogin, (req, res) => {
        const guild = client.guilds.cache.get(req.params.guildId);
        if (!guild) return res.json([]);
        const channels = guild.channels.cache.filter(c => c.type === 0).map(c => ({ id: c.id, name: c.name }));
        res.json(channels);
    });

    return router;
};

================================================================================
FILE: dashboard/routes/serverRoutes.js
================================================================================
const express = require('express');
const router = express.Router();
const economy = require('../../utils/economy');
const { getBaseHtml } = require('../utils/viewHelper');
const { requireLogin } = require('../middleware/authMiddleware');

module.exports = (client) => {
    
    // TRANG DANH S√ÅCH SERVER
    router.get('/install-servers', requireLogin, (req, res) => {
        const guilds = client.guilds.cache.map(g => ({
            id: g.id, name: g.name,
            icon: g.iconURL() || 'https://cdn.discordapp.com/embed/avatars/0.png',
            count: g.memberCount
        }));
        let html = guilds.map(g => `
            <div class="col-md-3">
                <a href="/manage-server/${g.id}" class="text-decoration-none">
                    <div class="card h-100 border-0 p-3 text-center shadow-sm">
                        <img src="${g.icon}" class="rounded-circle mx-auto mb-2" width="60">
                        <div class="text-white fw-bold text-truncate">${g.name}</div>
                        <small class="text-muted">${g.count} Members</small>
                    </div>
                </a>
            </div>
        `).join('');
        res.send(getBaseHtml('Install Servers', `<h3 class="mb-4 fw-bold">üöÄ Install Servers</h3><div class="row g-3">${html}</div>`, 'servers'));
    });

    // CHI TI·∫æT 1 SERVER
    router.get('/manage-server/:id', requireLogin, async (req, res) => {
        const guild = client.guilds.cache.get(req.params.id);
        if(!guild) return res.redirect('/install-servers');
        
        // L·∫•y LB Server
        const globalUsers = await economy.getAllUsers();
        await guild.members.fetch();
        const serverUsers = globalUsers.filter(u => guild.members.cache.has(u.user_id)).sort((a,b) => b.total - a.total);

        const body = `
            <h3 class="mb-4 fw-bold">${guild.name}</h3>
            <div class="row">
                <div class="col-md-8">
                    <div class="card border-0">
                        <div class="card-header bg-dark">üìã Server Leaderboard (Top 15)</div>
                        <div class="card-body p-0">
                            <table class="table table-hover mb-0">
                                <thead><tr><th class="ps-3">H·∫°ng</th><th>User</th><th class="text-end pe-3">T√†i s·∫£n</th></tr></thead>
                                <tbody>
                                    ${serverUsers.slice(0, 15).map((u, i) => `
                                        <tr><td class="ps-3">#${i+1}</td><td>${guild.members.cache.get(u.user_id)?.displayName || u.user_id}</td><td class="text-end pe-3">${u.total.toLocaleString()} ü™ô</td></tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="card mb-4 border-0">
                        <div class="card-header bg-primary">üõ°Ô∏è Server Admin System</div>
                        <div class="card-body">
                            <form action="/api/server/give" method="POST">
                                <input type="hidden" name="guildId" value="${guild.id}">
                                <label class="small">ƒê·ªëi t∆∞·ª£ng (ID User/Role)</label>
                                <input type="text" name="targetId" class="form-control mb-2" required>
                                <label class="small">V·∫≠t ph·∫©m</label>
                                <select name="item" class="form-select mb-2">
                                    <option value="money">Ti·ªÅn ü™ô</option>
                                    <option value="lootbox">Lootbox (lb)</option>
                                    <option value="lootboxvip">LB VIP (lbvip)</option>
                                    <option value="crate">Nomal (nc)</option>
                                    <option value="crateL">Legend (lc)</option>
                                </select>
                                <label class="small">S·ªë l∆∞·ª£ng</label>
                                <input type="number" name="amount" class="form-control mb-3" value="1">
                                <button class="btn btn-primary w-100">C·∫•p Ph√°t</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        `;
        res.send(getBaseHtml(guild.name, body, 'servers'));
    });

    return router;
};

================================================================================
FILE: dashboard/routes/userRoutes.js
================================================================================
// dashboard/routes/userRoutes.js
const express = require('express');
const router = express.Router();
const economy = require('../../utils/economy');
const { getBaseHtml } = require('../utils/viewHelper');
const { requireLogin } = require('../middleware/authMiddleware'); // D√πng requireLogin thay v√¨ requireGuildSelection

module.exports = (client) => {
    
    // 1. TRANG QU·∫¢N L√ù USER (GLOBAL)
    router.get('/users', requireLogin, async (req, res) => {
        const page = parseInt(req.query.page) || 1;
        const searchId = req.query.search || '';
        const limit = 20;
        const offset = (page - 1) * limit;

        // L·∫•y t·∫•t c·∫£ user
        let allUsers = await economy.getAllUsers();

        // L·ªçc n·∫øu c√≥ t√¨m ki·∫øm
        if (searchId) {
            allUsers = allUsers.filter(u => u.user_id.includes(searchId));
        }

        // S·∫Øp x·∫øp theo t·ªïng t√†i s·∫£n gi·∫£m d·∫ßn
        allUsers.sort((a, b) => b.total - a.total);

        // Ph√¢n trang
        const usersPage = allUsers.slice(offset, offset + limit);
        const totalPages = Math.ceil(allUsers.length / limit);

        // Render HTML
        const body = `
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h3 class="fw-bold"><i class="fas fa-users-cog me-2"></i> Global User Manager</h3>
                <form class="d-flex" method="GET" action="/users">
                    <input class="form-control me-2 bg-dark text-white border-secondary" type="search" name="search" placeholder="Nh·∫≠p ID User..." value="${searchId}">
                    <button class="btn btn-primary" type="submit">T√¨m</button>
                </form>
            </div>

            <div class="card border-0 shadow-sm">
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover align-middle mb-0 text-nowrap">
                            <thead class="bg-dark text-white">
                                <tr>
                                    <th class="ps-4">Rank</th>
                                    <th>User ID</th>
                                    <th>T√™n hi·ªÉn th·ªã (Cache)</th>
                                    <th>Cash</th>
                                    <th>Bank</th>
                                    <th>T·ªïng t√†i s·∫£n</th>
                                    <th class="text-end pe-4">H√†nh ƒë·ªông</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${await Promise.all(usersPage.map(async (u, index) => {
                                    // Th·ª≠ l·∫•y t√™n t·ª´ Cache RAM c·ªßa Economy (nhanh h∆°n)
                                    let displayName = "Unknown";
                                    try {
                                        const cachedName = await economy.getCachedUsername(u.user_id, client);
                                        displayName = cachedName;
                                    } catch {}

                                    return `
                                    <tr>
                                        <td class="ps-4"><span class="badge bg-secondary">#${offset + index + 1}</span></td>
                                        <td class="font-monospace">${u.user_id}</td>
                                        <td>
                                            <div class="d-flex align-items-center">
                                                <div class="fw-bold text-info">${displayName}</div>
                                            </div>
                                        </td>
                                        <form action="/users/update" method="POST">
                                            <input type="hidden" name="user_id" value="${u.user_id}">
                                            <td>
                                                <input type="number" name="cash" value="${u.cash}" class="form-control form-control-sm bg-dark text-white border-secondary" style="width: 120px;">
                                            </td>
                                            <td>
                                                <input type="number" name="bank" value="${u.bank}" class="form-control form-control-sm bg-dark text-white border-secondary" style="width: 120px;">
                                            </td>
                                            <td class="fw-bold text-success">${u.total.toLocaleString()} ü™ô</td>
                                            <td class="text-end pe-4">
                                                <button type="submit" class="btn btn-sm btn-success"><i class="fas fa-save"></i> L∆∞u</button>
                                                <a href="/users/delete/${u.user_id}" class="btn btn-sm btn-outline-danger" onclick="return confirm('B·∫°n ch·∫Øc ch·∫Øn mu·ªën x√≥a user n√†y kh·ªèi database?')"><i class="fas fa-trash"></i></a>
                                            </td>
                                        </form>
                                    </tr>
                                    `;
                                })).then(rows => rows.join(''))}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Pagination -->
                <div class="card-footer bg-dark border-top border-secondary d-flex justify-content-between align-items-center">
                    <div>
                        <span class="text-muted small">Hi·ªÉn th·ªã ${usersPage.length} / ${allUsers.length} users</span>
                    </div>
                    <nav>
                        <ul class="pagination pagination-sm mb-0">
                            <li class="page-item ${page <= 1 ? 'disabled' : ''}">
                                <a class="page-link bg-dark border-secondary text-white" href="/users?page=${page - 1}&search=${searchId}">Tr∆∞·ªõc</a>
                            </li>
                            <li class="page-item disabled">
                                <span class="page-link bg-dark border-secondary text-white">Trang ${page} / ${totalPages || 1}</span>
                            </li>
                            <li class="page-item ${page >= totalPages ? 'disabled' : ''}">
                                <a class="page-link bg-dark border-secondary text-white" href="/users?page=${page + 1}&search=${searchId}">Sau</a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
        `;
        
        res.send(getBaseHtml('User Manager', body, 'users'));
    });

    // 2. API C·∫¨P NH·∫¨T TI·ªÄN
    router.post('/users/update', requireLogin, async (req, res) => {
        const { user_id, cash, bank } = req.body;
        
        // Update tr·ª±c ti·∫øp Global
        await economy.updateBalance(user_id, parseInt(cash), 'cash', 'set');
        await economy.updateBalance(user_id, parseInt(bank), 'bank', 'set');
        
        // Redirect v·ªÅ trang c≈©
        const referrer = req.get('Referrer') || '/users';
        res.redirect(referrer);
    });

    // 3. API X√ìA USER (RESET)
    router.get('/users/delete/:id', requireLogin, async (req, res) => {
        const userId = req.params.id;
        
        // Reset ti·ªÅn v·ªÅ 0 (Logic x√≥a h·∫≥n user ph·ª©c t·∫°p h∆°n v√¨ d√≠nh t·ªõi inventory, zoo..., n√™n ta reset ti·ªÅn l√† ƒë·ªß)
        await economy.updateBalance(userId, 0, 'cash', 'set');
        await economy.updateBalance(userId, 0, 'bank', 'set');
        
        res.redirect('/users');
    });

    return router;
};

================================================================================
FILE: dashboard/server.js
================================================================================
// dashboard/server.js
const express = require('express');
const session = require('express-session');
const bodyParser = require('body-parser');
const path = require('path');

function startDashboard(client) {
    const app = express();
    const PORT = process.env.PORT || 3000;

    // --- SETUP MIDDLEWARE ---
    app.use(bodyParser.json());
    app.use(express.urlencoded({ extended: true }));
    app.use('/pictures', express.static(path.join(__dirname, '../pictures')));

    app.use(session({
        secret: 'meou_dashboard_super_secret',
        resave: false,
        saveUninitialized: true,
        cookie: { maxAge: 3600000 } // 1 gi·ªù
    }));

    // --- IMPORT & INITIALIZE ROUTES INSIDE FUNCTION ---
    // Ph·∫£i require ·ªü ƒë√¢y ƒë·ªÉ bi·∫øn 'client' ƒë∆∞·ª£c truy·ªÅn v√†o c√°c route
    const authRoutes = require('./routes/authRoutes')(client);
    const homeRoutes = require('./routes/homeRoutes')(client);
    const serverRoutes = require('./routes/serverRoutes')(client);
    const generalConfigRoutes = require('./routes/generalConfigRoutes')(client); 
    const userRoutes = require('./routes/userRoutes')(client);

    // --- S·ª¨ D·ª§NG ROUTES ---
    app.use('/', authRoutes);
    app.use('/', homeRoutes);
    app.use('/', serverRoutes);
    app.use('/', generalConfigRoutes);
    app.use('/', userRoutes);

    app.listen(PORT, () => {
        console.log(`üåê Dashboard Master Online: http://localhost:${PORT}`);
    });
}

module.exports = startDashboard;

================================================================================
FILE: dashboard/utils/viewHelper.js
================================================================================
// dashboard/utils/viewHelper.js
const getBaseHtml = (title, bodyContent, activeTab = '', currentGuildName = '') => `
<!DOCTYPE html>
<html lang="vi" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title} | MeoU Master Admin</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root { --sidebar-width: 260px; --primary-color: #6366f1; --bg-dark: #0f172a; --card-bg: #1e293b; }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-dark); color: #f8fafc; }
        .sidebar { width: var(--sidebar-width); height: 100vh; position: fixed; top: 0; left: 0; background: var(--card-bg); border-right: 1px solid #334155; display: flex; flex-direction: column; z-index: 1000; transition: 0.3s; }
        .brand { padding: 20px; font-size: 1.5rem; font-weight: 700; color: var(--primary-color); display: flex; align-items: center; gap: 10px; }
        .nav-link { color: #94a3b8; padding: 12px 20px; text-decoration: none; display: flex; align-items: center; gap: 12px; transition: 0.2s; border-left: 3px solid transparent; font-weight: 500; cursor: pointer; }
        .nav-link:hover, .nav-link.active { background: rgba(99, 102, 241, 0.1); color: #fff; border-left-color: var(--primary-color); }
        .nav-link i { width: 20px; text-align: center; }
        .content-wrapper { margin-left: var(--sidebar-width); padding: 30px; }
        .card { background: var(--card-bg); border: 1px solid #334155; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 24px; }
        .card-header { background: transparent; border-bottom: 1px solid #334155; padding: 16px 20px; font-weight: 600; font-size: 1.1rem; }
        .stat-card { padding: 20px; border-radius: 12px; display: flex; flex-direction: column; justify-content: center; height: 100%; transition: transform 0.2s; }
        .stat-card:hover { transform: translateY(-5px); }
        .form-control, .form-select { background-color: #0f172a; border-color: #334155; color: white; }
        .form-control:focus, .form-select:focus { background-color: #0f172a; border-color: var(--primary-color); color: white; box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.25); }
        .btn-primary { background-color: var(--primary-color); border: none; padding: 10px 20px; }
        .table { color: #e2e8f0; --bs-table-bg: transparent; }
        .table-hover tbody tr:hover { color: #fff; background-color: rgba(255,255,255,0.05); }
        .submenu { list-style: none; padding-left: 0; background: rgba(0,0,0,0.2); margin-bottom: 0; }
        .submenu .nav-link { padding-left: 50px; font-size: 0.9rem; border-left: none; }
        .game-section { border-left: 4px solid var(--primary-color); margin-bottom: 15px; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="brand"><i class="fa-solid fa-cat"></i> MeoU Master</div>
        <nav class="flex-grow-1 overflow-auto">
            <a href="/" class="nav-link ${activeTab === 'home' ? 'active' : ''}"><i class="fas fa-chart-line"></i> Dashboard</a>
            <a href="/install-servers" class="nav-link ${activeTab === 'servers' ? 'active' : ''}"><i class="fas fa-server"></i> Install Servers</a>
            
            <div class="my-2 border-top border-secondary opacity-25"></div>
            <a href="/game-config" class="nav-link ${activeTab === 'game' ? 'active' : ''}"><i class="fas fa-gamepad"></i> Global Game Settings</a>
            
            <div class="nav-item">
                <a class="nav-link ${activeTab.startsWith('shop') ? 'active' : 'collapsed'}" data-bs-toggle="collapse" href="#shopSubmenu">
                    <i class="fas fa-store"></i> Shop Manager <i class="fas fa-chevron-down ms-auto small"></i>
                </a>
                <div class="collapse ${activeTab.startsWith('shop') ? 'show' : ''}" id="shopSubmenu">
                    <ul class="submenu">
                        <li><a href="/shop-config/items" class="nav-link ${activeTab === 'shop-items' ? 'active' : ''}">Shop Items</a></li>
                        <li><a href="/shop-config/gems" class="nav-link ${activeTab === 'shop-gems' ? 'active' : ''}">Gem Market</a></li>
                    </ul>
                </div>
            </div>

            <a href="/users" class="nav-link ${activeTab === 'users' ? 'active' : ''}"><i class="fas fa-users"></i> Global User Manager</a>
            <a href="/settings/wordchain" class="nav-link ${activeTab === 'wordchain' ? 'active' : ''}"><i class="fas fa-link"></i> Wordchain Config</a>
        </nav>
        <div class="p-3">
            <a href="/logout" class="btn btn-outline-danger w-100"><i class="fas fa-sign-out-alt"></i> ƒêƒÉng xu·∫•t</a>
        </div>
    </div>
    <div class="content-wrapper">
        ${bodyContent}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
`;

module.exports = { getBaseHtml };

================================================================================
FILE: database/models.js
================================================================================
// database/models.js
const mongoose = require('mongoose');

// K·∫øt n·ªëi MongoDB
const MONGO_URI = process.env.MONGO_URI; 

if (!MONGO_URI) {
    console.error("‚ùå ERROR: Ch∆∞a c·∫•u h√¨nh MONGO_URI trong file .env!");
} else {
    mongoose.connect(MONGO_URI)
        .then(() => console.log("üçÉ ƒê√£ k·∫øt n·ªëi MongoDB Atlas!"))
        .catch(err => console.error("‚ùå L·ªói k·∫øt n·ªëi MongoDB:", err));
}

// --- 1. USER & ECONOMY (GLOBAL) ---
const userSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    cash: { type: Number, default: 0 },
    bank: { type: Number, default: 0 },
    last_daily: { type: Date, default: null },
    streak: { type: Number, default: 0 }
});
const User = mongoose.model('User', userSchema);

// --- 2. INVENTORY (GLOBAL) ---
const inventorySchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    item_id: { type: String, required: true },
    amount: { type: Number, default: 0 }
});
inventorySchema.index({ user_id: 1, item_id: 1 }, { unique: true });
const Inventory = mongoose.model('Inventory', inventorySchema);

// --- 3. SETTINGS (SERVER SPECIFIC) ---
const settingSchema = new mongoose.Schema({
    guild_id: { type: String, required: true, unique: true },
    prefix: { type: String, default: '.' },
    currency: { type: String, default: 'ü™ô' },
    admin_roles: { type: [String], default: [] }, 
    game_channels: { type: Map, of: String, default: {} },
    
    // Fix l·ªói invalid schema type
    work_min: { type: Number, default: 1000 }, 
    work_max: { type: Number, default: 2000 }, 
    work_cd: { type: Number, default: 25 },
    
    slut_min: { type: Number, default: 2000 }, slut_max: { type: Number, default: 3000 }, slut_cd: { type: Number, default: 25 }, slut_fail: { type: Number, default: 48 },
    crime_min: { type: Number, default: 2000 }, crime_max: { type: Number, default: 3000 }, crime_cd: { type: Number, default: 25 }, crime_fail: { type: Number, default: 48 },
    rob_cd: { type: Number, default: 25 }, rob_fail: { type: Number, default: 48 },
    
    battle_cd: { type: Number, default: 10 } 
});
const Setting = mongoose.model('Setting', settingSchema);

// --- 4. SHOP & ITEMS (GLOBAL) ---
const shopItemSchema = new mongoose.Schema({
    item_id: { type: String, required: true, unique: true },
    stock: { type: Number, default: 0 },
    price: { type: Number, default: 0 }
});
const ShopItemDB = mongoose.model('ShopItem', shopItemSchema);

// --- 5. WORD CHAIN (GLOBAL) ---
const wordChainSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    wins: { type: Number, default: 0 },
    correct_words: { type: Number, default: 0 }
});
const WordChainRank = mongoose.model('WordChainRank', wordChainSchema);

const wordSchema = new mongoose.Schema({
    word: { type: String, required: true, unique: true }
});
const WordDB = mongoose.model('Word', wordSchema);

// --- 6. SYSTEM (SERVER SPECIFIC) ---
const replySchema = new mongoose.Schema({
    guild_id: { type: String, required: true },
    command_type: { type: String, required: true },
    status: { type: String, required: true },
    message: { type: String, required: true }
});
const CustomReply = mongoose.model('CustomReply', replySchema);

const disabledCmdSchema = new mongoose.Schema({
    channel_id: { type: String, required: true },
    command: { type: String, required: true }
});
disabledCmdSchema.index({ channel_id: 1, command: 1 }, { unique: true });
const DisabledCommand = mongoose.model('DisabledCommand', disabledCmdSchema);

// --- 7. ZOO & HUNTING (GLOBAL) ---
const zooSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    animals: { type: Map, of: Number, default: {} } 
});
const Zoo = mongoose.model('Zoo', zooSchema);

const gemHistorySchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    item_id: { type: String, required: true }, 
    item_name: { type: String, required: true },
    time: { type: Date, default: Date.now }
});
const GemHistory = mongoose.model('GemHistory', gemHistorySchema);

const marketHistorySchema = new mongoose.Schema({
    gem_id: { type: String, required: true },
    price: { type: Number, required: true },
    total_in_server: { type: Number, default: 0 },
    time: { type: Date, default: Date.now }
});
marketHistorySchema.index({ gem_id: 1, time: -1 });
const MarketHistory = mongoose.model('MarketHistory', marketHistorySchema);

// --- 8. USER BUFFS (GLOBAL) ---
const userBuffSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    qty_gem_id: { type: String, default: null },
    qty_turns: { type: Number, default: 0 },
    qty_total: { type: Number, default: 0 },
    qual_gem_id: { type: String, default: null },
    qual_turns: { type: Number, default: 0 },
    qual_total: { type: Number, default: 0 }
});
const UserBuff = mongoose.model('UserBuff', userBuffSchema);

// --- 9. BATTLE PROFILE (GLOBAL) ---
const battleProfileSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    team: [{
        id: String,       
        name: String,     
        origin_name: String, 
        level: { type: Number, default: 0 },
        exp: { type: Number, default: 0 },
        joined_at: { type: Date, default: Date.now }
    }],
    win_streak: { type: Number, default: 0 },
    total_matches: { type: Number, default: 0 },
    total_wins: { type: Number, default: 0 },
    last_battle: { type: Date, default: null } 
});
const BattleProfile = mongoose.model('BattleProfile', battleProfileSchema);

// --- 10. GAME SESSION (M·ªöI) ---
const gameSessionSchema = new mongoose.Schema({
    channel_id: { type: String, required: true, unique: true },
    guild_id: { type: String, required: true },
    game_type: { type: String, required: true },
    data: { type: Object, default: {} },
    updated_at: { type: Date, default: Date.now }
});
const GameSession = mongoose.model('GameSession', gameSessionSchema);

module.exports = {
    User, Inventory, Setting, ShopItemDB, 
    WordChainRank, WordDB, 
    CustomReply, DisabledCommand,
    Zoo, GemHistory, MarketHistory, UserBuff,
    BattleProfile, GameSession
};

================================================================================
FILE: emoji.js
================================================================================
module.exports = {
    // --- H·ªÜ TH·ªêNG & UI ---
    SYSTEM: {
        COIN: 'ü™ô',
        FIRE: '<a:Fire:1461148771730718953>',
        UP: '<:up:1461137151109632071>',
        DOWN: '<:down:1461137149435973713>',
        OK: '<a:ok:1457476275525521631>',
        WRONG: '<a:wrong:1457477096023658698>',
        AHA: '<a:aha:1457473109992149033>',
        HOHO: '<a:hoho:1457472609494241330>',
        HEHE: '<a:hehe:1457472388718661713>',
        HAHA: '<a:haha:1457472038980685956>',
        HIHI: '<a:hihi:1457471433302216724>',
        LOADING: '<a:loading:1461163273872474162>'
    },

    // --- V·∫¨T PH·∫®M & H√íM ---
    ITEMS: {
        LOOTBOX: '<:lootbox:1461108775808143370>',
        LOOTBOX_VIP: '<a:lootboxvip:1461108772280733902>',
        LOOTBOX_OPEN: '<a:lootboxopen:1461108774160039998>',
        LOOTBOX_OPENED: '<a:lootboxopened:1461118461186019330>',
        CRATE: '<:crate:1461620337811652688>',
        CRATE_L: '<:createL:1461620199059886091>',
        CRATE_OPEN: '<a:crateopen:1461620332510052446>',
        CRATE_OPENED: '<:crateopened:1461620334611660801>'
    },

    // --- B·∫¢O NG·ªåC (GEMS) ---
    GEMS: {
        gem1: '<:gem1:1461108786822381772>',
        gem2: '<:gem2:1461108784381427898>',
        gem3: '<:gem3:1461108782430945445>',
        gem4: '<:gem4:1461108780434722999>',
        gem5: '<:gem5:1461108778039775345>',
        gem6: '<a:gem6:1461108769898627237>',
        gem7: '<a:gem7:1461108866627403992>',
        // Series A
        gem1a: '<:gem1a:1461570466320875676>',
        gem2a: '<:gem2a:1461570468224958555>',
        gem3a: '<:gem3a:1461570470062063616>',
        gem4a: '<:gem4a:1461570472125796599>',
        gem5a: '<:gem5a:1461570473925152961>',
        gem6a: '<a:gem6a:1461570478215921847>',
        gem7a: '<a:gem7a:1461570480526983273>'
    },

    // --- ZOO SYSTEM ---
    ZOO: {
        // Classes
        CLASSES: {
            U: '<:zooU:1461621603048620032>',
            C: '<:zooC:1461621604818882728>',
            R: '<:zooR:1461621601186349191>',
            E: '<:zooE:1461621599324078090>',
            M: '<:zooM:1461621595423375535>',
            G: '<a:zooG:1461621593662029958>',
            L: '<a:zooL:1461621591212429467>',
            F: '<a:zooF:1461621589153022063>'
        },
        // Godly
        GODLY: {
            camel: '<a:camelG:1461570809482186960>',
            fish: '<a:fishG:1461570812653076532>',
            panda: '<a:pandaG:1461570815014342666>',
            shrimp: '<a:shrimpG:1461570817610481850>',
            spider: '<a:spiderG:1461570820097839168>'
        },
        // Legendary
        LEGENDARY: {
            deer: '<a:deerL:1461570822669078713>',
            fox: '<a:foxL:1461570824749191339>',
            lion: '<a:lionL:1461570827827810328>',
            owl: '<a:owlL:1461570829937672285>',
            squid: '<a:squidL:1461570833108701376>'
        },
        // Fable
        FABLE: {
            pig: '<a:pigF:1461570835491061954>',
            eagle: '<a:eagleF:1461570838263238729>',
            frog: '<a:frogF:1461570840414916648>',
            monkey: '<a:monkeyF:1461570842281382008>',
            dog: '<a:dogF:1461570844990902302>'
        }
    },

    // --- GAME BAUCUA ---
    BAUCUA: {
        bau: '<:bau:1458580293949853706>',
        cua: '<:cua:1458580312354197691>',
        tom: '<:tom:1458575544902746327>',
        ca: '<:ca:1458576361487601807>',
        ga: '<:ga:1458577141804306643>',
        nai: '<:nai:1458577718076506122>'
    },

    // --- ƒêUA NG·ª∞A (HORSES) ---
    HORSES: {
        jack: '<:jack:1458925072780755025>',
        peter: '<:peter:1458925070859894918>',
        ani: '<:ani:1458925068577935436>',
        lan: '<:lan:1458925065566552135>',
        mai: '<:mai:1458925063314080118>',
        kien: '<:kien:1458925061271720191>',
        oanh: '<:dam_oanh:1458925058717126706>',
        hieu: '<:hieu:1458925055995023482>'
    },

    // --- B√ÄI T√ÇY (CARDS) ---
    CARDS: {
        'xx': '<:xx:1458760315729870982>',
        '2d': '<:2d:1458753555216334868>', '2c': '<:2c:1458753576582250589>', '2b': '<:2b:1458753531317325948>', '2a': '<:2a:1458753513512370291>',
        '3d': '<:3d:1458753630634119343>', '3c': '<:3c:1458753620399886420>', '3b': '<:3b:1458753610480619551>', '3a': '<:3a:1458753600217022598>',
        '4d': '<:4d:1458753683637665803>', '4c': '<:4c:1458753681871601804>', '4b': '<:4b:1458753679552151553>', '4a': '<:4a:1458753677429968969>',
        '5d': '<:5d:1458753698313277521>', '5c': '<:5c:1458753696505663604>', '5b': '<:5b:1458753687420670033>', '5a': '<:5a:1458753685428637820>',
        '6d': '<:6d:1458753706844491788>', '6c': '<:6c:1458753704747470993>', '6b': '<:6b:1458753702805372981>', '6a': '<:6a:1458753700196519987>',
        '7d': '<:7d:1458753715061395507>', '7c': '<:7c:1458753712880353310>', '7b': '<:7b:1458753710942326824>', '7a': '<:7a:1458753708467683340>',
        '8d': '<:8d:1458753731129770119>', '8c': '<:8c:1458753728877166680>', '8b': '<:8b:1458753726801248379>', '8a': '<:8a:1458753724531871887>',
        '9d': '<:9d:1458753740180951214>', '9c': '<:9c:1458753737760833618>', '9b': '<:9b:1458753735869206663>', '9a': '<:9a:1458753733583179786>',
        '10d': '<:10d:1458753748863287377>', '10c': '<:10c:1458753746841370624>', '10b': '<:10b:1458753744996012064>', '10a': '<:10a:1458753741783040042>',
        'jd': '<:jd:1458753764323496000>', 'jc': '<:jc:1458753762326745194>', 'jb': '<:jb:1458753760569462846>', 'ja': '<:ja:1458753758384357490>',
        'qd': '<:qd:1458753782312865998>', 'qc': '<:qc:1458753779204886570>', 'qb': '<:qb:1458753776923185305>', 'qa': '<:jq:1458753766231642187>',
        'kd': '<:kd:1458753774519586836>', 'kc': '<:kc:1458753771847946250>', 'kb': '<:kb:1458753770123952293>', 'ka': '<:ka:1458753768022741128>',
        'ad': '<:ad:1458753756932997150>', 'ac': '<:ac:1458753755133644860>', 'ab': '<:ab:1458753752445091840>', 'aa': '<:aa:1458753750616244224>'
    },

    // --- UNO EMOJIS ---
    UNO: {
        YWILD4: '<:YWILD4:1460468462261375007>',
        YWILD: '<:YWILD:1460468460248240320>',
        YSKIP: '<:YSKIP:1460468458125787157>',
        YREVERSE: '<:YREVERSE:1460468456158920840>',
        Yplus2: '<:Yplus2:1460468453591879731>',
        Y9: '<:Y9:1460468451725414502>',
        Y8: '<:Y8:1460468449900757125>',
        Y7: '<:Y7:1460468447984222349>',
        Y6: '<:Y6:1460468445719167007>',
        Y5: '<:Y5:1460468443814826034>',
        Y4: '<:Y4:1460468441654759649>',
        Y3: '<:Y3:1460468439272390698>',
        Y2: '<:Y2:1460468437431353508>',
        Y1: '<:Y1:1460468435422150717>',
        Y0: '<:Y0:1460468432880271402>',
        WILD4: '<:WILD4:1460468429399134220>',
        WILD: '<:WILD:1460468427616555072>',
        RWILD4: '<:RWILD4:1460468424181416000>',
        RWILD: '<:RWILD:1460468422574870621>',
        RSKIP: '<:RSKIP:1460468418947055828>',
        RREVERSE: '<:RREVERSE:1460468416182878263>',
        Rplus2: '<:Rplus2:1460468413041479930>',
        R9: '<:R9:1460468410814173358>',
        R8: '<:R8:1460468408842977584>',
        R7: '<:R7:1460468406888435835>',
        R6: '<:R6:1460468405235617990>',
        R5: '<:R5:1460468403516080383>',
        R4: '<:R4:1460468401712660503>',
        R3: '<:R3:1460468399430959261>',
        R2: '<:R2:1460468397971345428>',
        R1: '<:R1:1460468395383197727>',
        R0: '<:R0:1460468393118531645>',
        GWILD4: '<:GWILD4:1460468389100392644>',
        GWILD: '<:GWILD:1460468386126631139>',
        GSKIP: '<:GSKIP:1460468382859001876>',
        GREVERSE: '<:GREVERSE:1460468380816379904>',
        Gplus2: '<:Gplus2:1460468378866024498>',
        G9: '<:G9:1460468376492183726>',
        G8: '<:G8:1460468374718124154>',
        G7: '<:G7:1460468372801327341>',
        G6: '<:G6:1460468370825809971>',
        G5: '<:G5:1460468369106014347>',
        G4: '<:G4:1460468367214379038>',
        G3: '<:G3:1460468365075419167>',
        G2: '<:G2:1460468363204628621>',
        G1: '<:G1:1460468360885178595>',
        G0: '<:G0:1460468358611865675>',
        BWILD4: '<:BWILD4:1460468355831042242>',
        BWILD: '<:BWILD:1460468353591279658>',
        BSKIP: '<:BSKIP:1460468351607247102>',
        BREVERSE: '<:BREVERSE:1460468349262893300>',
        Bplus2: '<:Bplus2:1460459506512429127>',
        B4: '<:B4:1460454287888089262>',
        B1: '<:B1:1460453721036030062>',
        B3: '<:B3:1460453573669425398>',
        B9: '<:B9:1460453472225984704>',
        B8: '<:B8:1460453470036430933>',
        B7: '<:B7:1460453467335295008>',
        B6: '<:B6:1460453460146262046>',
        B5: '<:B5:1460453458137190678>',
        B2: '<:B2:1460453435890470943>',
        B0: '<:B0:1460453431356690608>'
    }
};

================================================================================
FILE: games/battle.js
================================================================================
// games/battle.js
const { EmbedBuilder } = require('discord.js');
const { BattleProfile, Setting } = require('../database/models'); 
const economy = require('../utils/economy');
const { GAME_CONFIG } = require('../config'); // Import Config ƒë·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ Dashboard
const { ANIMAL_STATS, LEVEL_EXP, calculateStats } = require('./battle_config');
const { HUNT_CONFIG } = require('./hunt_config');
const { removeVietnameseTones } = require('../utils/helpers');

// ID OWNER
const OWNER_ID = '414792622289190917';

// Helper: L·∫•y th√¥ng tin hi·ªÉn th·ªã (Icon, T√™n g·ªëc)
function getAnimalDisplayInfo(id) {
    for (const classKey in HUNT_CONFIG.ANIMALS) {
        const found = HUNT_CONFIG.ANIMALS[classKey].find(a => a.id === id);
        if (found) return found;
    }
    return { name: id, emoji: 'üêæ' };
}

// Helper: T√¨m ID th√∫ t·ª´ t√™n nh·∫≠p v√†o
function resolveAnimalId(keyword) {
    const cleanKey = removeVietnameseTones(keyword.toLowerCase());
    for (const id in ANIMAL_STATS) {
        const info = getAnimalDisplayInfo(id);
        const nameClean = removeVietnameseTones(info.name.toLowerCase());
        if (id === cleanKey || nameClean === cleanKey || nameClean.includes(cleanKey)) {
            return id;
        }
    }
    return null;
}

// --- 1. QU·∫¢N L√ù TEAM (GLOBAL) ---
async function handleTeam(message, args) {
    const userId = message.author.id;
    const subCmd = args[0] ? args[0].toLowerCase() : 'view';

    // T√¨m Profile theo UserID (Global)
    let battleProfile = await BattleProfile.findOne({ user_id: userId });
    if (!battleProfile) {
        battleProfile = await BattleProfile.create({ user_id: userId, team: [] });
    }

    // VIEW TEAM
    if (subCmd === 'view' || subCmd === 'check') {
        if (battleProfile.team.length === 0) {
            return message.reply("üõ°Ô∏è Team c·ªßa b·∫°n ƒëang tr·ªëng! D√πng `.team add <t√™n th√∫>` ƒë·ªÉ th√™m th√∫ v√†o ƒë·ªôi h√¨nh.");
        }

        let desc = "";
        battleProfile.team.forEach((pet, index) => {
            const display = getAnimalDisplayInfo(pet.id);
            const stats = calculateStats(pet.id, pet.level);
            
            const nextLevelExp = LEVEL_EXP[pet.level + 1] || "MAX";
            const expStr = nextLevelExp === "MAX" ? "MAX" : `${pet.exp}/${nextLevelExp}`;

            desc += `**${index + 1}. ${display.emoji} ${pet.name}** (Lv.${pet.level})\n`;
            desc += `‚ù§Ô∏è HP: ${stats.hp} | üõ°Ô∏è Armor: ${stats.armor} | ‚öîÔ∏è Atk: ${stats.atk}\n`;
            desc += `‚ú® EXP: \`${expStr}\`\n\n`;
        });

        const embed = new EmbedBuilder()
            .setTitle(`üõ°Ô∏è ƒê·ªôi H√¨nh C·ªßa ${message.author.username}`)
            .setDescription(desc)
            .setColor('Blue')
            .setFooter({ text: "S·ª≠ d·ª•ng .team remove <t√™n> ƒë·ªÉ lo·∫°i b·ªè th√∫" });
        return message.channel.send({ embeds: [embed] });
    }

    // ADD MEMBER
    if (subCmd === 'add') {
        if (battleProfile.team.length >= 3) return message.reply("‚õî ƒê·ªôi h√¨nh ƒë√£ ƒë·∫ßy (T·ªëi ƒëa 3 th√∫)!");
        
        const animalName = args.slice(1).join(' ');
        if (!animalName) return message.reply("Vui l√≤ng nh·∫≠p t√™n th√∫ c·∫ßn th√™m. VD: `.team add ga`");

        const animalId = resolveAnimalId(animalName);
        if (!animalId) return message.reply("Kh√¥ng t√¨m th·∫•y lo·∫°i th√∫ n√†y trong d·ªØ li·ªáu chi·∫øn ƒë·∫•u.");

        // Check Zoo Global
        const zoo = await economy.getZoo(userId);
        const stock = zoo.animals[animalId] || 0;
        
        if (stock <= 0) return message.reply(`üéí B·∫°n kh√¥ng c√≥ con **${getAnimalDisplayInfo(animalId).name}** n√†o trong kho.`);

        // Tr·ª´ th√∫ Global
        await economy.removeAnimals(userId, animalId, 1);
        
        const displayInfo = getAnimalDisplayInfo(animalId);
        battleProfile.team.push({
            id: animalId,
            name: displayInfo.name,
            origin_name: displayInfo.name,
            level: 0,
            exp: 0
        });
        await battleProfile.save();

        return message.reply(`‚úÖ ƒê√£ tri·ªáu h·ªìi **${displayInfo.emoji} ${displayInfo.name}** v√†o ƒë·ªôi h√¨nh chi·∫øn ƒë·∫•u!`);
    }

    // REMOVE MEMBER
    if (subCmd === 'remove') {
        const targetName = args.slice(1).join(' ').toLowerCase();
        if (!targetName) return message.reply("Nh·∫≠p t√™n th√∫ c·∫ßn lo·∫°i b·ªè. VD: `.team remove ga`");

        const index = battleProfile.team.findIndex(p => 
            p.name.toLowerCase().includes(targetName) || p.origin_name.toLowerCase().includes(targetName)
        );

        if (index === -1) return message.reply("Kh√¥ng t√¨m th·∫•y th√∫ n√†y trong ƒë·ªôi h√¨nh.");

        const petToRemove = battleProfile.team[index];
        
        // Tr·∫£ th√∫ v·ªÅ Zoo Global
        await economy.addAnimals(userId, [{ id: petToRemove.id }]);
        battleProfile.team.splice(index, 1);
        await battleProfile.save();

        return message.reply(`‚ôªÔ∏è ƒê√£ ƒë∆∞a **${petToRemove.name}** v·ªÅ l·∫°i kho th√∫ (Reset t√™n v·ªÅ **${petToRemove.origin_name}**).`);
    }
}

// --- 2. ƒê·ªîI T√äN (GLOBAL) ---
async function handleRename(message, args) {
    if (args.length < 2) return message.reply("C√∫ ph√°p: `.rename <t√™n th√∫ hi·ªán t·∫°i> <t√™n m·ªõi>`");

    const userId = message.author.id;
    
    let battleProfile = await BattleProfile.findOne({ user_id: userId });
    if (!battleProfile || battleProfile.team.length === 0) return message.reply("B·∫°n ch∆∞a c√≥ th√∫ n√†o trong team!");

    const targetKey = args[0].toLowerCase();
    const newName = args.slice(1).join(' ');

    const pet = battleProfile.team.find(p => 
        p.name.toLowerCase().includes(targetKey) || 
        p.origin_name.toLowerCase().includes(targetKey) ||
        p.id === resolveAnimalId(targetKey)
    );

    if (!pet) return message.reply("Kh√¥ng t√¨m th·∫•y th√∫ n√†y trong team.");
    if (newName.length > 20) return message.reply("T√™n qu√° d√†i (T·ªëi ƒëa 20 k√Ω t·ª±).");

    const oldName = pet.name;
    pet.name = newName;
    await battleProfile.save();

    return message.reply(`‚úèÔ∏è ƒê√£ ƒë·ªïi t√™n **${oldName}** th√†nh **${newName}**!`);
}

// --- 3. BATTLE SYSTEM (GLOBAL & DYNAMIC CONFIG) ---
async function handleBattle(message) {
    const userId = message.author.id;

    // 1. L·∫•y Profile Battle Global
    let userProfile = await BattleProfile.findOne({ user_id: userId });
    if (!userProfile) {
        userProfile = await BattleProfile.create({ user_id: userId, team: [] });
    }
    
    if (userProfile.team.length === 0) {
        return message.reply("üö´ B·∫°n ch∆∞a c√≥ th√∫ trong ƒë·ªôi h√¨nh! D√πng `.team add` ƒë·ªÉ thi·∫øt l·∫≠p.");
    }

    // --- COOLDOWN CHECK (L·∫§Y T·ª™ CONFIG DASHBOARD) ---
    // M·∫∑c ƒë·ªãnh 10s n·∫øu config ch∆∞a load k·ªãp
    const cdSeconds = (GAME_CONFIG.battle && GAME_CONFIG.battle.cooldown) ? GAME_CONFIG.battle.cooldown : 10;
    
    const lastBattle = userProfile.last_battle ? userProfile.last_battle.getTime() : 0;
    const now = Date.now();
    const diff = (now - lastBattle) / 1000;

    if (diff < cdSeconds) {
        let wait = Math.ceil(cdSeconds - diff);
        const cooldownMsg = await message.reply(`T·ªï ƒë·ªôi ƒëang h·ªìi s·ª©c. Th·ª≠ l·∫°i sau **${wait}s**`);
        const timer = setInterval(async () => {
            wait--;
            if (wait <= 0) {
                clearInterval(timer); 
                cooldownMsg.delete().catch(() => {}); 
            } else {
                try {
                    await cooldownMsg.edit(`T·ªï ƒë·ªôi ƒëang h·ªìi s·ª©c. Th·ª≠ l·∫°i sau **${wait}s**`);
                } catch (e) {
                    clearInterval(timer);
                }
            }
        }, 1000);
        return; 
    }

    // 2. T√çNH TO√ÅN TH∆Ø·ªûNG D·ª∞A TR√äN CONFIG DASHBOARD
    const totalLevel = userProfile.team.reduce((sum, p) => sum + p.level, 0);
    
    let winRange = [0, 0];
    let configExp = 30;

    // L·∫•y config t·ª´ bi·∫øn to√†n c·ª•c (ƒë∆∞·ª£c dashboard update)
    const bConf = GAME_CONFIG.battle || {
        tier1: { min: 1000, max: 2000, exp: 50 },
        tier2: { min: 2000, max: 4000, exp: 100 },
        tier3: { min: 4000, max: 6000, exp: 150 }
    };

    if (totalLevel < 30) {
        winRange = [bConf.tier1.min, bConf.tier1.max];
        configExp = bConf.tier1.exp;
    } else if (totalLevel <= 50) {
        winRange = [bConf.tier2.min, bConf.tier2.max];
        configExp = bConf.tier2.exp;
    } else { // > 50
        winRange = [bConf.tier3.min, bConf.tier3.max];
        configExp = bConf.tier3.exp;
    }

    // --- LOGIC ƒê·ªò KH√ì (G√°c c·ªïng Streak) ---
    let hardRate = 0.57;
    if (totalLevel >= 30 && totalLevel <= 50) hardRate = 0.62;
    if (totalLevel > 50) hardRate = 0.65;

    let isHard = false;
    
    if (userProfile.win_streak > 0 && userProfile.win_streak % 5 === 0) {
        const streakLuck = Math.random(); 
        if (streakLuck <= 0.46) {
            isHard = Math.random() < hardRate;
        } else {
            isHard = true; 
        }
    } else {
        isHard = Math.random() < hardRate;
    }

    // --- GENERATE ENEMY ---
    const avgLevel = Math.floor(totalLevel / userProfile.team.length);
    const enemyTeamSize = 3;
    const enemyTeam = [];
    const allAnimalIds = Object.keys(ANIMAL_STATS);
    const validEnemyAnimals = allAnimalIds.filter(id => ANIMAL_STATS[id].class !== 'C');
    const poolToPick = validEnemyAnimals.length > 0 ? validEnemyAnimals : allAnimalIds;

    for (let i = 0; i < enemyTeamSize; i++) {
        const randId = poolToPick[Math.floor(Math.random() * poolToPick.length)];
        const info = getAnimalDisplayInfo(randId);
        
        let botLvl;
        if (isHard) {
            botLvl = avgLevel + Math.floor(Math.random() * 4) + 3; 
        } else {
            botLvl = Math.max(0, avgLevel - Math.floor(Math.random() * 4));
        }
        
        const stats = calculateStats(randId, botLvl);
        enemyTeam.push({
            id: randId,
            name: `Wild ${info.name}`,
            emoji: info.emoji,
            level: botLvl,
            hp: stats.hp,
            max_hp: stats.max_hp,
            armor: stats.armor, 
            max_armor: stats.armor, 
            atk: stats.atk
        });
    }

    // --- PREPARE USER TEAM ---
    const userTeamBattle = userProfile.team.map(p => {
        const stats = calculateStats(p.id, p.level);
        const info = getAnimalDisplayInfo(p.id);
        return {
            ...p.toObject(),
            emoji: info.emoji,
            hp: stats.hp,
            max_hp: stats.max_hp,
            armor: stats.armor, 
            max_armor: stats.armor, 
            atk: stats.atk
        };
    });

    // --- BATTLE SIMULATION ---
    let round = 1;
    const maxRounds = 20;

    const dealDamage = (attacker, defender) => {
        if (defender.hp <= 0) return;
        const damage = attacker.atk;
        const isArmorHit = Math.random() < 0.5; 

        if (isArmorHit && defender.armor > 0) {
            defender.armor -= damage;
            if (defender.armor < 0) {
                defender.hp += defender.armor; 
                defender.armor = 0;
            }
        } else {
            defender.hp -= damage;
        }
    };

    while (userTeamBattle.some(p => p.hp > 0) && enemyTeam.some(p => p.hp > 0) && round <= maxRounds) {
        userTeamBattle.forEach((u, idx) => {
            if (u.hp <= 0) return;
            let target = enemyTeam[idx];
            if (!target || target.hp <= 0) target = enemyTeam.find(e => e.hp > 0);
            if (target) dealDamage(u, target);
        });

        enemyTeam.forEach((e, idx) => {
            if (e.hp <= 0) return;
            let target = userTeamBattle[idx];
            if (!target || target.hp <= 0) target = userTeamBattle.find(u => u.hp > 0);
            if (target) dealDamage(e, target);
        });
        round++;
    }

    // --- K·∫æT QU·∫¢ ---
    const userWin = userTeamBattle.some(p => p.hp > 0);
    const resultColor = userWin ? 'Green' : 'Red';
    
    let moneyMsg = "";
    let expGained = 0;
    let streakBonus = "";

    if (userWin) {
        // T√çNH TI·ªÄN THEO DASHBOARD
        const moneyReward = Math.floor(Math.random() * (winRange[1] - winRange[0] + 1)) + winRange[0];
        
        // C·ªông ti·ªÅn Global
        await economy.addMoney(userId, moneyReward);
        moneyMsg = `+${moneyReward.toLocaleString()} ü™ô`;

        // T√çNH EXP THEO DASHBOARD
        const baseExp = configExp;
        const bonusMultiplier = 1 + (userProfile.win_streak * 0.05);
        expGained = Math.floor(baseExp * bonusMultiplier);
        
        userProfile.win_streak += 1;
        userProfile.total_wins += 1;
        
        if (userProfile.win_streak > 1) streakBonus = `(Streak ${userProfile.win_streak} üî•)`;
    } else {
        moneyMsg = `0 ü™ô`;
        userProfile.win_streak = 0;
        expGained = 10;
    }
    userProfile.total_matches += 1;

    for (const pet of userProfile.team) {
        pet.exp += expGained;
        while (pet.level < 25 && pet.exp >= LEVEL_EXP[pet.level + 1]) {
            pet.level++;
        }
        if (pet.level >= 25) pet.exp = LEVEL_EXP[25];
    }
    
    userProfile.last_battle = now;
    await userProfile.save();

    // --- HI·ªÇN TH·ªä EMBED ---
    const s = '\u00A0\u00A0'; 
    const sep = '\u00A0\u00A0'; 

    const renderUnit = (unit) => {
        const dead = unit.hp <= 0;
        const hpStr = `${Math.max(0, unit.hp)}/${unit.max_hp}`;
        const armorStr = `${Math.max(0, unit.armor)}/${unit.max_armor}`;
        const icon = unit.emoji; 
        const deadMarker = dead ? "üíÄ" : "";
        const levelStr = unit.level.toString().padEnd(2, ' ');
        return `lv.${levelStr}|${icon}${s}\`[${hpStr}]\`${sep}\`[${armorStr}]\`${sep}\`[${unit.atk}]\`${deadMarker}`;
    };

    let userField = "";
    userTeamBattle.forEach(p => userField += renderUnit(p) + "\n");

    let enemyField = "";
    enemyTeam.forEach(p => enemyField += renderUnit(p) + "\n");

    const embed = new EmbedBuilder()
        .setTitle(`**ƒê·∫•u Tr∆∞·ªùng Th√∫** - ${userWin ? "Chi·∫øn Th·∫Øng" : "Th·∫•t B·∫°i"}`)
        .setColor(resultColor)
        .setDescription(`-------------------------------------
**${message.author.username}** \u00A0\u00A0\u00A0\u00A0 HP \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 AMR \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 ATK
${userField}==============================
${enemyField}==============================

**K·∫øt Qu·∫£:** ${moneyMsg}
**Kinh Nghi·ªám:** +${expGained} EXP ${streakBonus}`);

    message.channel.send({ embeds: [embed] });
}

// --- 4. XEM INFO TH√ö (GLOBAL) ---
async function handleBattleInfo(message, args) {
    if (args.length === 0) return message.reply("C√∫ ph√°p: `.binfo <t√™n th√∫>`");
    
    const userId = message.author.id;
    const keyword = args.join(' ').toLowerCase();

    let battleProfile = await BattleProfile.findOne({ user_id: userId });
    let targetPet = null;
    let isTeamPet = false;

    if (battleProfile && battleProfile.team.length > 0) {
        targetPet = battleProfile.team.find(p => 
            p.name.toLowerCase().includes(keyword) || 
            p.origin_name.toLowerCase().includes(keyword)
        );
    }

    let stats = null;
    let displayInfo = null;
    let petName = "";
    let levelDisplay = 0;

    if (targetPet) {
        isTeamPet = true;
        const animalId = targetPet.id;
        displayInfo = getAnimalDisplayInfo(animalId);
        stats = calculateStats(animalId, targetPet.level);
        petName = targetPet.name; 
        levelDisplay = targetPet.level;
    } else {
        const animalId = resolveAnimalId(keyword);
        if (!animalId) return message.reply("Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ lo√†i th√∫ n√†y (Ch∆∞a s·ªü h·ªØu ho·∫∑c t√™n sai).");
        
        displayInfo = getAnimalDisplayInfo(animalId);
        stats = calculateStats(animalId, 0); 
        petName = displayInfo.name; 
        levelDisplay = 0;
    }

    const embed = new EmbedBuilder()
        .setColor(isTeamPet ? 'Green' : 'Blue')
        .setTitle(`üìñ Th√¥ng Tin Th√∫ C∆∞ng`)
        .setDescription(
            `**${petName}** ${displayInfo.emoji}\n` +
            `|M√°u: \`[${stats.hp}]\`\n` +
            `|Gi√°p: \`[${stats.armor}]\`\n` +
            `|C√¥ng: \`[${stats.atk}]\``
        );
        
    if (isTeamPet) {
        embed.setFooter({ text: `Level: ${levelDisplay} | EXP: ${targetPet.exp}` });
    } else {
        embed.setFooter({ text: "Th√¥ng s·ªë c∆° b·∫£n (Level 0)" });
    }

    message.channel.send({ embeds: [embed] });
}

// --- 5. SET COOLDOWN (CH·ªà OWNER) ---
async function handleSetBattleCooldown(message, args) {
    if (message.author.id !== OWNER_ID) {
        return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn admin.");
    }
    
    const time = parseInt(args[0]);
    if (isNaN(time) || time < 0) return message.reply("Vui l√≤ng nh·∫≠p th·ªùi gian (gi√¢y) h·ª£p l·ªá.");
    
    // C·∫≠p nh·∫≠t RAM ngay l·∫≠p t·ª©c
    if (GAME_CONFIG.battle) {
        GAME_CONFIG.battle.cooldown = time;
    }

    // N·∫øu mu·ªën l∆∞u l√¢u d√†i v√†o Setting (t√πy ch·ªçn)
    // await economy.updateConfig(message.guild.id, 'battle_cd', time);
    
    return message.reply(`‚úÖ ƒê√£ thi·∫øt l·∫≠p th·ªùi gian h·ªìi chi√™u Battle l√† **${time}s** (√Åp d·ª•ng ngay).`);
}

module.exports = { handleTeam, handleRename, handleBattle, handleBattleInfo, handleSetBattleCooldown };

================================================================================
FILE: games/battle_config.js
================================================================================
// games/battle_config.js

// B·∫£ng Stats M·ªõi (C√≥ th√™m ch·ªâ s·ªë Attack)
const ANIMAL_STATS = {
    // --- CLASS C ---
    'sen': { hp: 50, armor: 30, atk: 35, class: 'C' },
    'kien': { hp: 65, armor: 25, atk: 30, class: 'C' },
    'ong': { hp: 75, armor: 20, atk: 25, class: 'C' },
    'buom': { hp: 85, armor: 15, atk: 20, class: 'C' },
    'sau': { hp: 100, armor: 10, atk: 15, class: 'C' },

    // --- CLASS U ---
    'meo': { hp: 110, armor: 60, atk: 65, class: 'U' },
    'soc': { hp: 135, armor: 52, atk: 58, class: 'U' },
    'doi': { hp: 155, armor: 45, atk: 52, class: 'U' },
    'ga': { hp: 180, armor: 37, atk: 46, class: 'U' },
    'vit': { hp: 200, armor: 30, atk: 40, class: 'U' },

    // --- CLASS R ---
    'cong': { hp: 210, armor: 70, atk: 95, class: 'R' },
    'cuu': { hp: 235, armor: 65, atk: 85, class: 'R' },
    'ngua': { hp: 260, armor: 60, atk: 75, class: 'R' },
    'bo': { hp: 285, armor: 55, atk: 68, class: 'R' },
    'voi': { hp: 300, armor: 50, atk: 60, class: 'R' },

    // --- CLASS E ---
    'vet': { hp: 310, armor: 80, atk: 125, class: 'E' },
    'khi_dot': { hp: 335, armor: 75, atk: 115, class: 'E' }, // Mapping 'Kh·ªâ'
    'bao': { hp: 360, armor: 70, atk: 100, class: 'E' },
    'ho': { hp: 385, armor: 65, atk: 90, class: 'E' },
    'te_giac': { hp: 400, armor: 60, atk: 80, class: 'E' },

    // --- CLASS M ---
    'cong_than': { hp: 415, armor: 90, atk: 160, class: 'M' },
    'phuong': { hp: 435, armor: 86, atk: 150, class: 'M' },
    'ki_lan': { hp: 455, armor: 82, atk: 140, class: 'M' },
    'nguoi_tuyet': { hp: 475, armor: 78, atk: 130, class: 'M' },
    'khung_long': { hp: 490, armor: 74, atk: 120, class: 'M' },
    'ca_voi': { hp: 500, armor: 70, atk: 110, class: 'M' },

    // --- CLASS G ---
    'tom': { hp: 510, armor: 100, atk: 190, class: 'G' },
    'nhen': { hp: 535, armor: 95, atk: 175, class: 'G' },
    'ca': { hp: 560, armor: 90, atk: 160, class: 'G' },
    'lac_da': { hp: 585, armor: 85, atk: 145, class: 'G' },
    'gau_truc': { hp: 600, armor: 80, atk: 130, class: 'G' },

    // --- CLASS L ---
    'cu': { hp: 610, armor: 120, atk: 220, class: 'L' },
    'cao': { hp: 635, armor: 115, atk: 205, class: 'L' },
    'huu': { hp: 660, armor: 110, atk: 190, class: 'L' },
    'bach_tuoc': { hp: 685, armor: 105, atk: 175, class: 'L' },
    'su_tu': { hp: 700, armor: 100, atk: 160, class: 'L' },

    // --- CLASS F ---
    'ech': { hp: 900, armor: 150, atk: 300, class: 'F' },
    'chim_ung': { hp: 915, armor: 142, atk: 285, class: 'F' },
    'khi_f': { hp: 930, armor: 135, atk: 275, class: 'F' }, // Kh·ªâ Th·∫ßn
    'cho_f': { hp: 945, armor: 128, atk: 265, class: 'F' }, // Ch√≥
    'heo_f': { hp: 960, armor: 120, atk: 250, class: 'F' }, // Heo
};

// B·∫£ng EXP c·∫ßn ƒë·ªÉ l√™n c·∫•p (Cumulative)
const LEVEL_EXP = [
    0,      // Lv 0
    50,     // Lv 1
    200,    // Lv 2
    450,    // Lv 3
    800,    // Lv 4
    1300,   // Lv 5 (M·ªëc 1)
    2000,   // Lv 6
    2950,   // Lv 7
    4200,   // Lv 8
    5800,   // Lv 9
    7800,   // Lv 10 (M·ªëc 2)
    10300,  // Lv 11
    13400,  // Lv 12
    17200,  // Lv 13
    21800,  // Lv 14
    27300,  // Lv 15 (M·ªëc 3)
    33800,  // Lv 16
    41400,  // Lv 17
    50200,  // Lv 18
    60300,  // Lv 19
    71800,  // Lv 20 (M·ªëc 4)
    84800,  // Lv 21
    99800,  // Lv 22
    117300, // Lv 23
    137800, // Lv 24
    162800  // Lv 25 (Max)
];

// M·ªëc Buff theo Level
const MILESTONES = {
    5:  { hp_bonus_pct: 0.15, armor_bonus: 5 },
    10: { hp_bonus_pct: 0.35, armor_bonus: 15 },
    15: { hp_bonus_pct: 0.60, armor_bonus: 30 },
    20: { hp_bonus_pct: 0.75, armor_bonus: 40 },
    25: { hp_bonus_pct: 0.90, armor_bonus: 50 }
};

// H√†m t√≠nh ch·ªâ s·ªë th·ª±c t·∫ø d·ª±a tr√™n Level
function calculateStats(animalId, level) {
    const base = ANIMAL_STATS[animalId];
    if (!base) return null; // Th√∫ kh√¥ng t·ªìn t·∫°i trong config battle

    // T√¨m m·ªëc level cao nh·∫•t ƒë√£ ƒë·∫°t ƒë∆∞·ª£c
    let milestone = { hp_bonus_pct: 0, armor_bonus: 0 };
    
    if (level >= 25) milestone = MILESTONES[25];
    else if (level >= 20) milestone = MILESTONES[20];
    else if (level >= 15) milestone = MILESTONES[15];
    else if (level >= 10) milestone = MILESTONES[10];
    else if (level >= 5)  milestone = MILESTONES[5];

    // T√≠nh to√°n HP
    const finalHp = Math.floor(base.hp * (1 + milestone.hp_bonus_pct));
    
    // T√≠nh to√°n Armor
    const finalArmor = base.armor + milestone.armor_bonus;
    
    // T√≠nh to√°n ATK: TƒÉng 2% m·ªói level (ƒë·ªÉ c√¢n b·∫±ng v·ªõi l∆∞·ª£ng m√°u tƒÉng)
    const finalAtk = Math.floor(base.atk * (1 + (level * 0.02))); 

    return {
        ...base,
        hp: finalHp,
        max_hp: finalHp,
        armor: finalArmor, // Max Armor
        max_armor: finalArmor,
        atk: finalAtk
    };
}

module.exports = { ANIMAL_STATS, LEVEL_EXP, MILESTONES, calculateStats };

================================================================================
FILE: games/baucua.js
================================================================================
// games/baucua.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType, MessageFlags, AttachmentBuilder } = require('discord.js');
const fs = require('fs');
const { GAME_CONFIG, ANIMALS, CURRENCY } = require('../config');
const economy = require('../utils/economy');
const { parseBetAmount } = require('../utils/helpers');

// Map ƒë·ªÉ l∆∞u session cho t·ª´ng k√™nh ri√™ng bi·ªát
const activeBauCuaSessions = new Map();

function resolveAnimal(keyword) {
    if (!keyword) return null;
    keyword = keyword.toLowerCase();
    for (const [key, data] of Object.entries(ANIMALS)) {
        if (data.keywords.includes(keyword)) return key;
    }
    return null;
}

// X·ª≠ l√Ω l·ªánh .bc
async function handleBauCua(message, args, client) {
    const animalArg = args[0];
    const amountArg = args[1];
    // const guildId = message.guild.id; // B·ªè
    const channelId = message.channel.id;
    const userId = message.author.id;
    const displayName = message.member ? message.member.displayName : message.author.username;

    const currentSession = activeBauCuaSessions.get(channelId);

    // CASE 1: M·ªü b√†n ho·∫∑c xem b√†n
    if (!animalArg) {
        if (currentSession) return message.reply("B√†n B·∫ßu Cua t·∫°i k√™nh n√†y ƒëang m·ªü r·ªìi, ƒë·∫∑t nhanh ƒëi b·∫°n!");
        await startBauCuaGame(message, client);
        return;
    }

    // CASE 2: ƒê·∫∑t c∆∞·ª£c nhanh (.bc bau 10k)
    const animalKey = resolveAnimal(animalArg);
    if (!animalKey) return message.reply("T√™n con v·∫≠t kh√¥ng ƒë√∫ng! (bau, cua, tom, ca, ga, nai)");

    let amount = 0;
    if (amountArg && amountArg.toLowerCase() === 'all') {
        const balance = await economy.getBalance(userId); // Global Check
        amount = balance.cash > GAME_CONFIG.maxBetBauCua ? GAME_CONFIG.maxBetBauCua : balance.cash;
    } else {
        amount = parseBetAmount(amountArg);
    }

    if (amount <= 0) return message.reply("Ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá!");

    if (!currentSession) {
        await startBauCuaGame(message, client);
    }
    // Global bet
    await placeBauCuaBet(userId, displayName, animalKey, amount, message);
}

async function startBauCuaGame(message, client) {
    const channelId = message.channel.id;
    if (activeBauCuaSessions.has(channelId)) return;

    const imagePath = './baucua.jpg';
    let attachment = null;
    if (fs.existsSync(imagePath)) attachment = new AttachmentBuilder(imagePath);

    const timeWait = GAME_CONFIG.bauCuaTime || 30; 
    const getEmbedDescription = (timeString) => {
        return "üëâCh·ªçn c·ª≠a v√† ƒë·∫∑t c∆∞·ª£c b·∫±ng n√∫t ho·∫∑c l·ªánh `.bc <con> <ti·ªÅn>`\n" +
            "üëâNh√† c√°i s·∫Ω ch·ªù b·∫°n trong **30s**.\n" +
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
            "**Tr·∫°ng th√°i:** ƒêang nh·∫≠n c∆∞·ª£c\n" +
            `üïí **Th·ªùi gian:** ${timeString}`;
    };

    const embed = new EmbedBuilder()
        .setTitle("MeoU Casino - B·∫ßu Cua T√¥m C√°")
        .setDescription(getEmbedDescription(`**${timeWait}s**`))
        .setColor('Gold')
        .setThumbnail(client.user.displayAvatarURL())
        .setFooter({ text: "Uy t√≠n - Xanh ch√≠n | MeoU Casino", iconURL: client.user.displayAvatarURL() });

    if (attachment) embed.setImage('attachment://baucua.jpg');

    const createBtn = (id, label, emoji, style) => new ButtonBuilder().setCustomId(id).setLabel(label).setEmoji(emoji).setStyle(style);
    
    const animalButtons1 = new ActionRowBuilder();
    const animalButtons2 = new ActionRowBuilder();
    let count = 0;
    for (const [key, data] of Object.entries(ANIMALS)) {
        const btn = createBtn(`animal_${key}`, data.name, data.emoji, data.style);
        if (count < 3) animalButtons1.addComponents(btn); else animalButtons2.addComponents(btn);
        count++;
    }
    
    const amountButtons1 = new ActionRowBuilder();
    const amountButtons2 = new ActionRowBuilder();
    const betLevels = [1000, 2000, 5000, 10000, 15000, 20000, 25000, 50000];

    betLevels.forEach((amt, index) => {
        const btn = createBtn(`amount_${amt}`, `${amt}`, 'ü™ô', ButtonStyle.Secondary);
        if (index < 4) amountButtons1.addComponents(btn); 
        else amountButtons2.addComponents(btn); 
    });

    const sendOptions = { 
        embeds: [embed], 
        components: [animalButtons1, animalButtons2, amountButtons1, amountButtons2] 
    };
    if (attachment) sendOptions.files = [attachment];

    const gameMsg = await message.channel.send(sendOptions);

    const sessionData = {
        userBets: {}, 
        tempSelections: {}, 
        message: gameMsg,
        startTime: Date.now()
    };
    activeBauCuaSessions.set(channelId, sessionData);

    let timeLeft = timeWait;
    const timerInterval = setInterval(async () => {
        timeLeft--;
        if (timeLeft < 0) { clearInterval(timerInterval); return; }
        const currentS = activeBauCuaSessions.get(channelId);
        if (!currentS) { clearInterval(timerInterval); return; }

        try { if (timeLeft % 5 === 0 || timeLeft <= 5) await gameMsg.edit({ embeds: [EmbedBuilder.from(embed).setDescription(getEmbedDescription(`**${timeLeft}s**`))] }); } catch (e) {}
    }, 1000);

    const collector = gameMsg.createMessageComponentCollector({ componentType: ComponentType.Button, time: timeWait * 1000 });

    collector.on('collect', async (interaction) => {
        const userId = interaction.user.id;
        const displayName = interaction.member ? interaction.member.displayName : interaction.user.globalName;
        const session = activeBauCuaSessions.get(interaction.channelId);

        if (!session) {
             return interaction.reply({ content: "V√°n ch∆°i ƒë√£ k·∫øt th√∫c!", flags: MessageFlags.Ephemeral });
        }

        if (interaction.customId.startsWith('animal_')) {
            const animalKey = interaction.customId.replace('animal_', '');
            session.tempSelections[userId] = animalKey;
            
            await interaction.reply({ 
                content: `üëå B·∫°n ƒë√£ ch·ªçn **${ANIMALS[animalKey].emoji} ${ANIMALS[animalKey].name.trim()}**. H√£y ch·ªçn ti·ªÅn c∆∞·ª£c!`, 
                flags: MessageFlags.Ephemeral 
            });
            setTimeout(() => interaction.deleteReply().catch(() => {}), 3000);
        } 
        else if (interaction.customId.startsWith('amount_')) {
            if (!session.tempSelections[userId]) {
                const warn = await interaction.reply({ content: "Ch·ªçn con v·∫≠t tr∆∞·ªõc ƒë√£ b·∫°n ∆°i!", flags: MessageFlags.Ephemeral });
                setTimeout(() => interaction.deleteReply().catch(() => {}), 3000);
                return;
            }
            const amount = parseInt(interaction.customId.replace('amount_', ''));
            const animalKey = session.tempSelections[userId];
            
            // Global Bet
            await placeBauCuaBet(userId, displayName, animalKey, amount, interaction);
            if (activeBauCuaSessions.get(interaction.channelId)) {
                delete activeBauCuaSessions.get(interaction.channelId).tempSelections[userId];
            }
        }
    });

    collector.on('end', async () => {
        const finishedSession = activeBauCuaSessions.get(channelId);
        activeBauCuaSessions.delete(channelId);
        clearInterval(timerInterval);

        const endEmbed = EmbedBuilder.from(embed).setDescription(getEmbedDescription("üî¥ ƒê√£ k·∫øt th√∫c")).setColor('Grey');
        try { await gameMsg.edit({ embeds: [endEmbed], components: [] }); } catch (e) {}

        const keys = Object.keys(ANIMALS);
        const results = [keys[Math.floor(Math.random()*keys.length)], keys[Math.floor(Math.random()*keys.length)], keys[Math.floor(Math.random()*keys.length)]];
        const resultString = results.map(k => `${ANIMALS[k].emoji} ${ANIMALS[k].name.trim()}`).join("  |  ");

        const resultLines = [];
        let hasWinner = false;

        if (finishedSession && finishedSession.userBets) {
            for (const [userId, userData] of Object.entries(finishedSession.userBets)) {
                let totalUserPayout = 0;
                const betsAggregated = {};
                for (const bet of userData.bets) {
                    if (!betsAggregated[bet.animal]) betsAggregated[bet.animal] = { count: 0, totalAmount: 0 };
                    betsAggregated[bet.animal].count += 1;
                    betsAggregated[bet.animal].totalAmount += bet.amount;
                    
                    const hitCount = results.filter(r => r === bet.animal).length;
                    if (hitCount > 0) totalUserPayout += (bet.amount + (bet.amount * hitCount));
                }
                const betDisplayString = Object.entries(betsAggregated).map(([k, d]) => `**${d.totalAmount.toLocaleString()}** ${CURRENCY} v√†o **${d.count}** ${ANIMALS[k].emoji}`).join(" + ");
                
                if (totalUserPayout > 0) {
                    hasWinner = true;
                    // Global Add Money
                    await economy.addMoney(userId, totalUserPayout, "Th·∫Øng B·∫ßu Cua");
                    resultLines.push(`üü¢ <@${userId}> ƒë√£ c∆∞·ª£c ${betDisplayString} v√† ƒÉn **${totalUserPayout.toLocaleString()}** ${CURRENCY}`);
                } else {
                    resultLines.push(`üî¥ ${userData.name} ƒë√£ c∆∞·ª£c ${betDisplayString} v√† m·∫•t s·∫°ch!`);
                }
            }
        }
        
        if (!hasWinner && resultLines.length > 0) resultLines.push("\n<a:haha:1457472038980685956> Nh√† c√°i h√∫p tr·ªçn ·ªï!");

        const resultEmbed = new EmbedBuilder()
            .setTitle("<a:hihi:1457471433302216724> K·∫æT QU·∫¢ B·∫¶U CUA <a:hihi:1457471433302216724>")
            .setDescription(`## ${resultString}`)
            .setColor('Red')
            .addFields({ name: "üìú T·ªîNG K·∫æT", value: resultLines.length > 0 ? resultLines.join("\n") : "Kh√¥ng c√≥ ai ƒë·∫∑t c∆∞·ª£c.", inline: false })
            .setFooter({ text: "C·∫£m ∆°n ƒë√£ c·ªëng hi·∫øn!", iconURL: client.user.displayAvatarURL() }).setTimestamp();
        await message.channel.send({ embeds: [resultEmbed] });
    });
}

// H√†m n√†y ƒë√£ b·ªè guildId
async function placeBauCuaBet(userId, displayName, animalKey, amount, context) {
    const channelId = context.channel.id;
    const session = activeBauCuaSessions.get(channelId);

    const sendAndClear = async (content, isEphemeral = false) => {
        try {
            if (context.isButton && context.isButton()) {
                if (context.deferred || context.replied) {
                    await context.followUp({ content, flags: isEphemeral ? MessageFlags.Ephemeral : undefined });
                } else {
                    await context.reply({ content, flags: isEphemeral ? MessageFlags.Ephemeral : undefined });
                }
                setTimeout(() => context.deleteReply().catch(() => {}), 3000);
            } else {
                const msg = await context.channel.send(content);
                setTimeout(() => msg.delete().catch(() => {}), 3000);
            }
        } catch (e) {
            console.error("L·ªói khi g·ª≠i/x√≥a tin nh·∫Øn:", e);
        }
    };

    if (!session) return sendAndClear("B√†n c∆∞·ª£c ƒë√£ ƒë√≥ng ho·∫∑c ch∆∞a m·ªü!", true);
    if (amount > GAME_CONFIG.maxBetBauCua) return sendAndClear(`‚õî Ch·ªâ nh·∫≠n c∆∞·ª£c t·ªëi ƒëa **${GAME_CONFIG.maxBetBauCua.toLocaleString()}** th√¥i!`, true);

    // Global Check
    const balance = await economy.getBalance(userId);
    if (balance.cash < amount) return sendAndClear(`**Kh√¥ng ƒë·ªß ti·ªÅn m·∫∑t!** (C√≥ ${balance.cash.toLocaleString()} ${CURRENCY})`, true);

    // Global Deduct
    const success = await economy.subtractMoney(userId, amount, `Bet Bau Cua: ${ANIMALS[animalKey].name.trim()}`);
    if (success) {
        if (!session.userBets[userId]) session.userBets[userId] = { name: displayName, bets: [] };
        session.userBets[userId].bets.push({ animal: animalKey, amount: amount });

        const embed = new EmbedBuilder()
            .setColor('LuminousVividPink') 
            .setDescription(`üî• <@${userId}> ƒë√£ c∆∞·ª£c **${amount.toLocaleString()}** ${CURRENCY} v√†o **${ANIMALS[animalKey].emoji} ${ANIMALS[animalKey].name.trim()}**!`);

        if (context.isButton && context.isButton()) {
            if (context.deferred || context.replied) await context.followUp({ embeds: [embed] });
            else await context.reply({ embeds: [embed] });
        } else {
            await context.channel.send({ embeds: [embed] });
        }
    } else {
        await sendAndClear("L·ªói h·ªá th·ªëng.", true);
    }
}

module.exports = { handleBauCua };

================================================================================
FILE: games/chicken.js
================================================================================
// games/chicken.js
const { EmbedBuilder } = require('discord.js');
const { GAME_CONFIG, CURRENCY } = require('../config');
const economy = require('../utils/economy');
const { parseBetAmount } = require('../utils/helpers');

const chickenSessions = {}; 
const cockFightStats = {}; 

async function handleChicken(message, args) {
    const userId = message.author.id;
    // const guildId = message.guild.id; // B·ªè

    // X·ª≠ l√Ω khi ƒëang d√πng Chicken Box (ƒê√° g√† mi·ªÖn ph√≠/theo l∆∞·ª£t)
    if (!args[0] && chickenSessions[userId]) {
        const session = chickenSessions[userId];
        if (Date.now() - session.startTime > 120000) {
            clearInterval(session.timer);
            delete chickenSessions[userId];
            return message.reply("G√† ch·∫øt gi√† r·ªìi. Mua con kh√°c ƒë√™!");
        }
        const isWin = Math.random() < GAME_CONFIG.winRateChickenBox;
        if (isWin) {
            session.wins++;
            let reward = 0;
            if (session.wins === 1) reward = 20000;
            if (session.wins === 2) reward = 15000;
            if (session.wins === 3) reward = 25000;

            // Global Add Money
            await economy.addMoney(userId, reward, "Chicken Fight Win");
            message.reply(`<:ga:1458577141804306643> c·ªßa b·∫°n ƒë√° th·∫Øng v√† mang v·ªÅ cho b·∫°n **${reward.toLocaleString()}** ${CURRENCY}`);

            if (session.wins >= 3) {
                clearInterval(session.timer);
                delete chickenSessions[userId];
                message.reply(`**G√† ƒêi√™n Xu·∫•t Hi·ªán!** G√† c·ªßa <@${userId}> ƒë√£ th·∫Øng th√¥ng 3 tr·∫≠n li√™n ti·∫øp v√† mang v·ªÅ **60,000** ${CURRENCY} G√† s·∫Ω ƒë∆∞·ª£c thu h·ªìi ƒë·ªÉ ti√™u h·ªßy`);
            }
        } else {
            clearInterval(session.timer);
            delete chickenSessions[userId];
            message.reply(`ü™¶ **G√† c·ªßa b·∫°n ƒë√£ t·ª≠ tr·∫≠n!** Tr√≤ ch∆°i k·∫øt th√∫c.`);
        }
        return;
    }

    // X·ª≠ l√Ω ƒë√° g√† th∆∞·ªùng (C∆∞·ª£c ti·ªÅn)
    let betAmount = 0;
    let balance = null;

    if (args[0] && args[0].toLowerCase() === 'all') {
        balance = await economy.getBalance(userId); // Global
        betAmount = balance.cash > GAME_CONFIG.maxBetDaGa ? GAME_CONFIG.maxBetDaGa : balance.cash;
    } else {
        betAmount = parseBetAmount(args[0]);
    }

    if (!args[0]) return message.reply("Nh·∫≠p ti·ªÅn v√†o b·∫°n ∆°i! VD: `.dg 5000` ho·∫∑c `.dg all`");
    if (betAmount <= 0) return message.reply("Ti·ªÅn c∆∞·ª£c t√†o lao!");
    if (betAmount > GAME_CONFIG.maxBetDaGa) return message.reply(`C∆∞·ª£c t·ªëi ƒëa **${GAME_CONFIG.maxBetDaGa.toLocaleString()}** th√¥i!`);

    if (!balance) balance = await economy.getBalance(userId); // Global
    if (balance.cash < betAmount) return message.reply(`Kh√¥ng ƒë·ªß ti·ªÅn! B·∫°n ch·ªâ c√≥ ${balance.cash.toLocaleString()} ${CURRENCY}`);
    
    // Global Deduct
    const success = await economy.subtractMoney(userId, betAmount, "Bet Chicken Fight");
    if (!success) return message.reply("L·ªói tr·ª´ ti·ªÅn.");

    if (!cockFightStats[userId]) cockFightStats[userId] = 0; 
    let winRate = GAME_CONFIG.winRateDaGaBase + (cockFightStats[userId] * 0.01); 
    if (winRate > GAME_CONFIG.winRateDaGaMax) winRate = GAME_CONFIG.winRateDaGaMax;
    
    const isWin = Math.random() < winRate;
    const embed = new EmbedBuilder().setAuthor({ name: "MeoU Mi·ªÅn T√¢y - ƒê√° G√†", iconURL: message.author.displayAvatarURL() });

    if (isWin) {
        cockFightStats[userId]++;
        const winAmount = betAmount * 2; 
        // Global Add Money
        await economy.addMoney(userId, winAmount, "Win Chicken Fight");
        embed.setColor('Green').setDescription(`G√† c·ªßa b·∫°n ƒë√£ th·∫Øng v√† mang v·ªÅ cho b·∫°n **${winAmount.toLocaleString()}** ${CURRENCY}!\nChu·ªói **${cockFightStats[userId]}** tr·∫≠n th·∫Øng <:ga:1458577141804306643>`).setFooter({ text: `S·ª©c m·∫°nh: ${Math.round(winRate*100)}%` });
    } else {
        cockFightStats[userId] = 0; 
        embed.setColor('Red').setDescription(`ü™¶ G√† c·ªßa b·∫°n ƒë√£ v·ªÅ n∆°i ch√≠n su·ªëi!\nChu·ªói win reset v·ªÅ 0.`).setFooter({ text: `S·ª©c m·∫°nh: ${Math.round(winRate*100)}%` });
    }
    return message.reply({ embeds: [embed] });
}

// H√†m k√≠ch ho·∫°t Chicken Box (g·ªçi t·ª´ file item_usage.js)
async function activateChickenBox(message, userId) {
    if (chickenSessions[userId]) {
        return { success: false, msg: "üö´ ƒêang c√≥ g√† r·ªìi, ƒë√° xong ƒëi ƒë√£." };
    }
    const getDesc = (t) => `**Lu·∫≠t:** Trong **${t}s** h√£y ƒë√° 3 tr·∫≠n ƒë√° g√†.\nüëä G√µ \`.dg\` ƒë·ªÉ ƒë√°.\n------------------------\n‚Ä¢Th·∫Øng 1 L·∫ßn: Nh·∫≠n 20,000ü™ô\n‚Ä¢Th·∫Øng 2 L·∫ßn: Th√™m 15,000ü™ô\n‚Ä¢Th·∫Øng 3 L·∫ßn: Th√™m 25,000ü™ô`;
    const embed = new EmbedBuilder().setColor('DarkRed').setTitle("üêì G√Ä CHI·∫æN V√ÄO CHU·ªíNG!").setDescription(getDesc(120));
    const msg = await message.reply({ embeds: [embed] });
    
    let t = 120;
    const timer = setInterval(async () => { 
        t--; 
        if (t <= 0) { 
            clearInterval(timer); 
            delete chickenSessions[userId]; 
            msg.edit({ embeds: [EmbedBuilder.from(embed).setDescription("**H·∫æT GI·ªú!**")] }); 
            return; 
        } 
        try { if(t % 5 === 0) msg.edit({ embeds: [EmbedBuilder.from(embed).setDescription(getDesc(t))] }); } catch (e) {} 
    }, 1000);
    
    chickenSessions[userId] = { wins: 0, startTime: Date.now(), timer: timer };
    return { success: true };
}

module.exports = { handleChicken, activateChickenBox };

================================================================================
FILE: games/duangua.js
================================================================================
const { 
    EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, 
    ModalBuilder, TextInputBuilder, TextInputStyle, ComponentType 
} = require('discord.js');
const { GAME_CONFIG, HORSES } = require('../config');
const economy = require('../utils/economy');

const activeRaces = new Set();

async function handleRace(message) {
    if (activeRaces.has(message.channel.id)) {
        return message.reply("ƒêang c√≥ m·ªôt cu·ªôc ƒëua di·ªÖn ra ·ªü k√™nh n√†y r·ªìi anh ∆°i!");
    }
    startRace(message);
}

async function startRace(message) {
    activeRaces.add(message.channel.id);
    const channel = message.channel;
    // const guildId = message.guild.id; // B·ªè guildId

    const TRACK_LENGTH = GAME_CONFIG.raceTrackLength || 28;
    const PAYOUT_RATE = GAME_CONFIG.racePayoutRate || 3;
    const MIN_BET = GAME_CONFIG.minBetRace || 1000;
    const MAX_BET = GAME_CONFIG.maxBetRace || 50000;

    const shuffled = [...HORSES].sort(() => 0.5 - Math.random());
    const raceHorses = shuffled.slice(0, 5).map(h => ({
        ...h,
        position: 0,
        finished: false
    }));

    const row = new ActionRowBuilder();
    
    raceHorses.forEach((h, index) => {
        row.addComponents(
            new ButtonBuilder()
                .setCustomId(`bet_race_${index}`) 
                .setLabel(h.name)
                .setEmoji(h.icon) 
                .setStyle(ButtonStyle.Primary)
        );
    });

    const timeBet = GAME_CONFIG.raceBetTime || 30; 
    const endTime = Math.floor(Date.now() / 1000) + timeBet;

    const betEmbed = new EmbedBuilder()
        .setAuthor({ 
            name: 'Nh√† C√°i ƒë·∫øn t·ª´ ch√¢u Phi', 
            iconURL: message.client.user.displayAvatarURL() 
        })
        .setTitle('üé∞ S√íNG ƒêUA NG·ª∞A M·ªû C·ª¨A')
        .setDescription(
            `**LU·∫¨T CH∆†I**\n` +
            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
            `1. **Th·ªÉ l·ªá:** 5 chi·∫øn m√£ s·∫Ω ƒëua trong 15 gi√¢y.\n` +
            `2. **ƒê·∫∑t c∆∞·ª£c:**\n` +
            `   - Ti·ªÅn t∆∞∆°i th√≥c th·∫≠t, ƒë·∫∑t r·ªìi mi·ªÖn ƒë√≤i l·∫°i.\n` +
            `   - T·ªâ l·ªá ƒÉn: **x${PAYOUT_RATE}**\n` +
            `   - C∆∞·ª£c t·ªëi thi·ªÉu: **${MIN_BET.toLocaleString()}** ü™ô | T·ªëi ƒëa: **${MAX_BET.toLocaleString()}** ü™ô\n` +
            `   - Thua th√¨ coi nh∆∞ ·ªßng h·ªô qu·ªπ t·ª´ thi·ªán 'Admin ngh√®o v∆∞·ª£t kh√≥'.\n\n` +
            `**Th·ªùi gian c∆∞·ª£c:** <t:${endTime}:R>\n\n` + 
            `**Danh s√°ch ng·ª±a ƒëua:**\n` +
            raceHorses.map((h, i) => `> ${i+1}. ${h.icon} **${h.name}**`).join('\n')
        )
        .setColor('#FF0000') 
        .setFooter({ text: 'Nh√† C√°i Uy T√≠n - Ch·∫•t L∆∞·ª£ng!' });

    const betMsg = await channel.send({ 
        embeds: [betEmbed], 
        components: [row] 
    });

    const bets = new Map(); 

    const collector = betMsg.createMessageComponentCollector({ 
        componentType: ComponentType.Button, 
        time: timeBet * 1000 
    });

    collector.on('collect', async (interaction) => {
        const horseIndex = parseInt(interaction.customId.split('_')[2]); 
        const selectedHorse = raceHorses[horseIndex];

        const modal = new ModalBuilder()
            .setCustomId(`modal_bet_${interaction.id}`)
            .setTitle(`C∆∞·ª£c cho ${selectedHorse.name}`);

        const amountInput = new TextInputBuilder()
            .setCustomId('betAmount')
            .setLabel("Nh·∫≠p s·ªë ti·ªÅn mu·ªën c∆∞·ª£c:")
            .setStyle(TextInputStyle.Short)
            .setPlaceholder(`T·ª´ ${MIN_BET.toLocaleString()} ƒë·∫øn ${MAX_BET.toLocaleString()}`)
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(10);

        const firstActionRow = new ActionRowBuilder().addComponents(amountInput);
        modal.addComponents(firstActionRow);

        await interaction.showModal(modal);

        try {
            const submitted = await interaction.awaitModalSubmit({
                time: 15000, 
                filter: (i) => i.customId === `modal_bet_${interaction.id}`
            });

            let amountStr = submitted.fields.getTextInputValue('betAmount');
            amountStr = amountStr.toLowerCase().replace(/k/g, '000').replace(/,/g, '');
            const amount = parseInt(amountStr);

            if (isNaN(amount)) {
                return submitted.reply({ content: "S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!", ephemeral: true });
            }

            if (amount < MIN_BET) {
                return submitted.reply({ content: `ƒê·∫∑t √≠t qu√° b·∫°n ∆°i! T·ªëi thi·ªÉu **${MIN_BET.toLocaleString()}** ü™ô m·ªõi nh·∫≠n k√®o nha.`, ephemeral: true });
            }

            if (amount > MAX_BET) {
                return submitted.reply({ content: `S·ªë ti·ªÅn qu√° l·ªõn! T·ªëi ƒëa **${MAX_BET.toLocaleString()}** ü™ô th√¥i b·∫°n.`, ephemeral: true });
            }

            if (bets.has(interaction.user.id)) {
                return submitted.reply({ content: "B·∫°n ƒë√£ c∆∞·ª£c r·ªìi, m·ªói v√°n ch·ªâ ƒë∆∞·ª£c ch·ªçn 1 con!", ephemeral: true });
            }

            // Global Check
            const balance = await economy.getBalance(interaction.user.id);
            if (balance.cash < amount) {
                return submitted.reply({ content: `B·∫°n kh√¥ng ƒë·ªß ti·ªÅn! Trong v√≠ c√≤n c√≥ **${balance.cash.toLocaleString()}** ü™ô`, ephemeral: true });
            }

            // Global Deduct
            const success = await economy.subtractMoney(interaction.user.id, amount, `Bet Race: ${selectedHorse.name}`);
            if (success) {
                bets.set(interaction.user.id, { horse: selectedHorse.name, amount: amount, user: interaction.user });
                await submitted.reply({ 
                    content: `${interaction.user} ƒë√£ ƒë·∫∑t **${amount.toLocaleString()}** ü™ô cho **${selectedHorse.name}** ${selectedHorse.icon}!`,
                    ephemeral: false 
                });
            } else {
                return submitted.reply({ content: `L·ªói h·ªá th·ªëng khi tr·ª´ ti·ªÅn!`, ephemeral: true });
            }

        } catch (error) {}
    });

    collector.on('end', async () => {
        const endedEmbed = EmbedBuilder.from(betEmbed)
            .setDescription(
                `‚õî **ƒê√É NG∆ØNG NH·∫¨N C∆Ø·ª¢C**\n\n` +
                `**Danh s√°ch ng·ª±a ƒëua:**\n` +
                raceHorses.map((h, i) => `> ${i+1}. ${h.icon} **${h.name}**`).join('\n')
            )
            .setColor('#808080'); 

        try {
            await betMsg.edit({ 
                embeds: [endedEmbed], 
                components: [] 
            });
        } catch (e) {}

        let round = 20; 
        
        const raceEmbed = new EmbedBuilder()
            .setTitle('üî• TR∆Ø·ªúNG ƒêUA ƒê√É B·∫ÆT ƒê·∫¶U üî•')
            .setDescription(renderRaceBoard(raceHorses, round, false, TRACK_LENGTH))
            .setColor('#FFA500'); 

        const raceMsg = await channel.send({ embeds: [raceEmbed] });

        const raceInterval = setInterval(async () => {
            round--;

            raceHorses.forEach(h => {
                const move = Math.floor(Math.random() * 3) + 1; 
                h.position += move;
                
                if (h.position > TRACK_LENGTH) {
                    h.position = TRACK_LENGTH;
                }
            });

            const finishers = raceHorses.filter(h => h.position >= TRACK_LENGTH);

            if (finishers.length > 0 || round <= 0) {
                clearInterval(raceInterval);
                
                let winner;
                
                if (finishers.length > 0) {
                    const winnersPool = finishers;
                    winner = winnersPool[Math.floor(Math.random() * winnersPool.length)];
                } else {
                    const maxPos = Math.max(...raceHorses.map(h => h.position));
                    const potentialWinners = raceHorses.filter(h => h.position === maxPos);
                    winner = potentialWinners[Math.floor(Math.random() * potentialWinners.length)];
                }

                try {
                    const finalEmbed = EmbedBuilder.from(raceEmbed)
                        .setDescription(renderRaceBoard(raceHorses, 0, winner, TRACK_LENGTH)); 
                    await raceMsg.edit({ embeds: [finalEmbed] });
                } catch (e) { console.error(e); }

                finishRace(channel, winner, raceHorses, bets, PAYOUT_RATE);
            } else {
                try {
                    const updatedEmbed = EmbedBuilder.from(raceEmbed)
                        .setDescription(renderRaceBoard(raceHorses, round, null, TRACK_LENGTH));
                    await raceMsg.edit({ embeds: [updatedEmbed] });
                } catch (e) { console.error(e); }
            }

        }, 1000); 
    });
}

function renderRaceBoard(horses, timeLeft, winnerObj, trackLength) {
    let board = `‚è±Ô∏è **Th·ªùi gian: ${timeLeft}s**\n\n`;
    
    horses.forEach(h => {
        const pos = Math.floor(h.position);
        
        const safePos = Math.min(pos, trackLength);
        const safeRemaining = Math.max(0, trackLength - safePos);

        const leftSpace = ' '.repeat(safePos); 
        const rightSpace = ' '.repeat(safeRemaining);
        
        let status = '|';
        if (winnerObj && h === winnerObj) {
            status = 'üèÅ';
        }
        
        board += `\`|${leftSpace}\` ${h.icon} \`${rightSpace}|\` ${status} - **${h.name}**\n`;
    });
    return board;
}

// B·ªè guildId
async function finishRace(channel, winner, horses, bets, payoutRate) {
    let description = `<a:hihi:1457471433302216724>**QU√ÅN QU√ÇN:** ${winner.icon} **${winner.name}**\n\n`;

    const winnersList = [];
    const losersList = [];

    for (const [userId, betData] of bets) {
        const betHorse = horses.find(h => h.name === betData.horse);
        const horseIcon = betHorse ? betHorse.icon : '';

        if (betData.horse === winner.name) {
            const payout = betData.amount * payoutRate; 
            try {
                // Global Add Money
                await economy.addMoney(userId, payout, "Win Race");
                winnersList.push(`<@${userId}> ƒë√£ ƒë·∫∑t **${betData.amount.toLocaleString()}** ü™ô v√†o ${horseIcon} **${betData.horse}** v√† nh·∫≠n ƒë∆∞·ª£c **${payout.toLocaleString()}** ü™ô`);
            } catch (error) {
                console.error(`L·ªói tr·∫£ th∆∞·ªüng cho ${userId}:`, error);
            }
        } else {
            const userName = betData.user.username;
            losersList.push(`<a:haha:1457472038980685956>**${userName}** ƒë√£ ƒë·∫∑t **${betData.amount.toLocaleString()}** ü™ô v√†o ${horseIcon} **${betData.horse}** v√† m·∫•t s·∫°ch kh√¥ng c√≤n g√¨.`);
        }
    }

    if (winnersList.length > 0) {
        description += `${winnersList.join('\n')}\n\n`;
    }

    if (losersList.length > 0) {
        description += `${losersList.join('\n')}`;
    }

    if (bets.size === 0) {
        description += "\nüëª Kh√¥ng c√≥ ai c∆∞·ª£c v√°n n√†y c·∫£.";
    }

    const resultEmbed = new EmbedBuilder()
        .setTitle('<a:aha:1457473109992149033>K·∫æT QU·∫¢ CU·ªòC ƒêUA<a:aha:1457473109992149033> ')
        .setDescription(description)
        .setColor('#FFD700')
        .setThumbnail(winner.icon.match(/https?:\/\/[^\s]+/) ? winner.icon : null);

    channel.send({ embeds: [resultEmbed] });
    activeRaces.delete(channel.id);
}

module.exports = { handleRace };

================================================================================
FILE: games/economy_game.js
================================================================================
// games/economy_game.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');
const economy = require('../utils/economy');
const { setHuntCooldown } = require('./hunt'); 
const { resolveGlobalUser } = require('../utils/helpers'); 

const OWNER_ID = '414792622289190917';

const COMMAND_ALIASES = {
    'w': 'work', 's': 'slut', 'c': 'crime',
    'dep': 'deposit', 'cat': 'deposit', 
    'with': 'withdraw', 'lay': 'withdraw', 
    'bal': 'balance', 'lb': 'leaderboard', 'give': 'givemoney',
    'addmoney': 'add-money', 'removemoney': 'remove-money',
    'addmoneyrole': 'add-money-role', 'removemoneyrole': 'remove-money-role',
    'addmoneyall': 'add-money-allmember',
    'setcooldown': 'set-cooldown', 'setpayout': 'set-payout',
    'setfailrate': 'set-fail-rate', 'setcurrency': 'set-currency',
    'setstartbalance': 'set-start-balance',
    'removetestusers': 'remove-test-users', 'gentestusers': 'gen-test-users',
    'addreply': 'add-reply', 'addreplyfail': 'add-reply-fail',
    'setadmin': 'set-admin', 'removeadmin': 'remove-admin',
    'diemdanh': 'daily', 'checkin': 'daily',
    'setchanel': 'set-channel', 'setchannel': 'set-channel'
};

const ROB_FAIL_MESSAGES = [
    "ƒê·ªãnh m√≥c v√≠ th·∫±ng b·∫°n th√¢n l√∫c n√≥ ƒëang ng·ªß, ai ng·ªù n√≥ ng·ªß m·ªü m·∫Øt. N√≥ t√≥m tay v·∫∑n ng∆∞·ª£c ra sau, b·∫Øt ƒë·ªÅn ti·ªÅn thu·ªëc xoa b√≥p {amount}.",
    "L√©n ƒëƒÉng nh·∫≠p Momo c·ªßa ƒë·ª©a b·∫°n ƒë·ªÉ chuy·ªÉn ti·ªÅn, nh·∫≠p sai m·∫≠t kh·∫©u 5 l·∫ßn b·ªã kh√≥a t√†i kho·∫£n. N√≥ b·∫Øt ƒë·ªÅn ph√≠ m·ªü kh√≥a v√† t·ªïn th·∫•t tinh th·∫ßn {amount}.",
    "Th√≤ tay v√†o t√∫i √°o kho√°c b·∫°n ƒë·ªãnh 'm∆∞·ª£n t·∫°m', ai ng·ªù trong t√∫i n√≥ c√≥ con chu·ªôt Hamster. Chu·ªôt c·∫Øn s∆∞ng tay, t·ªën ti·ªÅn ti√™m ph√≤ng {amount}.",
    "R·ªß b·∫°n ƒëi cafe ƒë·ªãnh d√†n c·∫£nh qu√™n v√≠ ƒë·ªÉ n√≥ bao, b·ªã n√≥ 'ƒë·ªçc v·ªã' b·∫Øt tr·∫£ lu√¥n c·∫£ ch·∫ßu n∆∞·ªõc cho c·∫£ nh√≥m. Bay m√†u {amount}.",
    "ƒê·ªôt nh·∫≠p ph√≤ng tr·ªç th·∫±ng b·∫°n, d·∫´m ph·∫£i b√£i lego n√≥ r·∫£i d∆∞·ªõi s√†n. ƒêau th·∫•u tr·ªùi xanh, ng√£ v·ª° lu√¥n c√°i b√¨nh n∆∞·ªõc c·ªßa n√≥. ƒê·ªÅn b√π {amount}.",
    "ƒê·ªãnh tr·ªôm long tr√°o ph·ª• ƒë·ªïi ti·ªÅn gi·∫£ l·∫•y ti·ªÅn th·∫≠t c·ªßa b·∫°n, b·ªã n√≥ soi ƒë√®n c·ª±c t√≠m ph√°t hi·ªán ngay t·∫°i tr·∫≠n. Ph·∫°t n·ªôp qu·ªπ nh√≥m {amount}.",
    "Hack nick Facebook b·∫°n ƒë·ªãnh nh·∫Øn tin vay ti·ªÅn ng∆∞·ªùi l·∫°, b·ªã n√≥ c√†i b·∫£o m·∫≠t 2 l·ªõp g·ª≠i m√£ v·ªÅ ƒëi·ªán tho·∫°i. B·ªã l·ªô t·∫©y, ph·∫£i m·ªùi n√≥ ƒëi ƒÉn l·∫©u t·∫° l·ªói h·∫øt {amount}.",
    "L·ª£i d·ª•ng l√∫c b·∫°n ƒëi v·ªá sinh ƒë·ªãnh th√≥ ƒëi·ªán tho·∫°i, ai ng·ªù camera qu√°n cafe chi·∫øu th·∫≥ng v√†o m·∫∑t. Ch·ªß qu√°n b√°o c√¥ng an, n·ªôp ph·∫°t h√†nh ch√≠nh {amount}.",
    "T√≠nh tr·∫•n l·ªôt th·∫±ng b·∫°n hi·ªÅn l√†nh nh·∫•t nh√≥m, ai ng·ªù n√≥ m·ªõi ƒëi h·ªçc Muay Th√°i v·ªÅ. B·ªã n√≥ 'test' v√†i ƒë∆∞·ªùng quy·ªÅn, t·ªën ti·ªÅn mua thu·ªëc ƒë·ªè {amount}.",
    "Canh me l√∫c b·∫°n r√∫t ti·ªÅn c√¢y ATM ƒë·ªãnh gi·∫≠t ch·∫°y, b·ªã b·∫£o v·ªá ng√¢n h√†ng t∆∞·ªüng c∆∞·ªõp th·∫≠t g√¥ c·ªï l·∫°i. B·∫°n th√¢n ph·∫£i l√™n b·∫£o l√£nh, t·ªën ph√≠ 'tr√† n∆∞·ªõc' {amount}."
];

const ROB_SUCCESS_MESSAGES = [
    "Th·ª±c hi·ªán ngh·ªã quy·∫øt l·∫•y c·ªßa ng∆∞·ªùi gi√†u chia cho ng∆∞·ªùi ngh√®o (l√† tui). ƒê√£ tr∆∞ng thu th√†nh c√¥ng {amount} t·ª´ kho b·∫°c c·ªßa b·∫°n.",
    "S·ª£ b·∫°n ƒëi l·ªách c·ªôt s·ªëng v√¨ v√≠ qu√° d√†y, m√¨nh xin ph√©p g√°nh v√°c gi√πm {amount}. Kh√¥ng c·∫ßn c·∫£m ∆°n ƒë√¢u, nghƒ©a v·ª• th√¥i m√†!",
    "K·ªπ nƒÉng b√†n tay v√†ng trong l√†ng m√≥c t√∫i ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t. L·ª•m nh·∫π {amount}, xin ph√©p ƒëi tr∆∞·ªõc l·ª° b·ªã b·∫Øt ƒë·ªÅn.",
    "M∆∞·ª£n t·∫°m {amount} mua ly tr√† s·ªØa full topping, bao gi·ªù gi√†u tui tr·∫£ (m√† bao gi·ªù gi√†u th√¨ tui ch∆∞a bi·∫øt). Iu b·∫°n!",
    "Thu ph√≠ duy tr√¨ t√¨nh b·∫°n th√°ng n√†y l√† {amount} nha. ƒê√£ tr·ª´ tr·ª±c ti·∫øp v√†o t√†i kho·∫£n, d·ªãch v·ª• nhanh g·ªçn l·∫π!",
    "Alo alo, check v√≠ xem c√≥ thi·∫øu {amount} kh√¥ng? N·∫øu c√≥ th√¨ ƒë·ª´ng t√¨m, n√≥ ƒëang n·∫±m ·∫•m √™m b√™n t√∫i m√¨nh r·ªìi.",
    "C·∫£m ∆°n b·∫°n ƒë√£ ƒë·∫ßu t∆∞ {amount} v√†o qu·ªπ t·ª´ thi·ªán Nu√¥i tui b√©o m·∫ßm. C√¥ng ƒë·ª©c v√¥ l∆∞·ª£ng!",
    "M·ªôt pha check var v√≠ ti·ªÅn c·ª±c g·∫Øt. Tr·ªçng t√†i x√°c nh·∫≠n b·∫°n ƒë√£ m·∫•t {amount} v√†o tay ƒë·ªôi b·∫°n (l√† tui).",
    "T√≠nh l·∫•y h·∫øt m√† l∆∞∆°ng t√¢m c·∫Øn r·ª©t, n√™n ch·ªâ xin ƒë·ªÉu {amount} u·ªëng c√† ph√™ th√¥i. V·∫´n c√≤n ti·ªÅn ƒëi xe bus v·ªÅ nh√© b·∫°n hi·ªÅn!",
    "V≈© tr·ª• g·ª≠i t√≠n hi·ªáu l√† b·∫°n c·∫ßn h·ªçc c√°ch bu√¥ng b·ªè v·∫≠t ch·∫•t. Tui gi√∫p b·∫°n th·ª±c h√†nh b√†i h·ªçc ƒë√≥ v·ªõi gi√° {amount}."
];

function getOrdinalSuffix(i) {
    var j = i % 10, k = i % 100;
    if (j == 1 && k != 11) return i + "st";
    if (j == 2 && k != 12) return i + "nd";
    if (j == 3 && k != 13) return i + "rd";
    return i + "th";
}

function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

async function sendCooldownMessage(message, expirationTimestamp) {
    const expirationSeconds = Math.floor(expirationTimestamp / 1000);
    const timeLeft = expirationTimestamp - Date.now();
    const msg = await message.reply(`Vui l√≤ng ch·ªù th√™m trong <t:${expirationSeconds}:R> ƒë·ªÉ s·ª≠ d·ª•ng l·∫°i l·ªánh`);
    if (timeLeft > 0) { setTimeout(() => { msg.delete().catch(() => {}); }, timeLeft); }
}

function parseDuration(str) {
    if (!str) return null;
    const match = str.match(/^(\d+)(s|m|h)$/i);
    if (!match) return null;
    const val = parseInt(match[1]);
    const unit = match[2].toLowerCase();
    if (unit === 's') return val;
    if (unit === 'm') return val * 60;
    if (unit === 'h') return val * 3600;
    return null;
}

async function getHybridRobReply(guildId, status, amount, currency) {
    let dbReplies = [];
    try { dbReplies = await economy.getCustomReplies(guildId, 'rob'); } catch (e) {}
    const validDbMessages = dbReplies.filter(r => r.status === status).map(r => r.message);
    const hardcodedMessages = status === 'success' ? ROB_SUCCESS_MESSAGES : ROB_FAIL_MESSAGES;
    const allMessages = [...validDbMessages, ...hardcodedMessages];
    let template = status === 'success' ? "B·∫°n nh·∫≠n ƒë∆∞·ª£c {amount}" : "B·∫°n m·∫•t {amount}";
    if (allMessages.length > 0) template = allMessages[Math.floor(Math.random() * allMessages.length)];
    const formattedAmount = `**${economy.formatMoney(amount)} ${currency}**`;
    return template.replace(/{amount}/g, formattedAmount);
}

function getNextDailyTime() {
    const now = new Date();
    const gmt7Time = new Date(now.getTime() + (7 * 60 * 60 * 1000));
    const nextDay = new Date(gmt7Time);
    nextDay.setUTCHours(24, 0, 0, 0); 
    return nextDay.getTime() - (7 * 60 * 60 * 1000); 
}

function isSameDayGMT7(date1, date2) {
    if (!date1 || !date2) return false;
    const d1 = new Date(date1.getTime() + (7 * 60 * 60 * 1000));
    const d2 = new Date(date2.getTime() + (7 * 60 * 60 * 1000));
    return d1.getUTCFullYear() === d2.getUTCFullYear() && d1.getUTCMonth() === d2.getUTCMonth() && d1.getUTCDate() === d2.getUTCDate();
}

function isYesterdayGMT7(lastDailyDate) {
    if (!lastDailyDate) return false;
    const now = new Date();
    const d1 = new Date(lastDailyDate.getTime() + (7 * 60 * 60 * 1000));
    const d2 = new Date(now.getTime() + (7 * 60 * 60 * 1000));
    const oneDay = 24 * 60 * 60 * 1000;
    const d1Reset = new Date(d1.getUTCFullYear(), d1.getUTCMonth(), d1.getUTCDate()).getTime();
    const d2Reset = new Date(d2.getUTCFullYear(), d2.getUTCMonth(), d2.getUTCDate()).getTime();
    return (d2Reset - d1Reset) === oneDay;
}

const formatMoney = (n) => parseInt(n).toLocaleString('en-US');

async function handleEconomyCommand(message, command, args) {
    const guildId = message.guild.id;
    const userId = message.author.id;
    const config = await economy.getConfig(guildId);
    
    if (await economy.isCommandDisabled(message.channel.id, command, COMMAND_ALIASES)) return;

    const cleanArgs = args.filter(arg => arg.trim() !== '');
    const isOwner = (userId === OWNER_ID);

    // Quy·ªÅn Admin Server d√†nh cho l·ªánh setchannel
    const checkServerAdmin = async () => {
        if (userId === message.guild.ownerId || isOwner) return true;
        const adminRoles = config.admin_roles || [];
        return message.member.roles.cache.some(role => adminRoles.includes(role.id));
    };
    const isServerAdmin = await checkServerAdmin();

    // --- 1. WORK ---
    if (command === 'work' || command === 'w') {
        const exp = economy.checkCooldown(null, userId, 'work', config.work_cd);
        if (exp > 0) return sendCooldownMessage(message, exp);
        const amount = getRandomInt(config.work_min || 1000, config.work_max || 2000);
        await economy.updateBalance(userId, amount, 'cash', 'add');
        const replyMsg = await economy.getReply(guildId, 'work', 'success', amount, config.currency);
        return message.reply({ embeds: [new EmbedBuilder().setColor(0x2ecc71).setDescription(replyMsg)] });
    }

    // --- 2. SLUT ---
    if (command === 'slut' || command === 's') {
        const exp = economy.checkCooldown(null, userId, 'slut', config.slut_cd);
        if (exp > 0) return sendCooldownMessage(message, exp);
        if (Math.random() * 100 < (config.slut_fail || 48)) {
            const fine = Math.floor((config.slut_max || 3000) / 2);
            const actualLost = await economy.deductMoney(userId, fine);
            const replyMsg = await economy.getReply(guildId, 'slut', 'fail', actualLost, config.currency);
            return message.reply({ embeds: [new EmbedBuilder().setColor(0xe74c3c).setDescription(replyMsg)] });
        } else {
            const amount = getRandomInt(config.slut_min || 2000, config.slut_max || 3000);
            await economy.updateBalance(userId, amount, 'cash', 'add');
            const replyMsg = await economy.getReply(guildId, 'slut', 'success', amount, config.currency);
            return message.reply({ embeds: [new EmbedBuilder().setColor(0x2ecc71).setDescription(replyMsg)] });
        }
    }

    // --- 3. CRIME ---
    if (command === 'crime' || command === 'c') {
        const exp = economy.checkCooldown(null, userId, 'crime', config.crime_cd);
        if (exp > 0) return sendCooldownMessage(message, exp);
        if (Math.random() * 100 < (config.crime_fail || 48)) {
            const fine = Math.floor((config.crime_max || 3000) * 0.8);
            const actualLost = await economy.deductMoney(userId, fine);
            const replyMsg = await economy.getReply(guildId, 'crime', 'fail', actualLost, config.currency);
            return message.reply({ embeds: [new EmbedBuilder().setColor(0xe74c3c).setDescription(replyMsg)] });
        } else {
            const amount = getRandomInt(config.crime_min || 2000, config.crime_max || 3000);
            await economy.updateBalance(userId, amount, 'cash', 'add');
            const replyMsg = await economy.getReply(guildId, 'crime', 'success', amount, config.currency);
            return message.reply({ embeds: [new EmbedBuilder().setColor(0x2ecc71).setDescription(replyMsg)] });
        }
    }

    // --- 4. ROB ---
    if (command === 'rob') {
        const exp = economy.checkCooldown(null, userId, 'rob', config.rob_cd);
        if (exp > 0) return sendCooldownMessage(message, exp);
        const target = await resolveGlobalUser(message, cleanArgs[0]);
        if (!target) return message.reply("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi n√†y.");
        if (target.id === userId) return message.reply("Kh√¥ng th·ªÉ t·ª± c∆∞·ªõp.");
        const victimBal = await economy.getBalance(target.id);
        if (victimBal.cash < 100) return message.reply(`**${target.username}** qu√° ngh√®o.`);
        if (Math.random() * 100 < (config.rob_fail || 50)) {
            const fine = getRandomInt(1000, 3000);
            const actualLost = await economy.deductMoney(userId, fine);
            const replyMsg = await getHybridRobReply(guildId, 'fail', actualLost, config.currency);
            return message.reply({ embeds: [new EmbedBuilder().setColor(0xe74c3c).setDescription(replyMsg)] });
        } else {
            const robAmount = Math.floor(victimBal.cash * (getRandomInt(10, 40) / 100));
            await economy.updateBalance(target.id, robAmount, 'cash', 'remove');
            await economy.updateBalance(userId, robAmount, 'cash', 'add');
            const replyMsg = await getHybridRobReply(guildId, 'success', robAmount, config.currency);
            return message.reply({ embeds: [new EmbedBuilder().setColor(0x2ecc71).setDescription(replyMsg)] });
        }
    }

    // --- 5. DAILY ---
    if (['daily', 'diemdanh', 'checkin'].includes(command)) {
        const user = await economy.getUser(userId);
        const now = new Date();
        if (user.last_daily && isSameDayGMT7(user.last_daily, now)) return sendCooldownMessage(message, getNextDailyTime());
        let streak = (user.last_daily && isYesterdayGMT7(user.last_daily)) ? user.streak + 1 : 1;
        let reward = 10000 + (Math.min(streak, 4) * 5000);
        let boxes = 2 + (Math.min(streak, 4) - 1);
        await economy.addMoney(userId, reward, "Daily");
        await economy.addItem(userId, 'lootbox', boxes);
        await economy.updateDaily(userId, streak);
        const embed = new EmbedBuilder().setColor('Gold').setTitle('**Qu√† ƒêi·ªÉm Danh**').setDescription(`Chu·ªói **${streak}** ng√†y. Nh·∫≠n **${reward.toLocaleString()}** ü™ô v√† **${boxes}** <:lootbox:1461108775808143370>`).setThumbnail(message.author.displayAvatarURL());
        return message.reply({ embeds: [embed] });
    }

    // --- 6. BALANCE ---
    if (['bal', 'balance'].includes(command)) {
        const target = await resolveGlobalUser(message, cleanArgs[0]) || message.author;
        const bal = await economy.getBalance(target.id);
        const embed = new EmbedBuilder().setColor(0x00FF00).setTitle(`T√†i s·∫£n c·ªßa ${target.username}`)
            .addFields(
                { name: 'Cash', value: `${formatMoney(bal.cash)} ${config.currency}`, inline: true },
                { name: 'Bank', value: `${formatMoney(bal.bank)} ${config.currency}`, inline: true },
                { name: 'Total', value: `${formatMoney(bal.total)} ${config.currency}`, inline: true }
            );
        return message.channel.send({ embeds: [embed] });
    }

    // --- 7. DEPOSIT/WITHDRAW ---
    if (['deposit', 'dep', 'cat'].includes(command)) {
        const bal = await economy.getBalance(userId);
        let amount = cleanArgs[0]?.toLowerCase() === 'all' ? bal.cash : parseInt(cleanArgs[0]);
        if (!amount || amount <= 0 || amount > bal.cash) return message.reply("Ti·ªÅn kh√¥ng h·ª£p l·ªá.");
        await economy.updateBalance(userId, amount, 'cash', 'remove');
        await economy.updateBalance(userId, amount, 'bank', 'add');
        return message.reply(`ƒê√£ g·ª≠i **${economy.formatMoney(amount)} ${config.currency}** v√†o ng√¢n h√†ng.`);
    }
    if (['withdraw', 'with', 'lay'].includes(command)) {
        const bal = await economy.getBalance(userId);
        let amount = cleanArgs[0]?.toLowerCase() === 'all' ? bal.bank : parseInt(cleanArgs[0]);
        if (!amount || amount <= 0 || amount > bal.bank) return message.reply("Ti·ªÅn kh√¥ng h·ª£p l·ªá.");
        await economy.updateBalance(userId, amount, 'bank', 'remove');
        await economy.updateBalance(userId, amount, 'cash', 'add');
        return message.reply(`ƒê√£ r√∫t **${economy.formatMoney(amount)} ${config.currency}** ra ti·ªÅn m·∫∑t.`);
    }

    // --- 8. GIVE ---
    if (['givemoney', 'give'].includes(command)) {
        const target = await resolveGlobalUser(message, cleanArgs[0]);
        const amount = parseInt(cleanArgs[1]);
        if (!target || !amount || amount <= 0 || target.id === userId) return message.reply("Th√¥ng tin kh√¥ng h·ª£p l·ªá.");
        const bal = await economy.getBalance(userId);
        if (amount > bal.cash) return message.reply("Kh√¥ng ƒë·ªß ti·ªÅn.");
        await economy.updateBalance(userId, amount, 'cash', 'remove');
        await economy.updateBalance(target.id, amount, 'cash', 'add');
        return message.reply(`ƒê√£ chuy·ªÉn **${economy.formatMoney(amount)} ${config.currency}** cho **${target.username}**.`);
    }

    // --- 9. LEADERBOARD ---
    if (['lb', 'leaderboard'].includes(command)) {
        const allUsers = (await economy.getAllUsers()).sort((a, b) => b.total - a.total);
        if (allUsers.length === 0) return message.reply("Ch∆∞a c√≥ d·ªØ li·ªáu.");
        const itemsPerPage = 10;
        const totalPages = Math.ceil(allUsers.length / itemsPerPage);
        let currentPage = 0;
        const generateEmbed = async (page) => {
            const start = page * itemsPerPage;
            const end = start + itemsPerPage;
            const currentData = allUsers.slice(start, end);
            const preparedList = await Promise.all(currentData.map(async (row, index) => {
                const name = await economy.getCachedUsername(row.user_id, message.client);
                return { rank: start + index + 1, name, money: row.total };
            }));
            let maxNameLen = Math.max(...preparedList.map(i => i.name.length));
            let tableContent = preparedList.map(i => `#${i.rank.toString().padEnd(3)} ${i.name.padEnd(maxNameLen + 1)} ${economy.formatMoney(i.money).padStart(12)} ${config.currency}`).join('\n');
            return new EmbedBuilder().setColor(0x3498DB).setTitle(`**üè¶ B·∫£ng X·∫øp H·∫°ng Th·∫ø Gi·ªõi**`).setDescription(`\`\`\`yaml\n${tableContent}\`\`\``)
                .setFooter({ text: `Trang ${page + 1}/${totalPages} - H·∫°ng b·∫°n: #${allUsers.findIndex(u => u.user_id === userId) + 1}` });
        };
        const generateButtons = (page) => new ActionRowBuilder().addComponents(
            new ButtonBuilder().setCustomId('prev').setLabel('Tr∆∞·ªõc').setStyle(ButtonStyle.Primary).setDisabled(page === 0),
            new ButtonBuilder().setCustomId('next').setLabel('Sau').setStyle(ButtonStyle.Primary).setDisabled(page === totalPages - 1)
        );
        const replyMsg = await message.reply({ embeds: [await generateEmbed(0)], components: [generateButtons(0)] });
        const collector = replyMsg.createMessageComponentCollector({ componentType: ComponentType.Button, time: 60000 });
        collector.on('collect', async i => {
            if (i.user.id !== userId) return i.reply({ content: 'Kh√¥ng ph·∫£i l·ªánh c·ªßa b·∫°n!', ephemeral: true });
            await i.deferUpdate();
            if (i.customId === 'prev' && currentPage > 0) currentPage--;
            else if (i.customId === 'next' && currentPage < totalPages - 1) currentPage++;
            await i.editReply({ embeds: [await generateEmbed(currentPage)], components: [generateButtons(currentPage)] });
        });
        return;
    }

    // --- 10. L·ªÜNH CH·ªàNH K√äNH (D√†nh cho Admin Server) ---
    if (['set-channel', 'setchannel', 'setchanel'].includes(command)) {
        if (!isServerAdmin) return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
        const gameType = cleanArgs[0]?.toLowerCase();
        if (!['noitu', 'baucua', 'uno'].includes(gameType)) return message.reply("Game: noitu, baucua, uno.");
        const channel = message.mentions.channels.first() || message.channel;
        await economy.setGameChannel(guildId, gameType, channel.id);
        return message.reply(`‚úÖ ƒê√£ set k√™nh **${gameType}** t·∫°i ${channel}.`);
    }

    // --- 11. OWNER COMMANDS (CH·∫∂N TUY·ªÜT ƒê·ªêI) ---
    const ownerCmds = ['add-money','addmoney','remove-money','removemoney','setcooldown','setpayout','set-start-balance','removetestusers','gentestusers','setadmin','removeadmin','resetmoney','reset-money','add-money-role','addmoneyrole','removemoneyrole','addmoneyall','disable','enable','set-currency','prefix','add-reply','addreply','addreplyfail'];
    
    if (ownerCmds.includes(command) || ownerCmds.includes(COMMAND_ALIASES[command])) {
        if (!isOwner) return message.reply("‚ö†Ô∏è **L·ªÜNH C·∫§M:** Ch·ªâ c√≥ **Bot Owner** m·ªõi ƒë∆∞·ª£c s·ª≠ d·ª•ng l·ªánh n√†y!");

        if (command.includes('addmoney') || command.includes('add-money')) {
            const target = await resolveGlobalUser(message, cleanArgs[0]) || await resolveGlobalUser(message, cleanArgs[1]);
            let amount = parseInt(cleanArgs[1]) || parseInt(cleanArgs[0]);
            if (!target || isNaN(amount)) return message.reply("Sai c√∫ ph√°p. `.addmoney <user> <amount>`");
            await economy.updateBalance(target.id, amount, 'cash', 'add');
            return message.reply(`‚úÖ ƒê√£ buff **${formatMoney(amount)}** cho **${target.username}**.`);
        }

        if (['resetmoney', 'reset-money'].includes(command)) {
            const target = await resolveGlobalUser(message, cleanArgs[0]);
            if (target) { 
                await economy.updateBalance(target.id, 0, 'cash', 'set'); 
                await economy.updateBalance(target.id, 0, 'bank', 'set'); 
                return message.reply(`ƒê√£ reset ti·ªÅn c·ªßa **${target.username}**.`); 
            } 
            return message.reply("Kh√¥ng t√¨m th·∫•y user.");
        }

        if (['set-admin', 'setadmin'].includes(command)) {
            const role = message.mentions.roles.first();
            if (!role) return message.reply("Tag role v√†o.");
            await economy.addAdminRole(guildId, role.id);
            return message.reply(`‚úÖ ƒê√£ c·∫•p quy·ªÅn Admin Server cho role **${role.name}**.`);
        }

        if (command === 'setcooldown') {
            const type = cleanArgs[0]?.toLowerCase();
            const durationStr = cleanArgs[1];
            if (!type || !durationStr) return message.reply("V√≠ d·ª•: `.setcooldown rob 10s`.");
            const seconds = parseDuration(durationStr);
            if (seconds === null) return message.reply("Th·ªùi gian kh√¥ng h·ª£p l·ªá.");
            if (type === 'hunt') setHuntCooldown(seconds);
            else await economy.updateConfig(guildId, `${type}_cd`, seconds);
            return message.reply(`‚úÖ ƒê√£ ch·ªânh cooldown **${type}** th√†nh **${seconds}s**.`);
        }

        if (command === 'disable') { let targetCmd = cleanArgs[0]; await economy.disableCommand(message.channel.id, targetCmd); return message.reply(`üîá ƒê√£ t·∫Øt l·ªánh **${targetCmd}**.`); }
        if (command === 'enable') { let targetCmd = cleanArgs[0]; await economy.enableCommand(message.channel.id, targetCmd); return message.reply(`üîä ƒê√£ b·∫≠t l·∫°i l·ªánh **${targetCmd}**.`); }
        if (['set-currency', 'setcurrency'].includes(command)) { const symbol = cleanArgs[0]; await economy.updateConfig(guildId, 'currency', symbol); return message.reply(`ƒê√£ ƒë·ªïi ƒë∆°n v·ªã ti·ªÅn t·ªá: \`${symbol}\``); }
        if (command === 'prefix') { const newPrefix = cleanArgs[0]; await economy.updateConfig(guildId, 'prefix', newPrefix); return message.reply(`Prefix ƒë·ªïi th√†nh: \`${newPrefix}\``); }
        if (['gen-test-users'].includes(command)) { await economy.createTestUsers(20); return message.reply("ƒê√£ t·∫°o 20 user ·∫£o."); }
        if (['remove-test-users'].includes(command)) { const count = await economy.removeTestUsers(); return message.reply(`ƒê√£ x√≥a **${count}** user ·∫£o.`); }
        if (['add-reply', 'addreply'].includes(command)) { const type = cleanArgs[0]?.toLowerCase(); const text = cleanArgs.slice(1).join(" "); await economy.addReply(guildId, type, 'success', text); return message.reply(`ƒê√£ th√™m vƒÉn m·∫´u th√†nh c√¥ng cho **${type}**.`); }
        if (['add-reply-fail', 'addreplyfail'].includes(command)) { const type = cleanArgs[0]?.toLowerCase(); const text = cleanArgs.slice(1).join(" "); await economy.addReply(guildId, type, 'fail', text); return message.reply(`ƒê√£ th√™m vƒÉn m·∫´u th·∫•t b·∫°i cho **${type}**.`); }
    }
}

module.exports = { handleEconomyCommand, COMMAND_ALIASES };

================================================================================
FILE: games/hunt.js
================================================================================
// games/hunt.js
const { EmbedBuilder } = require('discord.js');
const { HUNT_CONFIG } = require('./hunt_config');
const { SHOP_ITEMS, CURRENCY } = require('../config'); 
const economy = require('../utils/economy');
const { resolveGlobalUser } = require('../utils/helpers'); // IMPORT TH√äM
const crypto = require('crypto'); 

// ID C·ª¶A B·∫†N (BOT OWNER)
const OWNER_ID = '414792622289190917';

// --- DROP STATE QU·∫¢N L√ù ---
let globalDropState = { 
    count: 0, 
    lastHour: new Date().getHours(),
    lastDropTime: 0 
};

function checkAndResetDropState() {
    const currentHour = new Date().getHours();
    if (currentHour !== globalDropState.lastHour) {
        globalDropState.count = 0;
        globalDropState.lastHour = currentHour;
    }
}

function getMinutesUntilReset() {
    const now = new Date();
    return 60 - now.getMinutes();
}

function toSuperscript(num) {
    const map = { '0': '‚Å∞', '1': '¬π', '2': '¬≤', '3': '¬≥', '4': '‚Å¥', '5': '‚Åµ', '6': '‚Å∂', '7': '‚Å∑', '8': '‚Å∏', '9': '‚Åπ' };
    return num.toString().split('').map(digit => map[digit]).join('');
}

function getSecureRandom(max) {
    return crypto.randomInt(0, max);
}

function weightedRandom(items, isClassSelection = false) {
    const SCALE = 100000; 
    let table = [];
    let totalWeight = 0;

    if (isClassSelection) {
        for (const [key, data] of Object.entries(items)) {
            const weight = Math.round(data.rate * 1000); 
            if (weight > 0) {
                table.push({ key, data, weight });
                totalWeight += weight;
            }
        }
    } else {
        for (const item of items) {
            const weight = Math.round(item.rate * SCALE);
            if (weight > 0) {
                table.push({ data: item, weight });
                totalWeight += weight;
            }
        }
    }

    if (totalWeight === 0) return isClassSelection ? { key: 'U', ...items['U'] } : items[0];

    const rand = getSecureRandom(totalWeight);
    let currentSum = 0;
    for (const entry of table) {
        currentSum += entry.weight;
        if (rand < currentSum) {
            return isClassSelection ? { key: entry.key, ...entry.data } : entry.data;
        }
    }
    return table[0].data; 
}

// --- H√ÄM X·ª¨ L√ù L·ªÜNH HUNT ---
async function handleHunt(message) {
    const userId = message.author.id;
    
    // 0. CHECK COOLDOWN (GLOBAL)
    const cooldownExp = economy.checkCooldown(null, userId, 'hunt', HUNT_CONFIG.COOLDOWN);
    if (cooldownExp > 0) {
        const timeLeft = Math.floor(cooldownExp / 1000);
        const msg = await message.reply(`B·∫°n c·∫ßn ngh·ªâ ng∆°i m·ªôt ch√∫t. Th·ª≠ l·∫°i sau <t:${timeLeft}:R>`);
        setTimeout(() => msg.delete().catch(() => {}), cooldownExp - Date.now());
        return;
    }

    // 1. CHECK TI·ªÄN & TR·ª™ TI·ªÄN (GLOBAL)
    const userBalance = await economy.getBalance(userId); 
    const huntPrice = HUNT_CONFIG.PRICE || 250;

    if (userBalance.cash < huntPrice) {
        return message.reply(`B·∫°n kh√¥ng ƒë·ªß ti·ªÅn m·∫∑t! C·∫ßn **${huntPrice.toLocaleString()}** ${CURRENCY} ƒë·ªÉ mua v√© ƒëi sƒÉn.`);
    }

    const deductSuccess = await economy.subtractMoney(userId, huntPrice, "Hunt Fee");
    if (!deductSuccess) {
        return message.reply("C√≥ l·ªói x·∫£y ra khi tr·ª´ ti·ªÅn.");
    }

    // 2. L·∫•y Buff (Global)
    const userBuffs = await economy.getUserBuffs(userId);
    
    // -- Buff S·ªë L∆∞·ª£ng --
    let huntCount = 3; 
    let quantityBuffInfo = "";
    if (userBuffs.qty_turns > 0) {
        const gemId = userBuffs.qty_gem_id;
        const bonus = HUNT_CONFIG.GEM_BUFFS[gemId]?.bonus || 0;
        huntCount += bonus;
        const gemIcon = SHOP_ITEMS[gemId]?.emoji || '';
        quantityBuffInfo = `${gemIcon} \`[${userBuffs.qty_turns}/${userBuffs.qty_total}]\``;
    }

    // -- Buff T·ªâ L·ªá --
    let activeClasses = JSON.parse(JSON.stringify(HUNT_CONFIG.CLASSES));
    let qualityBuffInfo = "";
    
    if (userBuffs.qual_turns > 0) {
        const gemId = userBuffs.qual_gem_id;
        const gemIcon = SHOP_ITEMS[gemId]?.emoji || '';
        qualityBuffInfo = `${gemIcon} \`[${userBuffs.qual_turns}/${userBuffs.qual_total}]\``;
        
        const buffPercents = HUNT_CONFIG.BUFF_RATES_PERCENTAGE;
        for (const [classKey, percentage] of Object.entries(buffPercents)) {
            if (activeClasses[classKey]) {
                const baseRate = activeClasses[classKey].rate;
                const increase = baseRate * (percentage / 100);
                activeClasses[classKey].rate = parseFloat((baseRate + increase).toFixed(2));
            }
        }
    }

    // 3. Logic B·∫Øt Th√∫
    const caughtAnimals = [];
    const animalDisplayParts = []; 

    for (let i = 0; i < huntCount; i++) {
        const selectedClass = weightedRandom(activeClasses, true);
        const animalPool = HUNT_CONFIG.ANIMALS[selectedClass.key];
        
        if (!animalPool || animalPool.length === 0) {
            animalDisplayParts.push(`üí® Tr∆∞·ª£t`);
            continue;
        }

        const selectedAnimal = weightedRandom(animalPool, false);
        caughtAnimals.push(selectedAnimal);
        animalDisplayParts.push(`${selectedClass.emoji} **${selectedAnimal.name}** ${selectedAnimal.emoji}`);
    }

    // 4. Logic Drop H√≤m (Global)
    checkAndResetDropState();
    let dropInfo = "";
    const now = Date.now();
    const timeSinceLastDrop = now - globalDropState.lastDropTime;
    const DROP_COOLDOWN = 5 * 60 * 1000; // 5 ph√∫t

    if (globalDropState.count < 10 && timeSinceLastDrop >= DROP_COOLDOWN) {
        const rand = getSecureRandom(10000); 
        let droppedItemKey = null;
        
        if (rand < 100) droppedItemKey = 'crateL';      // 1%
        else if (rand < 600) droppedItemKey = 'crate';  // 5%

        if (droppedItemKey) {
            // Add Item Global
            await economy.addItem(userId, droppedItemKey, 1);
            globalDropState.count++;
            globalDropState.lastDropTime = now;
            
            const itemData = SHOP_ITEMS[droppedItemKey];
            const minutesLeft = getMinutesUntilReset();
            
            dropInfo = `\n---------------------------------------------------------\n` +
                       `${itemData.emoji} | B·∫°n t√¨m th·∫•y x1 **${itemData.name}** | \`[${globalDropState.count}/10] Reset: ${minutesLeft}p\``;
        }
    }

    // 5. L∆∞u Database (Global)
    if (caughtAnimals.length > 0) {
        await economy.addAnimals(userId, caughtAnimals);
    }
    await economy.decreaseBuffTurns(userId);

    // 6. Hi·ªÉn th·ªã
    let buffMessage = "";
    if (quantityBuffInfo || qualityBuffInfo) {
        buffMessage = `Kh·∫£ nƒÉng sƒÉn b·∫Øt ƒë∆∞·ª£c tƒÉng c∆∞·ªùng nh·ªù: ${quantityBuffInfo} ${qualityBuffInfo}\n`;
    }

    const embed = new EmbedBuilder()
        .setColor('Green')
        .setAuthor({ 
            name: `${message.member ? message.member.displayName : message.author.username} ƒêang ƒêi SƒÉn`, 
            iconURL: message.author.displayAvatarURL() 
        })
        .setDescription(
            `${buffMessage}\n` +
            animalDisplayParts.join(' | ') + 
            dropInfo
        )
        .setFooter({ text: "S·ª≠ d·ª•ng .zoo ƒë·ªÉ xem kho th√∫" });

    message.channel.send({ embeds: [embed] });
}

// --- H√ÄM ADMIN SET GI√Å HUNT ---
async function handleSetHuntPrice(message, args) {
    if (message.author.id !== OWNER_ID) {
        return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.");
    }

    const price = parseInt(args[0]);
    if (isNaN(price) || price < 0) {
        return message.reply(`Vui l√≤ng nh·∫≠p gi√° h·ª£p l·ªá. V√≠ d·ª•: \`.sethuntprice 500\``);
    }

    HUNT_CONFIG.PRICE = price;
    return message.reply(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t gi√° Hunt th√†nh: **${price.toLocaleString()}** ${CURRENCY}`);
}

// --- H√ÄM HELPER ƒê·ªÇ SET COOLDOWN ---
function setHuntCooldown(seconds) {
    const time = parseInt(seconds);
    if (isNaN(time) || time < 0) return false;
    
    HUNT_CONFIG.COOLDOWN = time;
    return true;
}

// --- HANDLE ZOO (GLOBAL - S·ª¨A L·ªñI CHECK ID) ---
async function handleZoo(message, args) {
    let targetUser = message.author;
    let targetName = message.member ? message.member.displayName : message.author.username;
    let avatarUrl = targetUser.displayAvatarURL();

    // Logic t√¨m User th√¥ng minh (D√πng resolveGlobalUser)
    if (args.length > 0) {
        const foundUser = await resolveGlobalUser(message, args[0]);
        if (foundUser) {
            targetUser = foundUser;
            targetName = foundUser.globalName || foundUser.username;
            avatarUrl = foundUser.displayAvatarURL();
        } else {
            return message.reply("‚ùå Kh√¥ng t√¨m th·∫•y s·ªü th√∫ c·ªßa ng∆∞·ªùi n√†y.");
        }
    }

    // L·∫•y Zoo Global
    const zooData = await economy.getZoo(targetUser.id);
    
    if (!zooData || !zooData.animals || Object.keys(zooData.animals).length === 0) {
        const isSelf = targetUser.id === message.author.id;
        return message.channel.send(isSelf 
            ? `üéí Kho th√∫ c·ªßa b·∫°n tr·ªëng tr∆°n! ƒêi sƒÉn ngay n√†o.`
            : `üéí Kho th√∫ c·ªßa **${targetName}** tr·ªëng tr∆°n!`
        );
    }

    let description = "";
    let totalValue = 0;
    const classOrder = ['F', 'L', 'G', 'M', 'E', 'R', 'C', 'U'];
    
    for (const classKey of classOrder) {
        const classInfo = HUNT_CONFIG.CLASSES[classKey];
        const animalsInConfig = HUNT_CONFIG.ANIMALS[classKey];
        const userOwnedInClass = [];
        
        if (animalsInConfig) {
            for (const animal of animalsInConfig) {
                const quantity = zooData.animals[animal.id] || 0;
                if (quantity > 0) {
                    userOwnedInClass.push(`${animal.emoji}${toSuperscript(quantity)}`);
                    const pricePerUnit = animal.price || classInfo.price || 0;
                    totalValue += (pricePerUnit * quantity);
                }
            }
        }
        if (userOwnedInClass.length > 0) {
            description += `${classInfo.emoji} | ${userOwnedInClass.join('  ')}\n`;
        }
    }

    const embed = new EmbedBuilder()
        .setColor('Gold')
        .setTitle(`ü¶Å S·ªü Th√∫ C·ªßa ${targetName}`)
        .setDescription(description || "L·ªói hi·ªÉn th·ªã d·ªØ li·ªáu.")
        .setThumbnail(avatarUrl)
        // Fix hi·ªÉn th·ªã CURRENCY
        .setFooter({ text: `T·ªïng Gi√° Tr·ªã: ${totalValue.toLocaleString()} ${CURRENCY}` });

    message.channel.send({ embeds: [embed] });
}

module.exports = { 
    handleHunt, 
    handleZoo, 
    handleSetHuntPrice, 
    setHuntCooldown 
};

================================================================================
FILE: games/hunt_config.js
================================================================================
const E = require('../emoji'); // L·∫•y emoji t·ª´ file t·ªïng

const HUNT_CONFIG = {
    COOLDOWN: 2, 
    PRICE: 0,  
    
    // C·∫§U H√åNH T·ªà L·ªÜ G·ªêC & ICON CLASS
    CLASSES: {
        'U': { rate: 35.94, emoji: E.ZOO.CLASSES.U, name: "Common" },
        'C': { rate: 30.0,  emoji: E.ZOO.CLASSES.C, name: "Uncommon" },
        'R': { rate: 20.0,  emoji: E.ZOO.CLASSES.R, name: "Rare" },
        'E': { rate: 10.0,  emoji: E.ZOO.CLASSES.E, name: "Epic" },
        'M': { rate: 3.5,   emoji: E.ZOO.CLASSES.M, name: "Mythical" },
        'G': { rate: 0.5,   emoji: E.ZOO.CLASSES.G, name: "Godly" },
        'L': { rate: 0.05,  emoji: E.ZOO.CLASSES.L, name: "Legendary" },
        'F': { rate: 0.01,  emoji: E.ZOO.CLASSES.F, name: "Fable" }
    },

    BUFF_RATES_PERCENTAGE: {
        'R': 50.0, 'E': 50.0, 'M': 50.0, 'G': 100.0, 'L': 100.0, 'F': 100.0 
    },

    GEM_BUFFS: {
        'gem1a': { type: 'quantity', bonus: 1, turns: 20 },
        'gem2a': { type: 'quantity', bonus: 1, turns: 30 },
        'gem3a': { type: 'quantity', bonus: 2, turns: 35 },
        'gem4a': { type: 'quantity', bonus: 2, turns: 35 },
        'gem5a': { type: 'quantity', bonus: 3, turns: 40 },
        'gem6a': { type: 'quantity', bonus: 3, turns: 50 },
        'gem7a': { type: 'quantity', bonus: 4, turns: 100 },
        'gem1': { type: 'quality', bonus: 0, turns: 10 }, 
        'gem2': { type: 'quality', bonus: 0, turns: 20 },
        'gem3': { type: 'quality', bonus: 0, turns: 30 },
        'gem4': { type: 'quality', bonus: 0, turns: 35 },
        'gem5': { type: 'quality', bonus: 0, turns: 40 },
        'gem6': { type: 'quality', bonus: 0, turns: 50 },
        'gem7': { type: 'quality', bonus: 0, turns: 100 },
    },

    ANIMALS: {
        'U': [
            { id: 'ga', name: 'G√†', emoji: 'üêì', rate: 0.20, price: 50 },
            { id: 'vit', name: 'V·ªãt', emoji: 'ü¶Ü', rate: 0.20, price: 70 },
            { id: 'soc', name: 'S√≥c', emoji: 'üêøÔ∏è', rate: 0.20, price: 90 },
            { id: 'doi', name: 'D∆°i', emoji: 'ü¶á', rate: 0.20, price: 110 },
            { id: 'meo', name: 'M√®o', emoji: 'üêà', rate: 0.20, price: 140 }
        ],
        'C': [
            { id: 'sau', name: 'S√¢u', emoji: 'üêõ', rate: 0.20, price: 150 },
            { id: 'sen', name: 'S√™n', emoji: 'üêå', rate: 0.20, price: 190 },
            { id: 'kien', name: 'Ki·∫øn', emoji: 'üêú', rate: 0.20, price: 220 },
            { id: 'buom', name: 'B∆∞·ªõm', emoji: 'ü¶ã', rate: 0.20, price: 250 },
            { id: 'ong', name: 'Ong', emoji: 'üêù', rate: 0.20, price: 280 }
        ],
        'R': [
            { id: 'cuu', name: 'C·ª´u', emoji: 'üêë', rate: 0.20, price: 350 },
            { id: 'bo', name: 'B√≤', emoji: 'üêÑ', rate: 0.20, price: 370 },
            { id: 'voi', name: 'Voi', emoji: 'üêò', rate: 0.20, price: 390 },
            { id: 'cong', name: 'C√¥ng', emoji: 'ü¶ö', rate: 0.20, price: 400 },
            { id: 'ngua', name: 'Ng·ª±a', emoji: 'üêé', rate: 0.20, price: 480 }
        ],
        'E': [
            { id: 'vet', name: 'V·∫πt', emoji: 'ü¶ú', rate: 0.20, price: 600 },
            { id: 'te_giac', name: 'T√™ Gi√°c', emoji: 'ü¶è', rate: 0.20, price: 650 },
            { id: 'khi_dot', name: 'Kh·ªâ ƒê·ªôt', emoji: 'ü¶ß', rate: 0.20, price: 750 },
            { id: 'bao', name: 'B√°o', emoji: 'üêÜ', rate: 0.20, price: 850 },
            { id: 'ho', name: 'H·ªï', emoji: 'üêØ', rate: 0.20, price: 990 }
        ],
        'M': [
            { id: 'khung_long', name: 'Kh·ªßng Long', emoji: 'ü¶ñ', rate: 0.20, price: 1200 },
            { id: 'ca_voi', name: 'C√° Voi', emoji: 'üê≥', rate: 0.20, price: 1600 },
            { id: 'nguoi_tuyet', name: 'Ng∆∞·ªùi Tuy·∫øt', emoji: '‚òÉÔ∏è', rate: 0.20, price: 1800 },
            { id: 'ki_lan', name: 'K√¨ L√¢n', emoji: 'ü¶Ñ', rate: 0.20, price: 1900 },
            { id: 'phuong', name: 'Ph∆∞·ª£ng', emoji: 'üê¶‚Äçüî•', rate: 0.20, price: 2200 }
        ],
        'G': [
            { id: 'ca', name: 'C√°', emoji: E.ZOO.GODLY.fish, rate: 0.30, price: 4000 },
            { id: 'lac_da', name: 'L·∫°c ƒê√†', emoji: E.ZOO.GODLY.camel, rate: 0.30, price: 5500 },
            { id: 'gau_truc', name: 'G·∫•u Tr√∫c', emoji: E.ZOO.GODLY.panda, rate: 0.20, price: 6500 },
            { id: 'tom', name: 'T√¥m', emoji: E.ZOO.GODLY.shrimp, rate: 0.10, price: 8000 },
            { id: 'nhen', name: 'Nh·ªán', emoji: E.ZOO.GODLY.spider, rate: 0.10, price: 9900 }
        ],
        'L': [
            { id: 'huu', name: 'H∆∞∆°u', emoji: E.ZOO.LEGENDARY.deer, rate: 0.30, price: 12200 },
            { id: 'cao', name: 'C√°o', emoji: E.ZOO.LEGENDARY.fox, rate: 0.30, price: 15500 },
            { id: 'su_tu', name: 'S∆∞ T·ª≠', emoji: E.ZOO.LEGENDARY.lion, rate: 0.20, price: 17000 },
            { id: 'bach_tuoc', name: 'B·∫°ch Tu·ªôc', emoji: E.ZOO.LEGENDARY.squid, rate: 0.10, price: 19000 },
            { id: 'cu_meo', name: 'C√∫ M√®o', emoji: E.ZOO.LEGENDARY.owl, rate: 0.10, price: 22000 }
        ],
        'F': [
            { id: 'heo_f', name: 'Heo', emoji: E.ZOO.FABLE.pig, rate: 0.35, price: 24000 },
            { id: 'chim_ung', name: 'Chim ∆Øng', emoji: E.ZOO.FABLE.eagle, rate: 0.30, price: 29000 },
            { id: 'ech', name: '·∫æch', emoji: E.ZOO.FABLE.frog, rate: 0.15, price: 32000 },
            { id: 'khi_f', name: 'Kh·ªâ', emoji: E.ZOO.FABLE.monkey, rate: 0.15, price: 50000 },
            { id: 'cho_f', name: 'Ch√≥', emoji: E.ZOO.FABLE.dog, rate: 0.05, price: 250000 }
        ]
    }
};

module.exports = { HUNT_CONFIG };

================================================================================
FILE: games/inventory.js
================================================================================
// games/inventory.js
const { EmbedBuilder } = require('discord.js');
const { SHOP_ITEMS } = require('../config');
const economy = require('../utils/economy');
const { findItemSmart, resolveGlobalUser } = require('../utils/helpers');

// ID C·ª¶A B·∫†N
const OWNER_ID = '414792622289190917';

async function handleInventory(message, args = []) {
    let targetUser = message.author;
    let targetId = message.author.id;
    let displayName = message.author.globalName || message.author.username;
    let avatarUrl = message.author.displayAvatarURL();
    
    // Logic t√¨m user th√¥ng minh (Fix l·ªói check ID d·∫°ng text)
    if (args.length > 0) {
        const foundUser = await resolveGlobalUser(message, args[0]);
        if (foundUser) {
            targetUser = foundUser;
            targetId = foundUser.id;
            displayName = foundUser.globalName || foundUser.username;
            avatarUrl = foundUser.displayAvatarURL();
        } else {
            return message.reply("‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i n√†y (Th·ª≠ d√πng ID ho·∫∑c Username ch√≠nh x√°c).");
        }
    }

    // L·∫•y Global Inventory
    const inventory = await economy.getInventory(targetId);

    if (inventory.length === 0) { 
        const isSelf = targetId === message.author.id;
        return message.reply(isSelf
            ? "üéí Kho ƒë·ªì c·ªßa b·∫°n tr·ªëng tr∆°n! H√£y gh√© `.shop` ƒë·ªÉ mua s·∫Øm nh√©."
            : `üéí Kho ƒë·ªì c·ªßa **${displayName}** tr·ªëng tr∆°n!`
        ); 
    }

    let shopItems = [];
    let lootboxGems = [];
    let crateGems = [];

    const getGemRank = (id) => {
        return parseInt(id.replace('gem', '').replace('a', '')) || 0;
    };

    inventory.forEach(invItem => {
        const itemConfig = SHOP_ITEMS[invItem.item_id];
        if (!itemConfig) return;

        const entry = {
            ...invItem,
            name: itemConfig.name,
            emoji: itemConfig.emoji || '',
            rank: getGemRank(invItem.item_id)
        };

        if (invItem.item_id.startsWith('gem')) {
            if (invItem.item_id.endsWith('a')) {
                crateGems.push(entry); 
            } else {
                lootboxGems.push(entry); 
            }
        } else {
            shopItems.push(entry); 
        }
    });

    // S·∫Øp x·∫øp
    lootboxGems.sort((a, b) => b.rank - a.rank);
    crateGems.sort((a, b) => b.rank - a.rank);
    shopItems.sort((a, b) => a.item_id.localeCompare(b.item_id));

    let description = "";
    let globalIndex = 1;

    const renderList = (list) => {
        if (list.length === 0) return "";
        return list.map(i => {
            const line = `**${globalIndex}.** ${i.name} ${i.emoji} - **SL: ${i.amount}**`;
            globalIndex++;
            return line;
        }).join('\n') + "\n";
    };

    const sections = [];
    if (shopItems.length > 0) sections.push(renderList(shopItems));
    if (lootboxGems.length > 0) sections.push(renderList(lootboxGems));
    if (crateGems.length > 0) sections.push(renderList(crateGems));

    description = sections.join("------------------------------\n");

    if (!description) description = "L·ªói hi·ªÉn th·ªã v·∫≠t ph·∫©m.";

    const embed = new EmbedBuilder()
        .setColor('Gold')
        .setTitle(`**H√≤m ƒê·ªì C·ªßa ${displayName}**`)
        .setDescription(description)
        .setThumbnail(avatarUrl)
        .setFooter({ text: "S·ª≠ d·ª•ng .use <t√™n item> ƒë·ªÉ d√πng ho·∫∑c .sell <t√™n item> ƒë·ªÉ b√°n" });
        
    return message.channel.send({ embeds: [embed] });
}

async function handleGiveItem(message, args) {
    const senderId = message.author.id;

    if (args.length < 2) return message.reply("C√∫ ph√°p: `.give-item <t√™n item> <user/id/name> [s·ªë l∆∞·ª£ng]`");

    // Logic t√°ch user v√† item t·ª´ args
    let targetUser = null;
    let userArgIndex = -1;

    // Qu√©t qua args ƒë·ªÉ t√¨m xem ƒë√¢u l√† User
    for (let i = 0; i < args.length; i++) {
        const u = await resolveGlobalUser(message, args[i]);
        if (u) {
            targetUser = u;
            userArgIndex = i;
            break;
        }
    }

    if (!targetUser) return message.reply("‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi nh·∫≠n (Tag t√™n, nh·∫≠p ID ho·∫∑c Username).");
    if (targetUser.id === senderId) return message.reply("Kh√¥ng th·ªÉ t·ª± t·∫∑ng qu√† cho m√¨nh!");
    if (targetUser.bot) return message.reply("Bot kh√¥ng c·∫ßn qu√† ƒë√¢u!");

    // Lo·∫°i b·ªè arg user ƒë·ªÉ l·∫•y item v√† amount
    const remainingArgs = args.filter((_, index) => index !== userArgIndex);

    if (remainingArgs.length === 0) return message.reply("Thi·∫øu t√™n v·∫≠t ph·∫©m!");

    let amount = 1;
    // Ki·ªÉm tra xem arg cu·ªëi c√πng c√≥ ph·∫£i l√† s·ªë kh√¥ng
    const lastArg = remainingArgs[remainingArgs.length - 1];
    if (!isNaN(lastArg)) {
        amount = parseInt(lastArg);
        remainingArgs.pop(); // X√≥a s·ªë l∆∞·ª£ng ra kh·ªèi m·∫£ng t√™n
    }

    if (amount <= 0) return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!");
    
    const itemKeyword = remainingArgs.join(" "); 
    const item = findItemSmart(itemKeyword);

    if (!item) return message.reply(`Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n l√† "**${itemKeyword}**".`);

    // Global Check
    const currentAmount = await economy.getItemAmount(senderId, item.id);
    if (currentAmount < amount) return message.reply(`üéí B·∫°n kh√¥ng ƒë·ªß **${item.name}** ƒë·ªÉ t·∫∑ng (C√≥: ${currentAmount}).`);

    // Global Transfer
    const success = await economy.transferItem(senderId, targetUser.id, item.id, amount);
    if (success) {
        return message.reply(`‚úÖ ƒê√£ chuy·ªÉn **${amount}x ${item.name}** ${item.emoji || ''} cho **${targetUser.username}**!`);
    } else {
        return message.reply("L·ªói khi chuy·ªÉn v·∫≠t ph·∫©m. Vui l√≤ng th·ª≠ l·∫°i.");
    }
}

// --- ADMIN COMMANDS (Ch·ªâ Owner) ---

async function handleAddItem(message, args) {
    const userId = message.author.id;
    if (userId !== OWNER_ID) {
        return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
    }

    const targetArg = args[args.length - 1];
    let targetType = null;
    let targetObj = null;

    // Check Role
    if (targetArg.match(/^<@&(\d+)>$/)) {
        targetType = 'role';
        targetObj = message.mentions.roles.first();
    } 
    // Check User (ID ho·∫∑c Tag)
    else {
        const u = await resolveGlobalUser(message, targetArg);
        if (u) {
            targetType = 'user';
            targetObj = u;
        }
    }

    if (!targetType || !targetObj) {
        return message.reply("Vui l√≤ng tag User/ID ho·∫∑c Role ·ªü cu·ªëi l·ªánh. VD: `.additem lucky 10 @Huy`");
    }

    const amountArg = args[args.length - 2];
    let amount = parseInt(amountArg);
    
    if (isNaN(amount) || amount <= 0) {
        return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!");
    }

    const itemKeyword = args.slice(0, args.length - 2).join(' ');
    const item = findItemSmart(itemKeyword);

    if (!item) {
        return message.reply(`Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n l√† "**${itemKeyword}**".`);
    }

    if (targetType === 'user') {
        await economy.addItem(targetObj.id, item.id, amount);
        return message.reply(`‚úÖ ƒê√£ th√™m **${amount}x ${item.name}** ${item.emoji || ''} v√†o kho c·ªßa **${targetObj.displayName || targetObj.username}**.`);
    } else if (targetType === 'role') {
        await message.guild.members.fetch();
        const members = targetObj.members.filter(m => !m.user.bot);
        const promises = members.map(m => economy.addItem(m.id, item.id, amount));
        await Promise.all(promises);
        return message.reply(`‚úÖ ƒê√£ th√™m **${amount}x ${item.name}** ${item.emoji || ''} cho **${members.size}** th√†nh vi√™n thu·ªôc role **${targetObj.name}**.`);
    }
}

async function handleRemoveItem(message, args) {
    const userId = message.author.id;
    if (userId !== OWNER_ID) {
        return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
    }

    const targetArg = args[args.length - 1];
    let targetType = null; 
    let targetObj = null;

    if (targetArg.match(/^<@&(\d+)>$/)) {
        targetType = 'role';
        targetObj = message.mentions.roles.first();
    } else {
        const u = await resolveGlobalUser(message, targetArg);
        if (u) {
            targetType = 'user';
            targetObj = u;
        }
    }

    if (!targetType || !targetObj) {
        return message.reply("Vui l√≤ng tag User/ID ho·∫∑c Role ·ªü cu·ªëi l·ªánh.");
    }

    const amountArg = args[args.length - 2];
    let amount = parseInt(amountArg);
    
    if (isNaN(amount) || amount <= 0) {
        return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!");
    }

    const itemKeyword = args.slice(0, args.length - 2).join(' ');
    const item = findItemSmart(itemKeyword);

    if (!item) {
        return message.reply(`Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n l√† "**${itemKeyword}**".`);
    }

    if (targetType === 'user') {
        const currentStock = await economy.getItemAmount(targetObj.id, item.id);
        const removeAmount = Math.min(currentStock, amount);
        
        if (removeAmount > 0) {
            await economy.removeItem(targetObj.id, item.id, removeAmount);
            return message.reply(`üóëÔ∏è ƒê√£ x√≥a **${removeAmount}x ${item.name}** kh·ªèi kho c·ªßa **${targetObj.displayName || targetObj.username}**.`);
        } else {
            return message.reply(`User n√†y kh√¥ng c√≥ **${item.name}** n√†o.`);
        }
    } else if (targetType === 'role') {
        await message.guild.members.fetch();
        const members = targetObj.members.filter(m => !m.user.bot);
        let count = 0;
        let totalRemoved = 0;

        for (const member of members.values()) {
            const currentStock = await economy.getItemAmount(member.id, item.id);
            const removeAmount = Math.min(currentStock, amount);
            if (removeAmount > 0) {
                await economy.removeItem(member.id, item.id, removeAmount);
                totalRemoved += removeAmount;
                count++;
            }
        }
        
        return message.reply(`üóëÔ∏è ƒê√£ x√≥a t·ªïng c·ªông **${totalRemoved}x ${item.name}** t·ª´ **${count}** th√†nh vi√™n thu·ªôc role **${targetObj.name}**.`);
    }
}

module.exports = { handleInventory, handleGiveItem, handleAddItem, handleRemoveItem };

================================================================================
FILE: games/item_usage.js
================================================================================
// games/item_usage.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');
const { SHOP_ITEMS } = require('../config');
const { HUNT_CONFIG } = require('./hunt_config');
const economy = require('../utils/economy');
const { activateChickenBox } = require('./chicken');
const { activateLuckyBox, openLootbox } = require('./lootbox');
const { findAllItemsSmart } = require('../utils/helpers'); // S·ª≠ d·ª•ng h√†m t√¨m ki·∫øm m·ªõi
const { showSelectionMenu } = require('../utils/selection_ui'); // Import UI Selection

async function handleUseItem(message, args) {
    const userId = message.author.id;
    // const guildId = message.guild.id; // Kh√¥ng d√πng guildId cho economy global n·ªØa

    // Logic t√°ch s·ªë l∆∞·ª£ng v√† t√™n item
    let quantity = 1;
    let keywordArgs = args;
    const lastArg = args[args.length - 1];

    if (lastArg && lastArg.toLowerCase() === 'all') {
        quantity = 'all'; 
        keywordArgs = args.slice(0, -1);
    } else if (lastArg && !isNaN(parseInt(lastArg))) {
        quantity = parseInt(lastArg);
        keywordArgs = args.slice(0, -1);
    }

    const searchKeyword = keywordArgs.join(' ');
    
    // 1. T√åM T·∫§T C·∫¢ ITEM TR√ôNG KH·ªöP
    const matchedItems = findAllItemsSmart(searchKeyword);

    if (matchedItems.length === 0) {
        return message.reply("Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n nh∆∞ v·∫≠y.");
    }

    // 2. N·∫æU C√ì NHI·ªÄU H∆†N 1 ITEM -> HI·ªÇN TH·ªä B·∫¢NG CH·ªåN
    if (matchedItems.length > 1) {
        // Chuy·ªÉn ƒë·ªïi format cho showSelectionMenu
        const selectionItems = matchedItems.map(i => ({
            id: i.id,
            name: i.name,
            emoji: i.emoji || 'üì¶',
            type: 'item',
            data: i
        }));

        return showSelectionMenu(message, selectionItems, 'use', (selected) => {
            // Callback khi user ch·ªçn xong: G·ªçi l·∫°i logic x·ª≠ l√Ω ch√≠nh v·ªõi item ƒë√£ ch·ªçn
            processUseItem(message, selected.data, quantity, userId);
        });
    }

    // 3. N·∫æU CH·ªà C√ì 1 ITEM -> D√ôNG LU√îN
    processUseItem(message, matchedItems[0], quantity, userId);
}

// --- LOGIC X·ª¨ L√ù D√ôNG ITEM (T√°ch ra ƒë·ªÉ t√°i s·ª≠ d·ª•ng) ---
async function processUseItem(message, item, quantity, userId) {
    // --- CHECK N·∫æU L√Ä GEM BUFF ---
    const buffInfo = HUNT_CONFIG.GEM_BUFFS[item.id];
    if (buffInfo) {
        // FIX: B·ªè guildId
        const userStock = await economy.getItemAmount(userId, item.id);
        if (userStock <= 0) return message.reply(`üéí B·∫°n kh√¥ng c√≥ **${item.name}** n√†o.`);

        // FIX: B·ªè guildId
        const currentBuffs = await economy.getUserBuffs(userId);
        if (buffInfo.type === 'quantity' && currentBuffs.qty_turns > 0) {
            return message.reply(`‚õî B·∫°n ƒëang c√≥ hi·ªáu ·ª©ng **TƒÉng S·ªë L∆∞·ª£ng**. H√£y d√πng h·∫øt l∆∞·ª£t tr∆∞·ªõc!`);
        }
        if (buffInfo.type === 'quality' && currentBuffs.qual_turns > 0) {
            return message.reply(`‚õî B·∫°n ƒëang c√≥ hi·ªáu ·ª©ng **TƒÉng T·ªâ L·ªá**. H√£y d√πng h·∫øt l∆∞·ª£t tr∆∞·ªõc!`);
        }

        let desc = buffInfo.type === 'quantity' 
            ? `${item.emoji} s·∫Ω gi√∫p **tƒÉng th√™m ${buffInfo.bonus} th√∫** b·∫Øt ƒë∆∞·ª£c v·ªõi **${buffInfo.turns} l∆∞·ª£t hunt**`
            : `${item.emoji} s·∫Ω gi√∫p **tƒÉng ƒë√°ng k·ªÉ c∆° h·ªôi b·∫Øt th√∫ hi·∫øm** v·ªõi **${buffInfo.turns} l∆∞·ª£t hunt**`;

        const embed = new EmbedBuilder()
            .setColor('Blue')
            .setTitle('X√°c nh·∫≠n s·ª≠ d·ª•ng v·∫≠t ph·∫©m')
            .setDescription(`B·∫°n c√≥ ch·∫Øc mu·ªën s·ª≠ d·ª•ng ${item.emoji} **${item.name}** ƒë·ªÉ ƒëi b·∫Øt th√∫ kh√¥ng?\n\n${desc}`);

        const row = new ActionRowBuilder().addComponents(
            new ButtonBuilder().setCustomId('buff_yes').setLabel('C√≥').setStyle(ButtonStyle.Success),
            new ButtonBuilder().setCustomId('buff_no').setLabel('Kh√¥ng').setStyle(ButtonStyle.Danger)
        );

        const replyMsg = await message.reply({ embeds: [embed], components: [row] });
        const collector = replyMsg.createMessageComponentCollector({ componentType: ComponentType.Button, time: 30000, filter: i => i.user.id === userId });

        collector.on('collect', async i => {
            if (i.customId === 'buff_no') await i.update({ content: "ƒê√£ h·ªßy s·ª≠ d·ª•ng.", embeds: [], components: [] });
            else {
                // FIX: B·ªè guildId
                const stockNow = await economy.getItemAmount(userId, item.id);
                if (stockNow <= 0) return i.update({ content: "B·∫°n ƒë√£ h·∫øt item n√†y r·ªìi.", embeds: [], components: [] });
                
                // FIX: B·ªè guildId
                await economy.removeItem(userId, item.id, 1);
                await economy.activateBuff(userId, buffInfo.type, item.id, buffInfo.turns);
                
                await i.update({ content: `ƒê√£ k√≠ch ho·∫°t s·ª©c m·∫°nh c·ªßa ${item.emoji} **${item.name}**!`, embeds: [], components: [] });
            }
        });
        return;
    }

    // --- LOOTBOX ---
    if (['lootbox', 'lootboxvip', 'crate', 'crateL'].includes(item.id)) {
        // FIX: B·ªè guildId
        const userStock = await economy.getItemAmount(userId, item.id);
        if (userStock <= 0) return message.reply(`üéí B·∫°n kh√¥ng c√≥ **${item.name}** n√†o ƒë·ªÉ m·ªü.`);

        const MAX_OPEN = 10;
        let amountToOpen = quantity === 'all' ? Math.min(userStock, MAX_OPEN) : Math.min(quantity, userStock);
        if (amountToOpen > MAX_OPEN) amountToOpen = MAX_OPEN;
        
        // FIX: B·ªè guildId
        await economy.removeItem(userId, item.id, amountToOpen);
        
        if ((quantity === 'all' && userStock > MAX_OPEN) || (quantity > MAX_OPEN)) {
            message.channel.send(`‚ö†Ô∏è Ch·ªâ ƒë∆∞·ª£c m·ªü t·ªëi ƒëa **${MAX_OPEN}** h√≤m/l·∫ßn. ƒêang m·ªü **${amountToOpen}** h√≤m.`);
        }
        
        // L∆∞u √Ω: openLootbox trong file lootbox.js c√≥ th·ªÉ c≈©ng c·∫ßn check l·∫°i n·∫øu n√≥ nh·∫≠n guildId, 
        // nh∆∞ng ·ªü ƒë√¢y t√¥i ch·ªâ s·ª≠a file item_usage.js theo y√™u c·∫ßu.
        await openLootbox(message, userId, item, amountToOpen);
        return;
    }

    // --- OTHER ITEMS ---
    // FIX: B·ªè guildId
    const hasItem = await economy.removeItem(userId, item.id, 1);
    if (!hasItem) return message.reply("üéí Kh√¥ng c√≥ h√†ng trong kho.");

    if (item.id === 'luckybox') {
        await activateLuckyBox(message, userId, item);
    } else if (item.id === 'chickenbox') {
        const result = await activateChickenBox(message, userId);
        if (!result.success) {
            // FIX: B·ªè guildId (Ho√†n tr·∫£ item n·∫øu th·∫•t b·∫°i)
            await economy.addItem(userId, item.id, 1);
            message.reply(result.msg);
        }
    } else {
         message.reply({ embeds: [new EmbedBuilder().setColor('Purple').setTitle(`üì¶ ƒê√É S·ª¨ D·ª§NG ${item.name.toUpperCase()}`).setDescription("ƒê√£ s·ª≠ d·ª•ng v·∫≠t ph·∫©m.")] });
    }
}

module.exports = { handleUseItem };

================================================================================
FILE: games/lootbox.js
================================================================================
// games/lootbox.js
const { EmbedBuilder } = require('discord.js');
const { SHOP_ITEMS, GEM_RATES, GEM_RATES_VIP, CURRENCY } = require('../config');
const economy = require('../utils/economy');

// L∆∞u tr·∫°ng th√°i ai ƒëang m·ªü Luckybox ƒë·ªÉ ch·ªù l·ªánh .roll
const rollWaitList = {};

/**
 * K√≠ch ho·∫°t Luckybox (G·ªçi t·ª´ item_usage.js khi user g√µ .use luckybox)
 */
async function activateLuckyBox(message, userId, item) {
    rollWaitList[userId] = true;
    const embed = new EmbedBuilder()
        .setColor('Purple')
        .setTitle(`üì¶ ƒê√É M·ªû ${item.name.toUpperCase()}`)
        .setDescription(item.useDescription || "G√µ `.roll 10` ƒë·ªÉ th·ª≠ v·∫≠n may!");
    
    return message.reply({ embeds: [embed] });
}

/**
 * X·ª≠ l√Ω l·ªánh .roll (G·ªçi t·ª´ index.js)
 */
async function handleRoll(message, args) {
    const userId = message.author.id;
    // const guildId = message.guild.id; // B·ªè guildId

    if (!rollWaitList[userId]) return; // Ch∆∞a m·ªü h·ªôp th√¨ kh√¥ng roll ƒë∆∞·ª£c (silent return)
    
    if (!args[0] || args[0] !== '10') {
        return message.reply("G√µ `.roll 10` m·ªõi ƒë√∫ng nha!");
    }
    
    // X√≥a tr·∫°ng th√°i ch·ªù ƒë·ªÉ tr√°nh spam
    delete rollWaitList[userId];
    
    const result = Math.floor(Math.random() * 10) + 1;
    let win = 0;
    let msg = "";

    // Logic tr·∫£ th∆∞·ªüng Luckybox
    if ([2, 5, 6].includes(result)) { 
        win = 15000; 
        msg = `üé≤ S·ªë **${result}** - Tr√∫ng **15,000** ${CURRENCY}`; 
    } else if (result === 10) { 
        win = 25000; 
        msg = `üé≤ **JACKPOT!** S·ªë **${result}** - Nh·∫≠n Th√™m **25,000** ${CURRENCY}`; 
    } else { 
        msg = `üé≤ S·ªë **${result}** - C√≤n ƒë√∫ng c√°i n·ªãt!`; 
    }
    
    if (win > 0) {
        // Global Add Money (Kh√¥ng d√πng guildId)
        await economy.addMoney(userId, win, "Lucky Box Win");
    }
    
    return message.reply(msg);
}

/**
 * M·ªü Lootbox/Crate (G·ªçi t·ª´ item_usage.js)
 */
async function openLootbox(message, userId, item, amount) {
    const boxName = item.name;
    const boxIcon = item.emoji;
    
    // X√°c ƒë·ªãnh t·ª∑ l·ªá drop
    let rates = GEM_RATES;
    if (item.id === 'lootboxvip') rates = GEM_RATES_VIP;
    // N·∫øu l√† crate (n·∫øu c√≥ logic ri√™ng cho crate th√¨ th√™m v√†o ƒë√¢y, t·∫°m th·ªùi d√πng rate th∆∞·ªùng)
    
    const activeRates = [...rates]; // Copy array

    // --- CASE 1: M·ªû 1 C√ÅI ---
    if (amount === 1) {
        const openEmbed = new EmbedBuilder()
            .setColor('Purple')
            .setTitle('**Ti·∫øn H√†nh M·ªü Lootbox**')
            .setDescription(`--------------------------\n<@${userId}> ƒëang m·ªü ${boxName} v√† nh·∫≠n ƒë∆∞·ª£c <a:lootboxopen:1461108774160039998>`);
        
        const msg = await message.reply({ embeds: [openEmbed] });

        // RNG
        const rand = Math.random() * 100;
        let accumulatedRate = 0;
        let selectedGem = null;
        
        for (const gem of activeRates) {
            accumulatedRate += gem.rate;
            if (rand <= accumulatedRate) {
                selectedGem = SHOP_ITEMS[gem.id];
                break;
            }
        }
        if (!selectedGem) selectedGem = SHOP_ITEMS['gem1']; // Fallback n·∫øu xui qu√°

        // Add Item Global
        await economy.addItem(userId, selectedGem.id, 1);

        setTimeout(() => {
            const resultEmbed = new EmbedBuilder()
                .setColor(item.id === 'lootboxvip' ? 'Gold' : 'Blue')
                .setTitle('**M·ªü Lootbox Th√†nh C√¥ng**')
                .setDescription(
                    `--------------------------\n` +
                    `<a:lootboxopened:1461118461186019330> **|** <@${userId}> ƒë√£ m·ªü ${boxName} v√† nh·∫≠n ƒë∆∞·ª£c **${selectedGem.name}** ${selectedGem.emoji}\n\n` +
                    `‚Ä¢ Ng·ªçc ƒë√£ ƒë∆∞·ª£c c·∫•t v√†o kho ƒë·ªì.`
                );
            msg.edit({ embeds: [resultEmbed] }).catch(() => {});
        }, 2000);
        
    } 
    // --- CASE 2: M·ªû NHI·ªÄU C√ÅI ---
    else {
        let processLog = "";
        
        const getEmbed = (log, currentStepMsg = "") => {
            return new EmbedBuilder()
                .setColor(item.id === 'lootboxvip' ? 'Gold' : 'Purple')
                .setTitle('**Ti·∫øn H√†nh M·ªü Lootbox**')
                .setDescription(
                    `---------------------------------------------\n` +
                    `<@${userId}> ƒë√£ ti·∫øn h√†nh m·ªü **${amount}** ${boxIcon} **${boxName}**\n\n` +
                    log +
                    currentStepMsg
                );
        };

        const msg = await message.reply({ embeds: [getEmbed(processLog)] });

        for (let i = 1; i <= amount; i++) {
            const openingMsg = `\nH√≤m s·ªë ${i} ƒëang m·ªü <a:lootboxopen:1461108774160039998> v√† nh·∫≠n ƒë∆∞·ª£c...`;
            try { await msg.edit({ embeds: [getEmbed(processLog, openingMsg)] }); } catch (e) {}
            
            await new Promise(r => setTimeout(r, 1500)); // Delay animation

            const rand = Math.random() * 100;
            let accumulatedRate = 0;
            let selectedGem = null;
            for (const gem of activeRates) {
                accumulatedRate += gem.rate;
                if (rand <= accumulatedRate) {
                    selectedGem = SHOP_ITEMS[gem.id];
                    break;
                }
            }
            if (!selectedGem) selectedGem = SHOP_ITEMS['gem1'];

            await economy.addItem(userId, selectedGem.id, 1);
            
            processLog += `H√≤m s·ªë ${i} ƒë√£ m·ªü <a:lootboxopened:1461118461186019330> v√† nh·∫≠n ƒë∆∞·ª£c ${selectedGem.emoji} **${selectedGem.name}**\n`;
            
            try { await msg.edit({ embeds: [getEmbed(processLog)] }); } catch (e) {}
        }
    }
}

module.exports = { activateLuckyBox, handleRoll, openLootbox };

================================================================================
FILE: games/minigames.js
================================================================================
// games/minigames.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType, MessageFlags } = require('discord.js');
const { GAME_CONFIG, SHOP_ITEMS, CURRENCY, GEM_RATES, GEM_RATES_VIP, ADMIN_ROLE_ID } = require('../config');
const economy = require('../utils/economy');
const gemMarket = require('../utils/gem_market'); // Import Market Module
// --- IMPORT T·ª™ HELPER (FIX DRY) ---
const { parseBetAmount, findItemSmart } = require('../utils/helpers');

const rollWaitList = {};  
const chickenSessions = {}; 
const cockFightStats = {}; 

// --- ƒê√É X√ìA: parseBetAmount (D√πng t·ª´ utils/helpers) ---
// --- ƒê√É X√ìA: removeVietnameseTones (D√πng t·ª´ utils/helpers) ---
// --- ƒê√É X√ìA: findItemSmart (D√πng t·ª´ utils/helpers) ---

// --- H√ÄM SYNC SHOP DATA ---
async function initShopData() {
    if (economy.syncShopData) {
        await economy.syncShopData(SHOP_ITEMS);
    }
}

// --- X·ª¨ L√ù CHECK GI√Å GEM ---
async function handleCheckPrice(message) {
    const content = message.content.trim();
    const args = content.split(/ +/).slice(1); 
    
    if (args.length === 0) {
        const embed = gemMarket.getMarketEmbed();
        return message.channel.send({ embeds: [embed] });
    } else {
        const searchKeyword = args.join(' ');
        const item = findItemSmart(searchKeyword);

        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y lo·∫°i Ng·ªçc n√†y.");
        if (!item.id.startsWith('gem')) return message.reply("Ch·ªâ c√≥ th·ªÉ xem l·ªãch s·ª≠ gi√° c·ªßa c√°c lo·∫°i Ng·ªçc.");

        const embed = await gemMarket.getGemHistoryEmbed(item.id);
        return message.channel.send({ embeds: [embed] });
    }
}

// --- X·ª¨ L√ù XEM ITEM INFO (Lootbox Rate) ---
async function handleItemInfo(message, args) {
    const keyword = args[0] ? args[0].toLowerCase() : '';
    let isVip = false;
    let isNormal = false;

    if (['lootboxvip', 'lbvip', 'vip'].includes(keyword)) isVip = true;
    else if (['lootbox', 'lb'].includes(keyword)) isNormal = true;

    if (!isVip && !isNormal) {
        const item = findItemSmart(keyword);
        if (item) {
             const embed = new EmbedBuilder()
                .setColor('Blue')
                .setTitle(`Th√¥ng tin v·∫≠t ph·∫©m: ${item.name}`)
                .setDescription(`${item.description}\n\nGi√°: ${item.price} ${CURRENCY}\nT·ªìn kho: ${item.stock}`);
             if (item.emoji) embed.setDescription(`${item.emoji} ${item.description}\n\nGi√°: ${item.price} ${CURRENCY}\nT·ªìn kho: ${item.stock}`);
             return message.reply({ embeds: [embed] });
        }
        return message.reply("B·∫°n mu·ªën xem t·ªâ l·ªá h√≤m n√†o? `.iteminfo lb` ho·∫∑c `.iteminfo lbvip`");
    }

    const rates = isVip ? GEM_RATES_VIP : GEM_RATES;
    const boxItem = isVip ? SHOP_ITEMS['lootboxvip'] : SHOP_ITEMS['lootbox'];
    const boxName = boxItem.name;
    const boxIcon = boxItem.emoji;

    let listStr = "";
    for (const rateData of rates) {
        const item = SHOP_ITEMS[rateData.id];
        const percent = rateData.rate.toFixed(1).replace('.', ',');
        listStr += `${item.emoji} ${item.name.padEnd(16, ' ')} ‚Ä¢         ${percent}%\n`;
    }

    const embed = new EmbedBuilder()
        .setColor(isVip ? 'Gold' : 'Blue')
        .setDescription(
            `T·ªâ l·ªá m·ªü h√≤m ${boxIcon} **${boxName}** l√†:\n` +
            `-----------------------------\n` +
            `|     T√™n Ng·ªçc       -          T·ªâ L·ªá |\n` +
            listStr
        );
        
    return message.channel.send({ embeds: [embed] });
}

// --- X·ª¨ L√ù B√ÅN GEM (FIXED: Support Amount & All) ---
async function handleSellGem(message, args) {
    const userId = message.author.id;
    const guildId = message.guild.id;

    if (args.length === 0) return message.reply("B·∫°n mu·ªën b√°n g√¨? VD: `.ban thothach` ho·∫∑c `.ban thothach 10` ho·∫∑c `.ban thothach all`.");

    // T√°ch s·ªë l∆∞·ª£ng v√† t·ª´ kh√≥a
    let quantity = 1;
    let isAll = false;
    let keywordArgs = args;

    const lastArg = args[args.length - 1].toLowerCase();
    if (lastArg === 'all') {
        isAll = true;
        keywordArgs = args.slice(0, -1);
    } else if (!isNaN(parseInt(lastArg))) {
        quantity = parseInt(lastArg);
        keywordArgs = args.slice(0, -1);
    }

    if (!isAll && quantity <= 0) return message.reply("S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.");

    const searchKeyword = keywordArgs.length > 0 ? keywordArgs.join(' ') : args.join(' ');
    const item = findItemSmart(searchKeyword);

    if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†y.");
    if (!item.id.startsWith('gem')) {
        return message.reply("‚õî Ch·ªâ c√≥ **B·∫£o Ng·ªçc** m·ªõi c√≥ th·ªÉ b√°n ·ªü Ch·ª£ ƒêen!");
    }

    const currentStock = await economy.getItemAmount(guildId, userId, item.id);
    if (currentStock <= 0) {
        return message.reply(`üéí B·∫°n kh√¥ng c√≥ **${item.name}** n√†o ƒë·ªÉ b√°n.`);
    }

    // ƒêi·ªÅu ch·ªânh s·ªë l∆∞·ª£ng b√°n th·ª±c t·∫ø
    if (isAll) {
        quantity = currentStock;
    } else if (quantity > currentStock) {
        quantity = currentStock;
    }

    const marketInfo = gemMarket.getGemPrice(item.id);
    const unitPrice = marketInfo.price;
    const totalPrice = unitPrice * quantity;

    const embed = new EmbedBuilder()
        .setColor('Orange')
        .setTitle('**MeoU Ch·ª£ ƒêen - Ch·ª£ Ng·ªçc**')
        .setDescription(
            `--------------------------------\n` +
            `B·∫°n c√≥ ch·∫Øc mu·ªën b√°n **${quantity}x** ${item.emoji} **${item.name}** kh√¥ng?\n` +
            `Gi√° b√°n: **${unitPrice.toLocaleString()}** ü™ô / vi√™n\n` +
            `T·ªïng nh·∫≠n: **${totalPrice.toLocaleString()}** ü™ô`
        );

    const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('sell_yes').setLabel('C√≥').setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId('sell_no').setLabel('Kh√¥ng').setStyle(ButtonStyle.Danger)
    );

    const replyMsg = await message.reply({ embeds: [embed], components: [row] });

    const collector = replyMsg.createMessageComponentCollector({ 
        componentType: ComponentType.Button, 
        time: 30000,
        filter: i => i.user.id === userId 
    });

    collector.on('collect', async interaction => {
        if (interaction.customId === 'sell_no') {
            await interaction.update({ content: "ƒê√£ h·ªßy l·ªánh b√°n.", embeds: [], components: [] });
            return;
        }

        if (interaction.customId === 'sell_yes') {
            const amountCheck = await economy.getItemAmount(guildId, userId, item.id);
            if (amountCheck < quantity) {
                await interaction.update({ content: "S·ªë l∆∞·ª£ng trong kho ƒë√£ thay ƒë·ªïi!", embeds: [], components: [] });
                return;
            }

            const removeSuccess = await economy.removeItem(guildId, userId, item.id, quantity);
            if (removeSuccess) {
                await economy.addMoney(guildId, userId, totalPrice, `Sell ${quantity} ${item.name}`);
                const successEmbed = new EmbedBuilder()
                    .setColor('Green')
                    .setTitle('**MeoU Ch·ª£ ƒêen - Ch·ª£ Ng·ªçc**')
                    .setDescription(
                        `--------------------------------\n` +
                        `B·∫°n ƒë√£ b√°n **${quantity}x** ${item.emoji} **${item.name}** v·ªõi gi√° **${totalPrice.toLocaleString()}** ü™ô`
                    )
                    .setFooter({ text: "MeoU Th∆∞∆°ng Gia - Uy T√≠n h∆°n NYC C·ªßa B·∫°n" });

                await interaction.update({ embeds: [successEmbed], components: [] });
            } else {
                await interaction.update({ content: "L·ªói h·ªá th·ªëng khi giao d·ªãch.", embeds: [], components: [] });
            }
        }
    });

    collector.on('end', (collected, reason) => {
        if (reason === 'time') {
            replyMsg.edit({ content: "‚è∞ H·∫øt th·ªùi gian x√°c nh·∫≠n.", components: [] }).catch(() => {});
        }
    });
}

// --- X·ª¨ L√ù REMOVE ITEM (ADMIN) ---
async function handleRemoveItem(message, args) {
    const guildId = message.guild.id;
    const userId = message.author.id;

    const config = await economy.getConfig(guildId);
    const adminRoles = config.admin_roles || [];
    const isOwner = userId === message.guild.ownerId;
    const hasAdminRole = message.member.roles.cache.some(r => adminRoles.includes(r.id));
    const hasHardcodedAdmin = message.member.roles.cache.has(ADMIN_ROLE_ID);

    if (!isOwner && !hasAdminRole && !hasHardcodedAdmin) {
        return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
    }

    const targetArg = args[args.length - 1];
    let targetType = null; 
    let targetObj = null;

    if (targetArg.match(/^<@!?(\d+)>$/)) {
        targetType = 'user';
        targetObj = message.mentions.members.first();
    } else if (targetArg.match(/^<@&(\d+)>$/)) {
        targetType = 'role';
        targetObj = message.mentions.roles.first();
    }

    if (!targetType || !targetObj) {
        return message.reply("Vui l√≤ng tag User ho·∫∑c Role ·ªü cu·ªëi l·ªánh. VD: `.remove-item lucky 1 @Huy`");
    }

    const amountArg = args[args.length - 2];
    let amount = parseInt(amountArg);
    
    if (isNaN(amount) || amount <= 0) {
        return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!");
    }

    const itemKeyword = args.slice(0, args.length - 2).join(' ');
    const item = findItemSmart(itemKeyword);

    if (!item) {
        return message.reply(`Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n l√† "**${itemKeyword}**".`);
    }

    if (targetType === 'user') {
        const currentStock = await economy.getItemAmount(guildId, targetObj.id, item.id);
        const removeAmount = Math.min(currentStock, amount);
        
        if (removeAmount > 0) {
            await economy.removeItem(guildId, targetObj.id, item.id, removeAmount);
            return message.reply(`üóëÔ∏è ƒê√£ x√≥a **${removeAmount}x ${item.name}** kh·ªèi kho c·ªßa **${targetObj.displayName}**.`);
        } else {
            return message.reply(`User n√†y kh√¥ng c√≥ **${item.name}** n√†o.`);
        }
    } else if (targetType === 'role') {
        await message.guild.members.fetch();
        const members = targetObj.members.filter(m => !m.user.bot);
        let count = 0;
        let totalRemoved = 0;

        for (const member of members.values()) {
            const currentStock = await economy.getItemAmount(guildId, member.id, item.id);
            const removeAmount = Math.min(currentStock, amount);
            if (removeAmount > 0) {
                await economy.removeItem(guildId, member.id, item.id, removeAmount);
                totalRemoved += removeAmount;
                count++;
            }
        }
        
        return message.reply(`üóëÔ∏è ƒê√£ x√≥a t·ªïng c·ªông **${totalRemoved}x ${item.name}** t·ª´ **${count}** th√†nh vi√™n thu·ªôc role **${targetObj.name}**.`);
    }
}

// --- X·ª¨ L√ù ADD ITEM ---
async function handleAddItem(message, args) {
    const guildId = message.guild.id;
    const userId = message.author.id;

    const config = await economy.getConfig(guildId);
    const adminRoles = config.admin_roles || [];
    const isOwner = userId === message.guild.ownerId;
    const hasAdminRole = message.member.roles.cache.some(r => adminRoles.includes(r.id));
    const hasHardcodedAdmin = message.member.roles.cache.has(ADMIN_ROLE_ID);

    if (!isOwner && !hasAdminRole && !hasHardcodedAdmin) {
        return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
    }

    const targetArg = args[args.length - 1];
    let targetType = null;
    let targetObj = null;

    if (targetArg.match(/^<@!?(\d+)>$/)) {
        targetType = 'user';
        targetObj = message.mentions.members.first();
    } else if (targetArg.match(/^<@&(\d+)>$/)) {
        targetType = 'role';
        targetObj = message.mentions.roles.first();
    }

    if (!targetType || !targetObj) {
        return message.reply("Vui l√≤ng tag User ho·∫∑c Role ·ªü cu·ªëi l·ªánh. VD: `.additem lucky 10 @Huy`");
    }

    const amountArg = args[args.length - 2];
    let amount = parseInt(amountArg);
    
    if (isNaN(amount) || amount <= 0) {
        return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!");
    }

    const itemKeyword = args.slice(0, args.length - 2).join(' ');
    const item = findItemSmart(itemKeyword);

    if (!item) {
        return message.reply(`Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n l√† "**${itemKeyword}**".`);
    }

    if (targetType === 'user') {
        await economy.addItem(guildId, targetObj.id, item.id, amount);
        return message.reply(`‚úÖ ƒê√£ th√™m **${amount}x ${item.name}** ${item.emoji || ''} v√†o kho c·ªßa **${targetObj.displayName}**.`);
    } else if (targetType === 'role') {
        await message.guild.members.fetch();
        const members = targetObj.members.filter(m => !m.user.bot);
        const promises = members.map(m => economy.addItem(guildId, m.id, item.id, amount));
        await Promise.all(promises);
        return message.reply(`‚úÖ ƒê√£ th√™m **${amount}x ${item.name}** ${item.emoji || ''} cho **${members.size}** th√†nh vi√™n thu·ªôc role **${targetObj.name}**.`);
    }
}

async function handleChicken(message, args) {
    const userId = message.author.id;
    const guildId = message.guild.id;

    if (!args[0] && chickenSessions[userId]) {
        const session = chickenSessions[userId];
        if (Date.now() - session.startTime > 120000) {
            clearInterval(session.timer);
            delete chickenSessions[userId];
            return message.reply("G√† ch·∫øt gi√† r·ªìi. Mua con kh√°c ƒë√™!");
        }
        const isWin = Math.random() < GAME_CONFIG.winRateChickenBox;
        if (isWin) {
            session.wins++;
            let reward = 0;
            if (session.wins === 1) reward = 20000;
            if (session.wins === 2) reward = 15000;
            if (session.wins === 3) reward = 25000;

            await economy.addMoney(guildId, userId, reward, "Chicken Fight Win");
            message.reply(`<:ga:1458577141804306643> c·ªßa b·∫°n ƒë√° th·∫Øng v√† mang v·ªÅ cho b·∫°n **${reward.toLocaleString()}** ${CURRENCY}`);

            if (session.wins >= 3) {
                clearInterval(session.timer);
                delete chickenSessions[userId];
                message.reply(`**G√† ƒêi√™n Xu·∫•t Hi·ªán!** G√† c·ªßa <@${userId}> ƒë√£ th·∫Øng th√¥ng 3 tr·∫≠n li√™n ti·∫øp v√† mang v·ªÅ **60,000** ${CURRENCY} G√† s·∫Ω ƒë∆∞·ª£c thu h·ªìi ƒë·ªÉ ti√™u h·ªßy`);
            }
        } else {
            clearInterval(session.timer);
            delete chickenSessions[userId];
            message.reply(`ü™¶ **G√† c·ªßa b·∫°n ƒë√£ t·ª≠ tr·∫≠n!** Tr√≤ ch∆°i k·∫øt th√∫c.`);
        }
        return;
    }

    let betAmount = 0;
    let balance = null;

    if (args[0] && args[0].toLowerCase() === 'all') {
        balance = await economy.getBalance(guildId, userId);
        betAmount = balance.cash > GAME_CONFIG.maxBetDaGa ? GAME_CONFIG.maxBetDaGa : balance.cash;
    } else {
        betAmount = parseBetAmount(args[0]);
    }

    if (!args[0]) return message.reply("Nh·∫≠p ti·ªÅn v√†o b·∫°n ∆°i! VD: `.dg 5000` ho·∫∑c `.dg all`");
    if (betAmount <= 0) return message.reply("Ti·ªÅn c∆∞·ª£c t√†o lao!");
    if (betAmount > GAME_CONFIG.maxBetDaGa) return message.reply(`C∆∞·ª£c t·ªëi ƒëa **${GAME_CONFIG.maxBetDaGa.toLocaleString()}** th√¥i!`);

    if (!balance) balance = await economy.getBalance(guildId, userId);
    if (balance.cash < betAmount) return message.reply(`Kh√¥ng ƒë·ªß ti·ªÅn! B·∫°n ch·ªâ c√≥ ${balance.cash.toLocaleString()} ${CURRENCY}`);
    
    const success = await economy.subtractMoney(guildId, userId, betAmount, "Bet Chicken Fight");
    if (!success) return message.reply("L·ªói tr·ª´ ti·ªÅn.");

    if (!cockFightStats[userId]) cockFightStats[userId] = 0; 
    let winRate = GAME_CONFIG.winRateDaGaBase + (cockFightStats[userId] * 0.01); 
    if (winRate > GAME_CONFIG.winRateDaGaMax) winRate = GAME_CONFIG.winRateDaGaMax;
    
    const isWin = Math.random() < winRate;
    const embed = new EmbedBuilder().setAuthor({ name: "MeoU Mi·ªÅn T√¢y - ƒê√° G√†", iconURL: message.author.displayAvatarURL() });

    if (isWin) {
        cockFightStats[userId]++;
        const winAmount = betAmount * 2; 
        await economy.addMoney(guildId, userId, winAmount, "Win Chicken Fight");
        embed.setColor('Green').setDescription(`G√† c·ªßa b·∫°n ƒë√£ th·∫Øng v√† mang v·ªÅ cho b·∫°n **${winAmount.toLocaleString()}** ${CURRENCY}!\nChu·ªói **${cockFightStats[userId]}** tr·∫≠n th·∫Øng <:ga:1458577141804306643>`).setFooter({ text: `S·ª©c m·∫°nh: ${Math.round(winRate*100)}%` });
    } else {
        cockFightStats[userId] = 0; 
        embed.setColor('Red').setDescription(`ü™¶ G√† c·ªßa b·∫°n ƒë√£ v·ªÅ n∆°i ch√≠n su·ªëi!\nChu·ªói win reset v·ªÅ 0.`).setFooter({ text: `S·ª©c m·∫°nh: ${Math.round(winRate*100)}%` });
    }
    return message.reply({ embeds: [embed] });
}

async function handleRoll(message, args) {
    const userId = message.author.id;
    if (!rollWaitList[userId]) return;
    if (args[0] !== '10') return message.reply("G√µ `.roll 10` m·ªõi ƒë√∫ng nha!");
    
    const result = Math.floor(Math.random() * 10) + 1;
    delete rollWaitList[userId];
    
    let win = 0, msg = "";
    if ([2, 5, 6].includes(result)) { win = 15000; msg = `üé≤ S·ªë **${result}** - Tr√∫ng **15,000** ${CURRENCY}`; }
    else if (result === 10) { win = 25000; msg = `üé≤ **JACKPOT!** S·ªë **${result}** - Nh·∫≠n Th√™m **25,000** ${CURRENCY}`; }
    else { msg = `üé≤ S·ªë **${result}** - C√≤n ƒë√∫ng c√°i n·ªãt!`; }
    
    if (win > 0) await economy.addMoney(message.guild.id, userId, win, "Lucky Box");
    return message.reply(msg);
}

async function handleInventory(message, args = []) {
    const guildId = message.guild.id;
    let targetUser = message.author;
    
    if (message.mentions.users.size > 0) {
        targetUser = message.mentions.users.first();
    } else if (args.length > 0) {
        const idArg = args[0];
        if (/^\d{17,19}$/.test(idArg)) {
            try {
                targetUser = await message.client.users.fetch(idArg);
            } catch (e) {
                return message.reply("Kh√¥ng t√¨m th·∫•y th√†nh vi√™n v·ªõi ID n√†y.");
            }
        }
    }

    const displayName = targetUser.globalName || targetUser.username;
    const inventory = await economy.getInventory(guildId, targetUser.id);

    if (inventory.length === 0) { 
        return message.reply(targetUser.id === message.author.id 
            ? "üéí Kho ƒë·ªì c·ªßa b·∫°n tr·ªëng tr∆°n! H√£y gh√© `.shop` ƒë·ªÉ mua s·∫Øm nh√©."
            : `üéí Kho ƒë·ªì c·ªßa **${displayName}** tr·ªëng tr∆°n!`
        ); 
    }

    let description = "------------------------------\n";
    let index = 1;
    for (const invItem of inventory) {
        const itemConfig = SHOP_ITEMS[invItem.item_id];
        let itemName = itemConfig ? itemConfig.name : `Unknown Item (${invItem.item_id})`;
        if (itemConfig && itemConfig.emoji) {
            itemName += ` ${itemConfig.emoji}`;
        }
        description += `**${index}.** ${itemName} - **SL: ${invItem.amount}**\n`;
        index++;
    }
    description += "------------------------------";
    
    const embed = new EmbedBuilder()
        .setColor('Gold')
        .setTitle(`**H√≤m ƒê·ªì C·ªßa ${displayName}**`)
        .setDescription(description)
        .setThumbnail(targetUser.displayAvatarURL());
        
    return message.channel.send({ embeds: [embed] });
}

async function handleGiveItem(message, args) {
    const guildId = message.guild.id;
    const senderId = message.author.id;

    if (args.length < 2) return message.reply("C√∫ ph√°p: `.give-item <t√™n item> @user [s·ªë l∆∞·ª£ng]`");

    const targetUser = message.mentions.members.first();
    if (!targetUser) return message.reply("B·∫°n ph·∫£i tag ng∆∞·ªùi nh·∫≠n!");
    if (targetUser.id === senderId) return message.reply("Kh√¥ng th·ªÉ t·ª± t·∫∑ng qu√† cho m√¨nh!");
    if (targetUser.user.bot) return message.reply("Bot kh√¥ng c·∫ßn qu√† ƒë√¢u!");

    const remainingArgs = args.filter(arg => !arg.includes(targetUser.id));

    if (remainingArgs.length === 0) return message.reply("Thi·∫øu t√™n v·∫≠t ph·∫©m!");

    let amount = 1;
    const lastArg = remainingArgs[remainingArgs.length - 1];
    if (!isNaN(lastArg)) {
        amount = parseInt(lastArg);
        remainingArgs.pop();
    }

    if (amount <= 0) return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!");
    const itemKeyword = remainingArgs.join(" "); 
    const item = findItemSmart(itemKeyword);

    if (!item) return message.reply(`Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†o t√™n l√† "**${itemKeyword}**".`);

    const currentAmount = await economy.getItemAmount(guildId, senderId, item.id);
    if (currentAmount < amount) return message.reply(`üéí B·∫°n kh√¥ng ƒë·ªß **${item.name}** ƒë·ªÉ t·∫∑ng (C√≥: ${currentAmount}).`);

    const success = await economy.transferItem(guildId, senderId, targetUser.id, item.id, amount);
    if (success) {
        return message.reply(`‚úÖ ƒê√£ chuy·ªÉn **${amount}x ${item.name}** ${item.emoji || ''} cho ${targetUser}!`);
    } else {
        return message.reply("L·ªói khi chuy·ªÉn v·∫≠t ph·∫©m. Vui l√≤ng th·ª≠ l·∫°i.");
    }
}

// --- X·ª¨ L√ù SHOP & USE ITEM ---
async function handleShop(message, cmd, args) {
    const userId = message.author.id;
    const guildId = message.guild.id;

    // --- ADMIN COMMANDS: ADDSTOCK & SETMONEY ---
    if (cmd === '.addstock') {
        const config = await economy.getConfig(guildId);
        const adminRoles = config.admin_roles || [];
        const isOwner = userId === message.guild.ownerId;
        const hasAdminRole = message.member.roles.cache.some(r => adminRoles.includes(r.id));
        
        if (!isOwner && !hasAdminRole) return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!");
        if (args.length < 2) return message.reply("C√∫ ph√°p: `.addstock <item> <s·ªë l∆∞·ª£ng>`");
        
        let quantity = parseInt(args[args.length - 1]);
        if (isNaN(quantity)) return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá.");
        
        const searchKeyword = args.slice(0, -1).join(' ');
        const item = findItemSmart(searchKeyword);
        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y item.");

        item.stock += quantity; 
        await economy.updateShopItem(item.id, { stock: item.stock });
        return message.reply(`‚úÖ ƒê√£ th√™m **${quantity}** v√†o kho **${item.name}**. T·ªìn kho hi·ªán t·∫°i: **${item.stock}**`);
    }

    if (cmd === '.setmoney') {
        const config = await economy.getConfig(guildId);
        const adminRoles = config.admin_roles || [];
        const isOwner = userId === message.guild.ownerId;
        const hasAdminRole = message.member.roles.cache.some(r => adminRoles.includes(r.id));

        if (!isOwner && !hasAdminRole) return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!");
        if (args.length < 2) return message.reply("C√∫ ph√°p: `.setmoney <item> <gi√° ti·ªÅn>`");
        
        let price = parseInt(args[args.length - 1]);
        if (isNaN(price) || price < 0) return message.reply("Gi√° ti·ªÅn kh√¥ng h·ª£p l·ªá.");
        
        const searchKeyword = args.slice(0, -1).join(' ');
        const item = findItemSmart(searchKeyword);
        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y item.");

        item.price = price; 
        await economy.updateShopItem(item.id, { price: item.price });
        return message.reply(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t gi√° **${item.name}** th√†nh **${price.toLocaleString()} ${CURRENCY}**`);
    }

    if (['.ch', '.cuahang', '.shop'].includes(cmd)) {
        const embed = new EmbedBuilder().setTitle("üõí TI·ªÜM T·∫†P H√ìA MEOU").setColor('Blue');
        Object.values(SHOP_ITEMS)
            .filter(i => i.price > 0)
            .forEach(i => embed.addFields({ name: `${i.name} ${i.emoji ? i.emoji : ''} - ${i.price.toLocaleString()} ${CURRENCY}`, value: `${i.description}\n**Kho: ${i.stock}**` }));
        return message.channel.send({ embeds: [embed] });
    }

    if (cmd === '.mua' || cmd === '.buy') {
        if (!args[0]) return message.reply("B·∫°n mu·ªën mua g√¨? VD: `.mua lucky` ho·∫∑c `.mua lucky 10`");

        let quantity = 1;
        let searchKeyword = "";

        const lastArg = args[args.length - 1];
        if (!isNaN(lastArg) && args.length > 1) {
            quantity = parseInt(lastArg);
            searchKeyword = args.slice(0, -1).join(' ').toLowerCase().trim();
        } else {
            searchKeyword = args.join(' ').toLowerCase().trim();
        }

        if (quantity <= 0) return message.reply("S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.");

        const item = Object.values(SHOP_ITEMS).find(i => {
            if (i.keywords.some(k => k === searchKeyword || k.startsWith(searchKeyword))) return true;
            if (i.name.toLowerCase().includes(searchKeyword)) return true;
            return false;
        });

        if (!item) return message.reply("Shop kh√¥ng c√≥ m√≥n n√†y ho·∫∑c b·∫°n nh·∫≠p ch∆∞a ƒë√∫ng t√™n.");
        if (item.price === 0) return message.reply("‚õî Item n√†y kh√¥ng b√°n, ch·ªâ c√≥ th·ªÉ ki·∫øm ƒë∆∞·ª£c!");
        if (item.stock < quantity) return message.reply(`üò≠ Shop ch·ªâ c√≤n **${item.stock}** c√°i th√¥i.`);
        
        const totalPrice = item.price * quantity;
        
        if (await economy.subtractMoney(guildId, userId, totalPrice, `Mua ${quantity}x ${item.name}`)) {
            item.stock -= quantity;
            await economy.updateShopItem(item.id, { stock: item.stock });
            await economy.addItem(guildId, userId, item.id, quantity);
            message.reply({ embeds: [new EmbedBuilder().setColor('Green').setTitle("üõçÔ∏è MUA TH√ÄNH C√îNG").setDescription(`ƒê√£ mua **${quantity}x ${item.name}**\nƒê√£ c·∫•t v√†o kho ƒë·ªì (\`.inv\`).\nG√µ \`.xai ${item.keywords[0]}\` ƒë·ªÉ d√πng.`)] });
            
        } else return message.reply(`Kh√¥ng ƒë·ªß ti·ªÅn! C·∫ßn **${totalPrice.toLocaleString()} ${CURRENCY}**.`);
    }

    // --- X·ª¨ L√ù L·ªÜNH USE / XAI ---
    if (cmd === '.xai' || cmd === '.use') {
        let quantity = 1;
        let keywordArgs = args;
        const lastArg = args[args.length - 1];

        if (lastArg && lastArg.toLowerCase() === 'all') {
            quantity = 'all'; 
            keywordArgs = args.slice(0, -1);
        } else if (lastArg && !isNaN(parseInt(lastArg))) {
            quantity = parseInt(lastArg);
            keywordArgs = args.slice(0, -1);
        }

        const searchKeyword = keywordArgs.join(' ').toLowerCase().trim();
        const item = Object.values(SHOP_ITEMS).find(i => i.keywords.some(k => k === searchKeyword || k.startsWith(searchKeyword)));
        
        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m.");

        if (item.id === 'lootbox' || item.id === 'lootboxvip') {
            const userStock = await economy.getItemAmount(guildId, userId, item.id);
            if (userStock <= 0) return message.reply(`üéí B·∫°n kh√¥ng c√≥ **${item.name}** n√†o ƒë·ªÉ m·ªü.`);

            if (quantity === 1) {
                const hasItem = await economy.removeItem(guildId, userId, item.id, 1);
                if (!hasItem) return message.reply("üéí L·ªói tr·ª´ item.");

                const boxName = item.id === 'lootboxvip' ? '**Lootbox VIP**' : '**Lootbox**';
                const openEmbed = new EmbedBuilder()
                    .setColor('Purple')
                    .setTitle('**Ti·∫øn H√†nh M·ªü Lootbox**')
                    .setDescription(
                        `--------------------------\n` +
                        `<@${userId}> ƒëang m·ªü ${boxName} v√† nh·∫≠n ƒë∆∞·ª£c <a:lootboxopen:1461108774160039998>`
                    );
                
                const msg = await message.reply({ embeds: [openEmbed] });
                const rates = item.id === 'lootboxvip' ? GEM_RATES_VIP : GEM_RATES;
                
                // FIXED: Lo·∫°i b·ªè vi·ªác sort t·ª± ƒë·ªông theo t·ªâ l·ªá th·∫•p l√™n cao
                const activeRates = [...rates]; 
                
                const rand = Math.random() * 100;
                let accumulatedRate = 0;
                let selectedGem = null;
                for (const gem of activeRates) {
                    accumulatedRate += gem.rate;
                    if (rand <= accumulatedRate) {
                        selectedGem = SHOP_ITEMS[gem.id];
                        break;
                    }
                }
                if (!selectedGem) selectedGem = SHOP_ITEMS['gem1']; 

                await economy.addItem(guildId, userId, selectedGem.id, 1);

                setTimeout(() => {
                    const resultEmbed = new EmbedBuilder()
                        .setColor(item.id === 'lootboxvip' ? 'Gold' : 'Blue')
                        .setTitle('**M·ªü Lootbox Th√†nh C√¥ng**')
                        .setDescription(
                            `--------------------------\n` +
                            `<a:lootboxopened:1461118461186019330> **|** <@${userId}> ƒë√£ m·ªü ${boxName} v√† nh·∫≠n ƒë∆∞·ª£c **${selectedGem.name}** ${selectedGem.emoji}\n\n` +
                            `‚Ä¢ Ng·ªçc ƒë√£ ƒë∆∞·ª£c c·∫•t v√†o kho ƒë·ªì. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh \`.check <item>\` ƒë·ªÉ ki·ªÉm tra gi√° hi·ªán t·∫°i c·ªßa item.\n` +
                            `‚Ä¢ B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh \`.ban <item>\` ho·∫∑c \`.sell <item>\` ƒë·ªÉ b√°n.`
                        );
                    msg.edit({ embeds: [resultEmbed] });
                }, 2000);
                return;
            } else {
                const MAX_OPEN = 10;
                let amountToOpen = (quantity === 'all') ? Math.min(userStock, MAX_OPEN) : Math.min(quantity, userStock, MAX_OPEN);

                await economy.removeItem(guildId, userId, item.id, amountToOpen);

                if ((quantity === 'all' && userStock > MAX_OPEN) || (quantity > MAX_OPEN)) {
                    message.channel.send(`‚ö†Ô∏è Ch·ªâ ƒë∆∞·ª£c m·ªü t·ªëi ƒëa **${MAX_OPEN}** h√≤m/l·∫ßn. ƒêang m·ªü **${amountToOpen}** h√≤m.`);
                }

                const boxName = item.name;
                const boxIcon = item.emoji;
                const rates = item.id === 'lootboxvip' ? GEM_RATES_VIP : GEM_RATES;
                
                // FIXED: Lo·∫°i b·ªè vi·ªác sort t·ª± ƒë·ªông theo t·ªâ l·ªá th·∫•p l√™n cao
                const activeRates = [...rates];

                let processLog = "";
                const getEmbed = (log, currentStepMsg = "") => {
                    return new EmbedBuilder()
                        .setColor(item.id === 'lootboxvip' ? 'Gold' : 'Purple')
                        .setTitle('**Ti·∫øn H√†nh M·ªü Lootbox**')
                        .setDescription(
                            `---------------------------------------------\n` +
                            `<@${userId}> ƒë√£ ti·∫øn h√†nh m·ªü **${amountToOpen}** ${boxIcon} **${boxName}**\n\n` +
                            log +
                            currentStepMsg
                        );
                };

                const msg = await message.reply({ embeds: [getEmbed(processLog)] });

                for (let i = 1; i <= amountToOpen; i++) {
                    const openingMsg = `\nH√≤m s·ªë ${i} ƒëang m·ªü <a:lootboxopen:1461108774160039998> v√† nh·∫≠n ƒë∆∞·ª£c...`;
                    await msg.edit({ embeds: [getEmbed(processLog, openingMsg)] });
                    await new Promise(r => setTimeout(r, 2000));

                    const rand = Math.random() * 100;
                    let accumulatedRate = 0;
                    let selectedGem = null;
                    for (const gem of activeRates) {
                        accumulatedRate += gem.rate;
                        if (rand <= accumulatedRate) {
                            selectedGem = SHOP_ITEMS[gem.id];
                            break;
                        }
                    }
                    if (!selectedGem) selectedGem = SHOP_ITEMS['gem1'];

                    await economy.addItem(guildId, userId, selectedGem.id, 1);
                    processLog += `H√≤m s·ªë ${i} ƒë√£ m·ªü <a:lootboxopened:1461118461186019330> v√† nh·∫≠n ƒë∆∞·ª£c ${selectedGem.emoji} **${selectedGem.name}**\n`;
                    await msg.edit({ embeds: [getEmbed(processLog)] });

                    if (i < amountToOpen) {
                        await new Promise(r => setTimeout(r, 1000));
                    }
                }
                return;
            }
        }

        const hasItem = await economy.removeItem(guildId, userId, item.id, 1);
        if (!hasItem) return message.reply("üéí Kh√¥ng c√≥ h√†ng trong kho.");

        if (item.id === 'luckybox') {
            rollWaitList[userId] = true;
            message.reply({ embeds: [new EmbedBuilder().setColor('Purple').setTitle(`üì¶ ƒê√É M·ªû ${item.name.toUpperCase()}`).setDescription(item.useDescription)] });
        } else if (item.id === 'chickenbox') {
            if (chickenSessions[userId]) {
                await economy.addItem(guildId, userId, item.id, 1); 
                return message.reply("üö´ ƒêang c√≥ g√† r·ªìi, ƒë√° xong ƒëi ƒë√£.");
            }
            const getDesc = (t) => `**Lu·∫≠t:** Trong **${t}s** h√£y ƒë√° 3 tr·∫≠n ƒë√° g√†.\nüëä G√µ \`.dg\` ƒë·ªÉ ƒë√°.\n------------------------\n‚Ä¢Th·∫Øng 1 L·∫ßn: Nh·∫≠n 20,000ü™ô\n‚Ä¢Th·∫Øng 2 L·∫ßn: Th√™m 15,000ü™ô\n‚Ä¢Th·∫Øng 3 L·∫ßn: Th√™m 25,000ü™ô`;
            const embed = new EmbedBuilder().setColor('DarkRed').setTitle("üêì G√Ä CHI·∫æN V√ÄO CHU·ªíNG!").setDescription(getDesc(120));
            const msg = await message.reply({ embeds: [embed] });
            let t = 120;
            const timer = setInterval(async () => { 
                t--; 
                if (t <= 0) { 
                    clearInterval(timer); 
                    delete chickenSessions[userId]; 
                    msg.edit({ embeds: [EmbedBuilder.from(embed).setDescription("**H·∫æT GI·ªú!**")] }); 
                    return; 
                } 
                try { msg.edit({ embeds: [EmbedBuilder.from(embed).setDescription(getDesc(t))] }); } catch (e) {} 
            }, 1000);
            chickenSessions[userId] = { wins: 0, startTime: Date.now(), timer: timer };
        } else {
             message.reply({ embeds: [new EmbedBuilder().setColor('Purple').setTitle(`üì¶ ƒê√É S·ª¨ D·ª§NG ${item.name.toUpperCase()}`).setDescription("ƒê√£ s·ª≠ d·ª•ng v·∫≠t ph·∫©m.")] });
        }
    }
}

module.exports = { 
    handleChicken, 
    handleRoll, 
    handleShop, 
    handleInventory, 
    handleGiveItem, 
    initShopData, 
    handleSellGem, 
    handleCheckPrice, 
    handleAddItem,
    handleItemInfo,
    handleRemoveItem
};

================================================================================
FILE: games/roulette.js
================================================================================
const { 
    EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, 
    ModalBuilder, TextInputBuilder, TextInputStyle, AttachmentBuilder,
    MessageFlags, ComponentType 
} = require('discord.js');
const economy = require('../utils/economy');
const fs = require('fs');

const GAME_CONFIG = {
    minBet: 1,
    maxBetPerTurn: 500000,
    maxTotalBet: 1000000,    
    countdown: 45 
};

const RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
const activeGames = new Map();

const BET_ALIASES = {
    'red': 'red', 'do': 'red', 'ƒë·ªè': 'red', 'd': 'red',
    'black': 'black', 'den': 'black', 'ƒëen': 'black',
    'even': 'even', 'chan': 'even', 'ch·∫µn': 'even', 'c': 'even',
    'odd': 'odd', 'le': 'odd', 'l·∫ª': 'odd', 'l': 'odd',
    '1-12': '1-12', '1st': '1-12', 'mot': '1-12', 'nh·∫•t': '1-12',
    '13-24': '13-24', '2nd': '13-24', 'hai': '13-24', 'nh√¨': '13-24',
    '25-36': '25-36', '3rd': '25-36', 'ba': '25-36',
};

async function handleRoulette(message, args) {
    if (args.length === 0) {
        if (activeGames.has(message.channel.id)) {
            return message.reply("S√≤ng ƒëang m·ªü r·ªìi b·∫°n ∆°i! Nhanh tay ƒë·∫∑t c∆∞·ª£c ƒëi n√†o.");
        }
        return startGame(message);
    }

    if (args.length >= 2) {
        const betTypeRaw = args[0]; 
        const amountRaw = args[1];  
        
        await handleCommandBet(message, betTypeRaw, amountRaw);
    }
}

async function handleCommandBet(message, typeInput, amountInput) {
    const channelId = message.channel.id;
    let gameState = activeGames.get(channelId);

    if (!gameState) {
        await startGame(message);
        gameState = activeGames.get(channelId);
        if (!gameState) return message.reply("L·ªói kh√¥ng th·ªÉ m·ªü s√≤ng, b·∫°n th·ª≠ l·∫°i gi√∫p m√¨nh nh√©.");
    }

    let betType = null;
    let betValue = null;

    if (!isNaN(typeInput) && parseInt(typeInput) >= 0 && parseInt(typeInput) <= 36) {
        betType = 'specific';
        betValue = parseInt(typeInput);
    } else {
        betType = BET_ALIASES[typeInput];
    }

    if (!betType) {
        return message.reply(`Kh√¥ng hi·ªÉu c·ª≠a **"${typeInput}"** l√† c·ª≠a n√†o. B·∫°n th·ª≠: ƒë·ªè, ƒëen, ch·∫µn, l·∫ª, 1-12, ho·∫∑c s·ªë 0-36 xem.`);
    }

    let amountStr = amountInput.replace(/k/g, '000').replace(/,/g, '');
    let amount = parseInt(amountStr);

    if (isNaN(amount) || amount < GAME_CONFIG.minBet) {
        return message.reply(`Ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá ho·∫∑c nh·ªè qu√° b·∫°n ∆°i (T·ªëi thi·ªÉu ${GAME_CONFIG.minBet} ü™ô).`);
    }

    await processBetLogic(
        message.channel, 
        message.author, 
        betType, 
        betValue, 
        amount, 
        true 
    );
}

async function startGame(message) {
    const endTime = Date.now() + GAME_CONFIG.countdown * 1000;
    // const guildId = message.guild.id; // B·ªè guildId
    
    activeGames.set(message.channel.id, {
        // guildId: guildId, // B·ªè
        endTime: endTime,
        bets: [], 
        usersSelection: new Map(), 
        userBetMessages: new Map(), 
        gameMsg: null
    });

    const rowBets1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('bet_red').setLabel('ƒê·ªè (x2)').setStyle(ButtonStyle.Danger),
        new ButtonBuilder().setCustomId('bet_black').setLabel('ƒêen (x2)').setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId('bet_even').setLabel('Ch·∫µn (x2)').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('bet_odd').setLabel('L·∫ª (x2)').setStyle(ButtonStyle.Primary),
    );

    const rowBets2 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('bet_1-12').setLabel('1-12 (x3)').setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId('bet_13-24').setLabel('13-24 (x3)').setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId('bet_25-36').setLabel('25-36 (x3)').setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId('bet_specific').setLabel('üéØ S·ªë (x36)').setStyle(ButtonStyle.Secondary),
    );
    
    const rowChips1 = new ActionRowBuilder().addComponents(
        createChipBtn(1000), createChipBtn(2000), createChipBtn(5000), createChipBtn(10000)
    );
    const rowChips2 = new ActionRowBuilder().addComponents(
        createChipBtn(15000), createChipBtn(20000), createChipBtn(25000), createChipBtn(50000)
    );

    let files = [];
    try {
        if (fs.existsSync('./roulette.png')) {
            const imageAttachment = new AttachmentBuilder('./roulette.png', { name: 'roulette.png' });
            files.push(imageAttachment);
        }
    } catch (e) { console.log("Thi·∫øu ·∫£nh roulette.png"); }

    const timestamp = Math.floor(endTime / 1000);

    const embed = new EmbedBuilder()
        .setTitle('ROULETTE - NH√Ä C√ÅI ƒê·∫æN T·ª™ CH√ÇU PHI')
        .setDescription(
            `‚è±Ô∏è **CH·ªêT S·ªî SAU:** <t:${timestamp}:R>\n\n` +
            `üìú **C√ÅCH CH∆†I:**\n` +
            `1Ô∏è‚É£ **D√πng N√∫t:** Ch·ªçn C·ª≠a -> Ch·ªçn Ti·ªÅn.\n` +
            `2Ô∏è‚É£ **D√πng L·ªánh:** Chat \`.rl <c·ª≠a> <ti·ªÅn>\` (VD: \`.rl ƒë·ªè 50k\`, \`.rl 20 10k\`)\n` +
            `3Ô∏è‚É£ **C·ª≠a h·ªó tr·ª£:** ƒê·ªè, ƒêen, Ch·∫µn, L·∫ª, 1-12, 13-24, 25-36, S·ªë 0-36.`
        )
        .setColor('#FF4500')
        .setFooter({ text: 'Xanh ch√≠n - Uy t√≠n - H·ªó tr·ª£ l·ªánh chat' });

    if (files.length > 0) embed.setImage('attachment://roulette.png');

    const gameMsg = await message.channel.send({ 
        embeds: [embed], 
        components: [rowBets1, rowBets2, rowChips1, rowChips2], 
        files: files
    });

    const collector = gameMsg.createMessageComponentCollector({ 
        filter: i => !i.user.bot, 
        time: GAME_CONFIG.countdown * 1000 
    });
    
    const gameState = activeGames.get(message.channel.id);
    if (gameState) gameState.gameMsg = gameMsg; 

    collector.on('collect', async i => handleInteraction(i, message.channel.id));
    collector.on('end', async () => finishGame(message.channel));
}

function createChipBtn(amount) {
    return new ButtonBuilder()
        .setCustomId(`chip_${amount}`)
        .setLabel(`${amount.toLocaleString()} ü™ô`)
        .setStyle(ButtonStyle.Secondary);
}

async function handleInteraction(interaction, channelId) {
    const gameState = activeGames.get(channelId);
    if (!gameState) return interaction.reply({ content: 'V√°n ch∆°i k·∫øt th√∫c r·ªìi!', flags: MessageFlags.Ephemeral });

    const userId = interaction.user.id;
    const customId = interaction.customId;

    if (customId.startsWith('bet_')) {
        const type = customId.replace('bet_', '');
        
        if (type === 'specific') {
            const modal = new ModalBuilder().setCustomId('modal_number').setTitle('Ch·ªçn S·ªë May M·∫Øn');
            const input = new TextInputBuilder().setCustomId('input_num').setLabel("S·ªë (0-36)").setStyle(TextInputStyle.Short).setRequired(true);
            modal.addComponents(new ActionRowBuilder().addComponents(input));
            
            await interaction.showModal(modal);
            
            try {
                const modalSubmit = await interaction.awaitModalSubmit({ 
                    time: 60000, 
                    filter: i => i.customId === 'modal_number' && i.user.id === userId
                });
                
                const numStr = modalSubmit.fields.getTextInputValue('input_num');
                const number = parseInt(numStr);
                
                if (isNaN(number) || number < 0 || number > 36) {
                    await modalSubmit.reply({ content: 'S·ªë kh√¥ng h·ª£p l·ªá!', flags: MessageFlags.Ephemeral });
                } else {
                    gameState.usersSelection.set(userId, { type: 'specific', value: number });
                    await modalSubmit.reply({ content: ` ƒê√£ ch·ªçn s·ªë **${number}**. B·∫•m ch·ªçn ti·ªÅn ƒëi b·∫°n!`, flags: MessageFlags.Ephemeral });
                    setTimeout(() => modalSubmit.deleteReply().catch(() => {}), 3000);
                }
            } catch (e) {}
            return;
        }

        gameState.usersSelection.set(userId, { type: type, value: null });
        
        await interaction.reply({ content: ` ƒê√£ ch·ªçn c·ª≠a **${type.toUpperCase()}**. Gi·ªù b·∫•m ch·ªçn ti·ªÅn ƒëi b·∫°n!`, flags: MessageFlags.Ephemeral });
        setTimeout(() => interaction.deleteReply().catch(() => {}), 3000);
        return;
    }

    if (customId.startsWith('chip_')) {
        const selection = gameState.usersSelection.get(userId);
        if (!selection) return interaction.reply({ content: `Ch·ªçn c·ª≠a c∆∞·ª£c tr∆∞·ªõc ƒë√£ b·∫°n ∆°i!`, flags: MessageFlags.Ephemeral });

        const amount = parseInt(customId.split('_')[1]);
        
        await interaction.deferUpdate();
        await processBetLogic(interaction.channel, interaction.user, selection.type, selection.value, amount, true);
    }
}

async function processBetLogic(channel, user, type, value, amount, showPublicMsg) {
    const gameState = activeGames.get(channel.id);
    if (!gameState) {
        if (showPublicMsg) channel.send("S√≤ng ƒë√£ ƒë√≥ng ho·∫∑c ch∆∞a m·ªü k·ªãp, b·∫°n th·ª≠ l·∫°i nh√©.");
        return;
    }

    const currentTotal = gameState.bets
        .filter(b => b.userId === user.id)
        .reduce((sum, b) => sum + b.amount, 0);

    if (currentTotal + amount > GAME_CONFIG.maxTotalBet) {
        const msg = `üõë B·∫°n ch∆°i l·ªõn qu√°! Gi·ªõi h·∫°n m·ªói v√°n l√† ${GAME_CONFIG.maxTotalBet.toLocaleString()} ü™ô th√¥i.`;
        if (showPublicMsg) channel.send(msg);
        return;
    }

    try {
        // Global Balance Check (B·ªè guildId)
        const bal = await economy.getBalance(user.id);
        if (bal.cash < amount) {
            const msg = `**Kh√¥ng ƒë·ªß l√∫a!** B·∫°n c√≤n c√≥ ${bal.cash.toLocaleString()} ü™ô √†.`;
            if (showPublicMsg) channel.send(msg);
            return;
        }
        
        // Global Deduct (B·ªè guildId)
        const success = await economy.subtractMoney(user.id, amount, "Bet Roulette");
        if (!success) {
             if (showPublicMsg) channel.send(`L·ªói h·ªá th·ªëng khi tr·ª´ ti·ªÅn!`);
             return;
        }

        const existingBet = gameState.bets.find(b => 
            b.userId === user.id && 
            b.type === type && 
            b.value === value 
        );

        if (existingBet) {
            existingBet.amount += amount;
        } else {
            gameState.bets.push({
                userId: user.id,
                username: user.username,
                type: type,
                value: value,
                amount: amount
            });
        }

        if (showPublicMsg) {
            const userBets = gameState.bets.filter(b => b.userId === user.id);
            
            const betDescriptions = userBets.map(bet => {
                let betName = "";
                if (bet.type === 'specific') betName = `s·ªë **${bet.value}**`;
                else if (bet.type === 'red') betName = `**ƒê·ªè**`;
                else if (bet.type === 'black') betName = `**ƒêen**`;
                else if (bet.type === 'even') betName = `**Ch·∫µn**`;
                else if (bet.type === 'odd') betName = `**L·∫ª**`;
                else betName = `kho·∫£ng **${bet.type}**`;
                
                return `**${bet.amount.toLocaleString()} ü™ô** v√†o ${betName}`;
            });

            const fullDescription = `${user.toString()} ƒë√£ c∆∞·ª£c t·ªïng ${betDescriptions.join(' **+** ')}`;

            const pinkEmbed = new EmbedBuilder()
                .setColor('#FF69B4') 
                .setDescription(fullDescription)
                .setFooter({ text: 'Nh√† c√°i nh·∫≠n c∆∞·ª£c!' });

            const existingMsg = gameState.userBetMessages.get(user.id);

            if (existingMsg) {
                try {
                    await existingMsg.edit({ embeds: [pinkEmbed] });
                } catch (e) {
                    const newMsg = await channel.send({ embeds: [pinkEmbed] });
                    gameState.userBetMessages.set(user.id, newMsg);
                }
            } else {
                const newMsg = await channel.send({ embeds: [pinkEmbed] });
                gameState.userBetMessages.set(user.id, newMsg);
            }
        } 

    } catch (e) {
        console.error(e);
        if (showPublicMsg) channel.send("L·ªói k·∫øt n·ªëi ng√¢n h√†ng ho·∫∑c Bot ch∆∞a c√≥ quy·ªÅn!");
    }
}

async function finishGame(channel) {
    const gameState = activeGames.get(channel.id);
    if (!gameState) return;

    if (gameState.gameMsg) {
        try {
            const disabledRows = gameState.gameMsg.components.map(row => {
                const r = ActionRowBuilder.from(row);
                r.components.forEach(c => c.setDisabled(true));
                return r;
            });
            await gameState.gameMsg.edit({ components: disabledRows });
        } catch (e) {}
    }

    activeGames.delete(channel.id);

    const resultNum = Math.floor(Math.random() * 37);
    
    let color = 'green'; 
    if (RED_NUMBERS.includes(resultNum)) color = 'red';
    else if (resultNum !== 0) color = 'black';

    const isEven = resultNum !== 0 && resultNum % 2 === 0;
    const colorEmoji = { 'red': 'üî¥', 'black': '‚ö´', 'green': 'üü¢' };

    const playerResults = new Map();

    for (const bet of gameState.bets) {
        let multiplier = 0;

        if (bet.type === 'specific' && bet.value === resultNum) multiplier = 36;
        else if (bet.type === 'red' && color === 'red') multiplier = 2;
        else if (bet.type === 'black' && color === 'black') multiplier = 2;
        else if (bet.type === 'even' && isEven) multiplier = 2;
        else if (bet.type === 'odd' && !isEven && resultNum !== 0) multiplier = 2;
        else if (bet.type === '1-12' && resultNum >= 1 && resultNum <= 12) multiplier = 3;
        else if (bet.type === '13-24' && resultNum >= 13 && resultNum <= 24) multiplier = 3;
        else if (bet.type === '25-36' && resultNum >= 25 && resultNum <= 36) multiplier = 3;

        const payout = bet.amount * multiplier;

        if (!playerResults.has(bet.userId)) {
            playerResults.set(bet.userId, {
                totalBet: 0,
                totalPayout: 0,
                details: []
            });
        }

        const stats = playerResults.get(bet.userId);
        stats.totalBet += bet.amount;
        stats.totalPayout += payout;

        let betDisplay = bet.type === 'specific' ? `S·ªë ${bet.value}` : bet.type.toUpperCase();
        if(betDisplay === 'RED') betDisplay = '**ƒê·ªè**';
        if(betDisplay === 'BLACK') betDisplay = '**ƒêen**';
        if(betDisplay === 'EVEN') betDisplay = '**Ch·∫µm**';
        if(betDisplay === 'ODD') betDisplay = '**L·∫ª**';
        
        stats.details.push(`${bet.amount.toLocaleString()} ü™ô v√†o ${betDisplay}`);
    }

    const resultsList = [];
    
    for (const [userId, stats] of playerResults) {
        if (stats.totalPayout > 0) {
            try {
                // Global Add Money
                await economy.addMoney(userId, stats.totalPayout, "Win Roulette");
            } catch (e) { console.error(`L·ªói tr·∫£ th∆∞·ªüng cho ${userId}:`, e); }
        }

        if (stats.totalPayout > 0) {
            if (stats.details.length === 1) {
                resultsList.push(
                    `<@${userId}> ƒë√£ c∆∞·ª£c ${stats.details[0]} v√† mang v·ªÅ **${stats.totalPayout.toLocaleString()} ü™ô**`
                );
            } else {
                const detailsStr = stats.details.join(' + ');
                resultsList.push(
                    `<@${userId}> ƒë√£ c∆∞·ª£c ${detailsStr} t·ªïng c·ªông h·∫øt **${stats.totalBet.toLocaleString()} ü™ô** v√† mang v·ªÅ **${stats.totalPayout.toLocaleString()} ü™ô**`
                );
            }
        } else {
            if (stats.details.length === 1) {
                resultsList.push(
                    `<@${userId}> ƒë√£ c∆∞·ª£c ${stats.details[0]} v√† m·∫•t h·∫øt`
                );
            } else {
                const detailsStr = stats.details.join(' + ');
                resultsList.push(
                    `<@${userId}> ƒë√£ c∆∞·ª£c ${detailsStr} t·ªïng c·ªông h·∫øt **${stats.totalBet.toLocaleString()} ü™ô** v√† nh√† c√°i h√∫p s·∫°ch. Hihi`
                );
            }
        }
    }

    const resultEmbed = new EmbedBuilder()
        .setAuthor({ 
            name: 'MeoU T√†i X·ªâu - Roulette', 
            iconURL: channel.client.user.displayAvatarURL() 
        })
        .setTitle(`üé≤ K·∫æT QU·∫¢: ${colorEmoji[color]} ${resultNum} ${colorEmoji[color]}`)
        .setColor('#FFFF00') 
        .setDescription(resultsList.length > 0 ? resultsList.join('\n\n') : "Nh√† c√°i h√∫p tr·ªçn! Kh√¥ng ai ch∆°i c·∫£.");

    await channel.send({ embeds: [resultEmbed] });
}

module.exports = { handleRoulette };

================================================================================
FILE: games/shop.js
================================================================================
// games/shop.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');
const { SHOP_ITEMS, CURRENCY, GEM_RATES, GEM_RATES_VIP } = require('../config');
const economy = require('../utils/economy');
const gemMarket = require('../utils/gem_market');
const { findItemSmart } = require('../utils/helpers');

// ID C·ª¶A B·∫†N
const OWNER_ID = '414792622289190917';

// Sync data shop l√∫c kh·ªüi ƒë·ªông
async function initShopData() {
    if (economy.syncShopData) {
        await economy.syncShopData(SHOP_ITEMS);
    }
}

async function handleShop(message, cmd, args) {
    const userId = message.author.id;
    // const guildId = message.guild.id; // Kh√¥ng c·∫ßn d√πng guildId cho economy n·ªØa

    // --- ADMIN COMMANDS: ADDSTOCK & SETMONEY (CH·ªà OWNER) ---
    if (cmd === '.addstock') {
        if (userId !== OWNER_ID) return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
        if (args.length < 2) return message.reply("C√∫ ph√°p: `.addstock <item> <s·ªë l∆∞·ª£ng>`");
        
        let quantity = parseInt(args[args.length - 1]);
        if (isNaN(quantity)) return message.reply("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá.");
        
        const searchKeyword = args.slice(0, -1).join(' ');
        const item = findItemSmart(searchKeyword);
        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y item.");

        item.stock += quantity; 
        await economy.updateShopItem(item.id, { stock: item.stock });
        return message.reply(`‚úÖ ƒê√£ th√™m **${quantity}** v√†o kho **${item.name}**. T·ªìn kho hi·ªán t·∫°i: **${item.stock}**`);
    }

    if (cmd === '.setmoney') {
        if (userId !== OWNER_ID) return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
        if (args.length < 2) return message.reply("C√∫ ph√°p: `.setmoney <item> <gi√° ti·ªÅn>`");
        
        let price = parseInt(args[args.length - 1]);
        if (isNaN(price) || price < 0) return message.reply("Gi√° ti·ªÅn kh√¥ng h·ª£p l·ªá.");
        
        const searchKeyword = args.slice(0, -1).join(' ');
        const item = findItemSmart(searchKeyword);
        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y item.");

        item.price = price; 
        await economy.updateShopItem(item.id, { price: item.price });
        return message.reply(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t gi√° **${item.name}** th√†nh **${price.toLocaleString()} ${CURRENCY}**`);
    }

    // --- USER COMMANDS: VIEW SHOP & BUY ---
    if (['.ch', '.cuahang', '.shop'].includes(cmd)) {
        const embed = new EmbedBuilder().setTitle("üõí TI·ªÜM T·∫†P H√ìA MEOU").setColor('Blue');
        
        const itemsToShow = Object.values(SHOP_ITEMS).filter(i => 
            i.price > 0 || ['crate', 'crateL'].includes(i.id)
        );

        itemsToShow.sort((a, b) => {
            const isBoxA = a.id.includes('box') || a.id.includes('crate');
            const isBoxB = b.id.includes('box') || b.id.includes('crate');
            if (isBoxA && !isBoxB) return -1;
            if (!isBoxA && isBoxB) return 1;
            return 0;
        });

        itemsToShow.forEach(i => {
            const priceDisplay = i.price > 0 ? `${i.price.toLocaleString()} ${CURRENCY}` : "**Mi·ªÖn Ph√≠ (S·ª± ki·ªán)**";
            const emojiDisplay = i.emoji ? i.emoji : '';
            embed.addFields({ 
                name: `${emojiDisplay} ${i.name} - ${priceDisplay}`, 
                value: `${i.description}\n**Kho: ${i.stock}**` 
            });
        });

        return message.channel.send({ embeds: [embed] });
    }

    if (cmd === '.mua' || cmd === '.buy') {
        if (!args[0]) return message.reply("B·∫°n mu·ªën mua g√¨? VD: `.mua lucky` ho·∫∑c `.mua lucky 10`");

        let quantity = 1;
        let searchKeyword = "";

        const lastArg = args[args.length - 1];
        if (!isNaN(lastArg) && args.length > 1) {
            quantity = parseInt(lastArg);
            searchKeyword = args.slice(0, -1).join(' ').toLowerCase().trim();
        } else {
            searchKeyword = args.join(' ').toLowerCase().trim();
        }

        if (quantity <= 0) return message.reply("S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.");

        const item = Object.values(SHOP_ITEMS).find(i => {
            if (i.keywords.some(k => k === searchKeyword || k.startsWith(searchKeyword))) return true;
            if (i.name.toLowerCase().includes(searchKeyword)) return true;
            return false;
        });

        if (!item) return message.reply("Shop kh√¥ng c√≥ m√≥n n√†y ho·∫∑c b·∫°n nh·∫≠p ch∆∞a ƒë√∫ng t√™n.");
        
        if (item.price === 0 && !['crate', 'crateL'].includes(item.id)) {
            return message.reply("‚õî Item n√†y kh√¥ng b√°n, ch·ªâ c√≥ th·ªÉ ki·∫øm ƒë∆∞·ª£c!");
        }
        
        if (item.stock < quantity) return message.reply(`üò≠ Shop ch·ªâ c√≤n **${item.stock}** c√°i th√¥i.`);
        
        const totalPrice = item.price * quantity;
        
        // Tr·ª´ ti·ªÅn Global (b·ªè guildId)
        let transactionSuccess = true;
        if (totalPrice > 0) {
            transactionSuccess = await economy.subtractMoney(userId, totalPrice, `Mua ${quantity}x ${item.name}`);
        }

        if (transactionSuccess) {
            item.stock -= quantity;
            await economy.updateShopItem(item.id, { stock: item.stock });
            // C·ªông item Global (b·ªè guildId)
            await economy.addItem(userId, item.id, quantity);
            message.reply({ embeds: [new EmbedBuilder().setColor('Green').setTitle("üõçÔ∏è MUA TH√ÄNH C√îNG").setDescription(`ƒê√£ mua **${quantity}x ${item.name}**\nƒê√£ c·∫•t v√†o kho ƒë·ªì (\`.inv\`).\nG√µ \`.xai ${item.keywords[0]}\` ƒë·ªÉ d√πng.`)] });
            
        } else {
            return message.reply(`Kh√¥ng ƒë·ªß ti·ªÅn! C·∫ßn **${totalPrice.toLocaleString()} ${CURRENCY}**.`);
        }
    }
}

async function handleCheckPrice(message) {
    const content = message.content.trim();
    const args = content.split(/ +/).slice(1); 
    
    if (args.length === 0) {
        const embed = gemMarket.getMarketEmbed();
        return message.channel.send({ embeds: [embed] });
    } else {
        const searchKeyword = args.join(' ');
        const item = findItemSmart(searchKeyword);

        if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y lo·∫°i Ng·ªçc n√†y.");
        if (!item.id.startsWith('gem')) return message.reply("Ch·ªâ c√≥ th·ªÉ xem l·ªãch s·ª≠ gi√° c·ªßa c√°c lo·∫°i Ng·ªçc.");

        const embed = await gemMarket.getGemHistoryEmbed(item.id); 
        return message.channel.send({ embeds: [embed] });
    }
}

async function handleSellGem(message, args) {
    const userId = message.author.id;
    // const guildId = message.guild.id;

    if (args.length === 0) return message.reply("B·∫°n mu·ªën b√°n g√¨? VD: `.ban thothach` ho·∫∑c `.ban thothach 10` ho·∫∑c `.ban thothach all`.");

    let quantity = 1;
    let isAll = false;
    let keywordArgs = args;

    const lastArg = args[args.length - 1].toLowerCase();
    if (lastArg === 'all') {
        isAll = true;
        keywordArgs = args.slice(0, -1);
    } else if (!isNaN(parseInt(lastArg))) {
        quantity = parseInt(lastArg);
        keywordArgs = args.slice(0, -1);
    }

    if (!isAll && quantity <= 0) return message.reply("S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.");

    const searchKeyword = keywordArgs.length > 0 ? keywordArgs.join(' ') : args.join(' ');
    const item = findItemSmart(searchKeyword);

    if (!item) return message.reply("Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†y.");
    if (!item.id.startsWith('gem')) {
        return message.reply("‚õî Ch·ªâ c√≥ **B·∫£o Ng·ªçc** m·ªõi c√≥ th·ªÉ b√°n ·ªü Ch·ª£ ƒêen!");
    }

    // Check kho Global (b·ªè guildId)
    const currentStock = await economy.getItemAmount(userId, item.id);
    if (currentStock <= 0) {
        return message.reply(`üéí B·∫°n kh√¥ng c√≥ **${item.name}** n√†o ƒë·ªÉ b√°n.`);
    }

    if (isAll) {
        quantity = currentStock;
    } else if (quantity > currentStock) {
        quantity = currentStock;
    }

    const marketInfo = gemMarket.getGemPrice(item.id);
    const unitPrice = marketInfo.price;
    const totalPrice = unitPrice * quantity;

    const embed = new EmbedBuilder()
        .setColor('Orange')
        .setTitle('**MeoU Ch·ª£ ƒêen - Ch·ª£ Ng·ªçc**')
        .setDescription(
            `--------------------------------\n` +
            `B·∫°n c√≥ ch·∫Øc mu·ªën b√°n **${quantity}x** ${item.emoji} **${item.name}** kh√¥ng?\n` +
            `Gi√° b√°n: **${unitPrice.toLocaleString()}** ü™ô / vi√™n\n` +
            `T·ªïng nh·∫≠n: **${totalPrice.toLocaleString()}** ü™ô`
        );

    const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('sell_yes').setLabel('C√≥').setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId('sell_no').setLabel('Kh√¥ng').setStyle(ButtonStyle.Danger)
    );

    const replyMsg = await message.reply({ embeds: [embed], components: [row] });

    const collector = replyMsg.createMessageComponentCollector({ 
        componentType: ComponentType.Button, 
        time: 30000,
        filter: i => i.user.id === userId 
    });

    collector.on('collect', async interaction => {
        if (interaction.customId === 'sell_no') {
            await interaction.update({ content: "ƒê√£ h·ªßy l·ªánh b√°n.", embeds: [], components: [] });
            return;
        }

        if (interaction.customId === 'sell_yes') {
            // Check l·∫°i stock Global
            const amountCheck = await economy.getItemAmount(userId, item.id);
            if (amountCheck < quantity) {
                await interaction.update({ content: "S·ªë l∆∞·ª£ng trong kho ƒë√£ thay ƒë·ªïi!", embeds: [], components: [] });
                return;
            }

            // Tr·ª´ item Global
            const removeSuccess = await economy.removeItem(userId, item.id, quantity);
            if (removeSuccess) {
                // C·ªông ti·ªÅn Global
                await economy.addMoney(userId, totalPrice, `Sell ${quantity} ${item.name}`);
                const successEmbed = new EmbedBuilder()
                    .setColor('Green')
                    .setTitle('**MeoU Ch·ª£ ƒêen - Ch·ª£ Ng·ªçc**')
                    .setDescription(
                        `--------------------------------\n` +
                        `B·∫°n ƒë√£ b√°n **${quantity}x** ${item.emoji} **${item.name}** v·ªõi gi√° **${totalPrice.toLocaleString()}** ü™ô`
                    )
                    .setFooter({ text: "MeoU Th∆∞∆°ng Gia - Uy T√≠n h∆°n NYC C·ªßa B·∫°n" });

                await interaction.update({ embeds: [successEmbed], components: [] });
            } else {
                await interaction.update({ content: "L·ªói h·ªá th·ªëng khi giao d·ªãch.", embeds: [], components: [] });
            }
        }
    });

    collector.on('end', (collected, reason) => {
        if (reason === 'time') {
            replyMsg.edit({ content: "‚è∞ H·∫øt th·ªùi gian x√°c nh·∫≠n.", components: [] }).catch(() => {});
        }
    });
}

async function handleItemInfo(message, args) {
    // ... Logic gi·ªØ nguy√™n, kh√¥ng li√™n quan ƒë·∫øn economy ...
    // (ƒê√£ c√≥ trong file g·ªëc, kh√¥ng c·∫ßn s·ª≠a ƒë·ªïi g√¨ v√¨ ch·ªâ hi·ªÉn th·ªã th√¥ng tin tƒ©nh)
    const keyword = args[0] ? args[0].toLowerCase() : '';
    let isVip = false;
    let isNormal = false;

    if (['lootboxvip', 'lbvip', 'vip'].includes(keyword)) isVip = true;
    else if (['lootbox', 'lb'].includes(keyword)) isNormal = true;

    if (!isVip && !isNormal) {
        const item = findItemSmart(keyword);
        if (item) {
             const embed = new EmbedBuilder()
                .setColor('Blue')
                .setTitle(`Th√¥ng tin v·∫≠t ph·∫©m: ${item.name}`)
                .setDescription(`${item.description}\n\nGi√°: ${item.price} ${CURRENCY}\nT·ªìn kho: ${item.stock}`);
             if (item.emoji) embed.setDescription(`${item.emoji} ${item.description}\n\nGi√°: ${item.price} ${CURRENCY}\nT·ªìn kho: ${item.stock}`);
             return message.reply({ embeds: [embed] });
        }
        return message.reply("B·∫°n mu·ªën xem t·ªâ l·ªá h√≤m n√†o? `.iteminfo lb` ho·∫∑c `.iteminfo lbvip`");
    }

    const rates = isVip ? GEM_RATES_VIP : GEM_RATES;
    const boxItem = isVip ? SHOP_ITEMS['lootboxvip'] : SHOP_ITEMS['lootbox'];
    const boxName = boxItem.name;
    const boxIcon = boxItem.emoji;

    let listStr = "";
    for (const rateData of rates) {
        const item = SHOP_ITEMS[rateData.id];
        const percent = rateData.rate.toFixed(1).replace('.', ',');
        listStr += `${item.emoji} ${item.name.padEnd(16, ' ')} ‚Ä¢         ${percent}%\n`;
    }

    const embed = new EmbedBuilder()
        .setColor(isVip ? 'Gold' : 'Blue')
        .setDescription(
            `T·ªâ l·ªá m·ªü h√≤m ${boxIcon} **${boxName}** l√†:\n` +
            `-----------------------------\n` +
            `|     T√™n Ng·ªçc       -          T·ªâ L·ªá |\n` +
            listStr
        );
        
    return message.channel.send({ embeds: [embed] });
}

module.exports = { initShopData, handleShop, handleCheckPrice, handleSellGem, handleItemInfo };

================================================================================
FILE: games/uno_emojis.js
================================================================================
const E = require('../emoji');
module.exports = E.UNO;

================================================================================
FILE: games/uno_game.js
================================================================================
// games/uno_game.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Colors } = require('discord.js');
const { UNO_CONFIG } = require('../config.js');
const EMOJIS = require('./uno_emojis.js');
const UI = require('./uno_ui.js');
const economy = require('../utils/economy.js');

// Store active games
const activeUnoGames = new Map();

class Card {
    constructor(type, color, value) {
        this.type = type;
        this.color = color;
        this.value = value;
        this.id = `card_${Math.random().toString(36).substr(2, 9)}`;
    }

    getIconKey() {
        const colorMap = { 'üî¥': 'R', 'üîµ': 'B', 'üü¢': 'G', 'üü°': 'Y', 'black': '' };
        const prefix = colorMap[this.color] !== undefined ? colorMap[this.color] : '';
        let suffix = '';
        if (this.type === UNO_CONFIG.TYPES.NUMBER) suffix = this.value;
        else if (this.type === UNO_CONFIG.TYPES.SKIP) suffix = 'SKIP';
        else if (this.type === UNO_CONFIG.TYPES.REVERSE) suffix = 'REVERSE';
        else if (this.type === UNO_CONFIG.TYPES.DRAW2) suffix = 'plus2';
        else if (this.type === UNO_CONFIG.TYPES.WILD) suffix = 'WILD';
        else if (this.type === UNO_CONFIG.TYPES.WILD4) suffix = 'WILD4';
        return prefix + suffix;
    }

    toString() {
        const key = this.getIconKey();
        return EMOJIS[key] || `${this.value} ${this.color}`;
    }

    canPlayOn(topCard, activeDrawStack = 0) {
        if (activeDrawStack > 0) {
            if (topCard.type === UNO_CONFIG.TYPES.DRAW2) return this.type === UNO_CONFIG.TYPES.DRAW2 || this.type === UNO_CONFIG.TYPES.WILD4;
            if (topCard.type === UNO_CONFIG.TYPES.WILD4) return this.type === UNO_CONFIG.TYPES.WILD4;
            return false;
        }
        if (this.type === UNO_CONFIG.TYPES.WILD || this.type === UNO_CONFIG.TYPES.WILD4) return true;
        if (this.color === topCard.color) return true;
        if (this.type === UNO_CONFIG.TYPES.NUMBER && this.value === topCard.value) return true;
        if (this.type !== UNO_CONFIG.TYPES.NUMBER && this.type === topCard.type) return true;
        return false;
    }
}

class UnoGame {
    constructor(channel, betAmount, mode, host, onEndGame, onCancelLobby) {
        this.channel = channel;
        this.betAmount = betAmount;
        this.mode = mode; 
        this.host = host;
        this.onEndGame = onEndGame;
        this.onCancelLobby = onCancelLobby;
        this.players = []; 
        this.hands = new Map(); 
        this.publicHandMessages = new Map();
        this.playerInteractions = new Map(); 
        this.lobbyMessage = null;
        this.deck = [];
        this.currentTurnIndex = 0;
        this.direction = 1; 
        this.topCard = null;
        this.lastPlayedCard = null; 
        this.lastPlayerName = null; 
        this.gameOver = false;
        this.drawStack = 0; 
        this.pendingWildUser = null; 
        this.pendingWildCard = null; 
        this.boardMessage = null; 
        this.unoCalled = false; 
        this.turnTimer = null; 
        this.noJoinTimer = null;
        this.autoCancelTimer = null;
        this.generateDeck();
        if (this.mode === 'ranked') this.startLobbyTimers();
    }

    startLobbyTimers() {
        this.noJoinTimer = setTimeout(() => {
            if (this.onCancelLobby && this.players.length < 2) this.onCancelLobby(this, "Qu√° 5 ph√∫t kh√¥ng c√≥ ng∆∞·ªùi tham gia.");
        }, 5 * 60 * 1000);
        this.autoCancelTimer = setTimeout(() => {
            if (this.onCancelLobby) this.onCancelLobby(this, "Qu√° 10 ph√∫t s√≤ng ch∆∞a b·∫Øt ƒë·∫ßu.");
        }, 10 * 60 * 1000);
    }

    generateDeck() {
        this.deck = [];
        const Colors = UNO_CONFIG.COLORS;
        Colors.forEach(color => {
            this.deck.push(new Card(UNO_CONFIG.TYPES.NUMBER, color, 0));
            for (let i = 1; i <= 9; i++) {
                this.deck.push(new Card(UNO_CONFIG.TYPES.NUMBER, color, i));
                this.deck.push(new Card(UNO_CONFIG.TYPES.NUMBER, color, i));
            }
            for (let i = 0; i < 2; i++) {
                this.deck.push(new Card(UNO_CONFIG.TYPES.SKIP, color, -1));
                this.deck.push(new Card(UNO_CONFIG.TYPES.REVERSE, color, -1));
                this.deck.push(new Card(UNO_CONFIG.TYPES.DRAW2, color, -1));
            }
        });
        for (let i = 0; i < 4; i++) {
            this.deck.push(new Card(UNO_CONFIG.TYPES.WILD, 'black', -1));
            this.deck.push(new Card(UNO_CONFIG.TYPES.WILD4, 'black', -1));
        }
        this.shuffleDeck();
    }

    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    drawCard() {
        if (this.deck.length === 0) this.generateDeck(); 
        return this.deck.pop();
    }

    addPlayer(user) {
        if (!this.players.find(p => p.id === user.id)) this.players.push(user);
        if (this.players.length >= 2 && this.noJoinTimer) { clearTimeout(this.noJoinTimer); this.noJoinTimer = null; }
    }

    start() {
        if (this.noJoinTimer) clearTimeout(this.noJoinTimer);
        if (this.autoCancelTimer) clearTimeout(this.autoCancelTimer);
        this.players.forEach(p => this.hands.set(p.id, Array(7).fill(null).map(() => this.drawCard())));
        if (this.mode === 'solo') this.hands.set("0", Array(7).fill(null).map(() => this.drawCard()));
        let firstCard = this.drawCard();
        while (firstCard.type !== UNO_CONFIG.TYPES.NUMBER) {
            this.deck.unshift(firstCard); this.shuffleDeck(); firstCard = this.drawCard();
        }
        this.topCard = firstCard;
        this.lastPlayedCard = firstCard;
        this.lastPlayerName = null;
        this.drawStack = 0;
    }

    getCurrentPlayer() {
        if (this.mode === 'solo') return this.currentTurnIndex === 0 ? this.players[0] : { id: "0", username: "Bot", bot: true };
        return this.players[this.currentTurnIndex];
    }

    nextTurn(skip = false) {
        this.unoCalled = false;
        const total = this.mode === 'solo' ? 2 : this.players.length;
        let step = this.direction;
        if (skip) step *= 2; 
        this.currentTurnIndex = (this.currentTurnIndex + step) % total;
        if (this.currentTurnIndex < 0) this.currentTurnIndex += total;
        this.resetTurnTimer();
    }

    resetTurnTimer() {
        if (this.turnTimer) clearTimeout(this.turnTimer);
        if (this.gameOver) return;
        this.turnTimer = setTimeout(() => this.handleTimeout(), 30000);
    }

    async handleTimeout() {
        if (this.gameOver) return;
        const player = this.getCurrentPlayer();
        if (this.pendingWildUser && this.pendingWildUser === player.id) { await this.resolveWildPlay(player.id, UNO_CONFIG.COLORS[0], true); return; }
        if (player.bot) return;
        const hand = this.hands.get(player.id);
        const playableCardIndex = hand.findIndex(c => c.canPlayOn(this.topCard, this.drawStack));
        let actionMsg = "";
        if (playableCardIndex !== -1) {
            const card = hand[playableCardIndex];
            if (card.type === UNO_CONFIG.TYPES.WILD || card.type === UNO_CONFIG.TYPES.WILD4) {
                 hand.splice(playableCardIndex, 1); this.pendingWildCard = card;
                 await this.resolveWildPlay(player.id, UNO_CONFIG.COLORS[0], true); return;
            }
            hand.splice(playableCardIndex, 1);
            await this.executeCardPlay(player, card, "(Auto)");
        } else {
            if (this.drawStack > 0) {
                const count = this.drawStack; for(let i=0; i<count; i++) hand.push(this.drawCard());
                this.drawStack = 0; actionMsg = `(Auto) Ph·∫£i r√∫t ${count} l√°!`;
            } else {
                hand.push(this.drawCard()); actionMsg = `(Auto) R√∫t 1 l√°`;
            }
            this.nextTurn();
            this.updateBoardMessage(actionMsg);
            this.updateAllPlayersHands();
            if (this.mode === 'solo') await this.runBotTurn();
        }
    }

    async executeCardPlay(player, card, prefixMsg = "") {
        this.topCard = card; this.lastPlayedCard = card; this.lastPlayerName = player.username;
        let extraMsg = prefixMsg; let skipTurn = false;
        if (card.type === UNO_CONFIG.TYPES.DRAW2) { this.drawStack += 2; extraMsg += " (+2)"; } 
        else if (card.type === UNO_CONFIG.TYPES.WILD4) { this.drawStack += 4; extraMsg += " (+4)"; }
        else if (card.type === UNO_CONFIG.TYPES.SKIP) { skipTurn = true; extraMsg += " (C·∫•m)"; }
        else if (card.type === UNO_CONFIG.TYPES.REVERSE) {
            if (this.mode === 'solo' || this.players.length === 2) { skipTurn = true; extraMsg += " (ƒê·∫£o - ƒê√°nh ti·∫øp)"; }
            else { this.direction *= -1; extraMsg += " (ƒê·∫£o chi·ªÅu)"; }
        }
        if (this.boardMessage) { const payload = UI.createBoardPayload(this); await this.boardMessage.edit(payload).catch(() => {}); }
        const hand = this.hands.get(player.id);
        if (hand.length === 0) {
            this.gameOver = true;
            if (this.turnTimer) clearTimeout(this.turnTimer);
            setTimeout(async () => { await this.onEndGame(this, player); }, 1000);
            return;
        }
        this.nextTurn(skipTurn);
        this.updateBoardMessage();
        await this.updateAllPlayersHands();
        if (this.mode === 'solo' && !this.gameOver) await this.runBotTurn();
    }

    async resolveWildPlay(userId, color, isAuto = false) {
        const player = userId === "0" ? { id: "0", username: "Bot", bot: true } : this.players.find(p => p.id === userId);
        const card = this.pendingWildCard;
        card.color = color;
        this.pendingWildUser = null; this.pendingWildCard = null;
        await this.executeCardPlay(player, card, isAuto ? "(Auto)" : "");
    }

    updateBoardMessage(statusMsg = "") {
        if (this.boardMessage) { const payload = UI.createBoardPayload(this, statusMsg); this.boardMessage.edit(payload).catch(() => {}); }
    }
    
    async updateHandMessage(userId) {
        const rows = UI.createHandRows(this, userId);
        const user = this.players.find(p => p.id === userId);
        const endTime = Math.floor(Date.now() / 1000) + 30;
        const currentPlayer = this.getCurrentPlayer();
        const isMyTurn = currentPlayer.id === userId;
        const statusText = isMyTurn ? "‚ö° **L∆∞·ª£t c·ªßa B·∫°n**" : " **ƒêang Ch·ªù ƒê·ªëi Th·ªß**";
        const content = `**${this.host.username}'s UNO Game**\n${user.toString()} ${statusText}\n*H·∫øt gi·ªù: <t:${endTime}:R>*`;
        if (this.mode === 'solo') {
            const msg = this.publicHandMessages.get(userId);
            if (msg) { try { await msg.edit({ content: content, components: rows }); } catch(e) {} }
        } else {
            const interaction = this.playerInteractions.get(userId);
            if (interaction) { try { await interaction.editReply({ content: content, components: rows }); } catch(e) {} }
        }
    }

    async updateAllPlayersHands() {
        for (const player of this.players) { if (!player.bot) await this.updateHandMessage(player.id); }
    }

    botPlay() {
        const botHand = this.hands.get("0");
        const playableCards = botHand.filter(c => c.canPlayOn(this.topCard, this.drawStack));
        if (playableCards.length > 0) {
            let cardToPlay = playableCards.find(c => (this.drawStack > 0 && (c.type === UNO_CONFIG.TYPES.DRAW2 || c.type === UNO_CONFIG.TYPES.WILD4)));
            if (!cardToPlay) cardToPlay = playableCards.find(c => c.type !== UNO_CONFIG.TYPES.WILD && c.type !== UNO_CONFIG.TYPES.WILD4);
            if (!cardToPlay) cardToPlay = playableCards[0];
            const index = botHand.indexOf(cardToPlay);
            botHand.splice(index, 1);
            if (cardToPlay.type === UNO_CONFIG.TYPES.WILD || cardToPlay.type === UNO_CONFIG.TYPES.WILD4) {
                const colorCounts = {};
                botHand.forEach(c => { if(c.color !== 'black') colorCounts[c.color] = (colorCounts[c.color] || 0) + 1; });
                const bestColor = Object.keys(colorCounts).reduce((a, b) => colorCounts[a] > colorCounts[b] ? a : b, UNO_CONFIG.COLORS[0]);
                cardToPlay.color = bestColor;
            }
            let extra = botHand.length === 1 ? "\nBot **UNO!**" : "";
            return { action: 'play', card: cardToPlay, msg: `**Bot ƒë√£ ƒë√°nh** ${cardToPlay}${extra}` };
        } else {
            if (this.drawStack > 0) {
                const count = this.drawStack; for(let i=0; i<count; i++) botHand.push(this.drawCard());
                this.drawStack = 0;
                return { action: 'draw', msg: `Bot ƒê√£ R√∫t ${count} L√° - L∆∞·ª£t C·ªßa B·∫°n!` };
            } else {
                botHand.push(this.drawCard());
                return { action: 'draw', msg: "Bot ƒê√£ R√∫t 1 L√° - L∆∞·ª£t C·ªßa B·∫°n!" };
            }
        }
    }

    async runBotTurn() {
        this.updateAllPlayersHands();
        const currentPlayer = this.getCurrentPlayer();
        if (!currentPlayer.bot) return;
        setTimeout(async () => {
            if (this.gameOver || !this.getCurrentPlayer().bot) return;
            const result = this.botPlay(); 
            if (result.action === 'play') await this.executeCardPlay({ id: "0", username: "Bot", bot: true }, result.card);
            else {
                this.nextTurn(); this.updateBoardMessage(result.msg); this.updateAllPlayersHands();
            }
        }, 3000); 
    }
}

// --- CALLBACK FUNCTIONS ---
async function endGame(game, winner) {
    if (game.turnTimer) clearTimeout(game.turnTimer); 
    const isBotWinner = winner.id === "0" || winner.bot;
    let winnerName = isBotWinner ? "MeoU Bot" : winner.username;
    
    if (!isBotWinner) {
        let reward = game.mode === 'solo' ? game.betAmount * 2 : game.betAmount * game.players.length;
        // Global Add Money (b·ªè guildId)
        await economy.addMoney(winner.id, reward, "Th·∫Øng UNO");
        game.channel.send(`üéâ Ch√∫c m·ª´ng ${winner.toString()} h√∫p **${reward.toLocaleString()}** ü™ô!`);
    } else {
        game.channel.send(`ü§ñ Bot th·∫Øng! Bot xin ti·ªÅn c∆∞·ª£c nh√©.`);
    }

    const embed = new EmbedBuilder().setTitle("üèÅ V√ÅN ƒê·∫§U K·∫æT TH√öC").setDescription(`üèÜ Ng∆∞·ªùi chi·∫øn th·∫Øng: **${winnerName}**`).setColor(Colors.Red);
    await game.channel.send({ embeds: [embed] });
    
    game.publicHandMessages.forEach(async (msg) => { try { await msg.delete(); } catch(e) {} });
    activeUnoGames.delete(game.channel.id);
}

async function cancelLobby(game, reason) {
    if (game.noJoinTimer) clearTimeout(game.noJoinTimer);
    if (game.autoCancelTimer) clearTimeout(game.autoCancelTimer);
    for (const player of game.players) {
        // Global Refund (b·ªè guildId)
        await economy.addMoney(player.id, game.betAmount, "Ho√†n ti·ªÅn UNO");
    }
    if (game.lobbyMessage) {
        const cancelEmbed = new EmbedBuilder().setTitle("Ph√≤ng ƒê√£ B·ªã H·ªßy").setDescription(`**L√Ω do:** ${reason}\n\nƒê√£ ho√†n ti·ªÅn c∆∞·ª£c.`).setColor(Colors.Red);
        try { await game.lobbyMessage.edit({ embeds: [cancelEmbed], components: [] }); } catch (e) {}
    } else {
        game.channel.send(`**Ph√≤ng UNO ƒë√£ b·ªã h·ªßy.**\nL√Ω do: ${reason}\nƒê√£ ho√†n ti·ªÅn.`);
    }
    activeUnoGames.delete(game.channel.id);
}

async function handleUnoCommand(message, args) {
    const allowedChannel = await economy.getGameChannel(message.guild.id, 'uno');
    if (allowedChannel && message.channel.id !== allowedChannel) {
        return message.reply(`üö´ UNO ch·ªâ ch∆°i ƒë∆∞·ª£c ·ªü k√™nh <#${allowedChannel}>!`).then(m => setTimeout(() => m.delete().catch(()=>{}), 5000));
    }

    if (activeUnoGames.has(message.channel.id)) return message.reply("ƒêang c√≥ k√®o r·ªìi b·∫°n ∆°i!");
    
    if (args[0] === 'help') {
        const helpEmbed = UI.createHelpEmbed();
        return message.channel.send({ embeds: [helpEmbed] });
    }

    let isMulti = false;
    let betAmount = 0;
    
    if (args[0] && args[0].toLowerCase() === 'add') {
        isMulti = true; 
        betAmount = parseInt(args[1]);
    } else {
        betAmount = parseInt(args[0]);
    }

    if (isNaN(betAmount) || betAmount < 1000 || betAmount > 50000) {
        return message.reply("Ti·ªÅn c∆∞·ª£c ph·∫£i t·ª´ **1,000** ƒë·∫øn **50,000** ü™ô!");
    }

    // Global Balance Check
    const bal = await economy.getBalance(message.author.id);
    if (bal.cash < betAmount) return message.reply("üí∏ Kh√¥ng ƒë·ªß ti·ªÅn c∆∞·ª£c!");

    const game = new UnoGame(message.channel, betAmount, isMulti ? 'ranked' : 'solo', message.author, endGame, cancelLobby);
    activeUnoGames.set(message.channel.id, game);

    if (!isMulti) {
        // Global Deduct (Solo)
        await economy.subtractMoney(message.author.id, betAmount, "C∆∞·ª£c UNO Solo");
        game.addPlayer(message.author);
        game.start();

        const payload = UI.createBoardPayload(game);
        game.boardMessage = await message.channel.send(payload);
        
        const rows = UI.createHandRows(game, message.author.id);
        const endTime = Math.floor(Date.now() / 1000) + 30;
        const handMsg = await message.channel.send({ 
            content: `**${message.author.username}'s UNO Game**\n${message.author.toString()} ‚ö° **L∆∞·ª£t c·ªßa B·∫°n**\n*H·∫øt gi·ªù: <t:${endTime}:R>*`, 
            components: rows 
        });
        game.publicHandMessages.set(message.author.id, handMsg);
        game.resetTurnTimer();
    } else {
        // Global Deduct (Host Ranked)
        await economy.subtractMoney(message.author.id, betAmount, "C∆∞·ª£c UNO Ranked");
        game.addPlayer(message.author);
        const lobbyEmbed = UI.createLobbyEmbed(game);
        const row = new ActionRowBuilder().addComponents(
            new ButtonBuilder().setCustomId('uno_join').setLabel('V√†o Tr·∫≠n').setStyle(ButtonStyle.Success),
            new ButtonBuilder().setCustomId('uno_start').setLabel('B·∫Øt ƒê·∫ßu').setStyle(ButtonStyle.Danger)
        );
        game.lobbyMessage = await message.channel.send({ embeds: [lobbyEmbed], components: [row] });
    }
}

async function handleUnoInteraction(interaction) {
    const game = activeUnoGames.get(interaction.channelId);
    let targetGame = game;
    if (!targetGame && interaction.channel.type === 1) { 
        for (const [_, g] of activeUnoGames) {
            if (g.players.find(p => p.id === interaction.user.id)) { targetGame = g; break; }
        }
    }
    if (!targetGame) return interaction.reply({content: "Game kh√¥ng t·ªìn t·∫°i!", ephemeral: true});

    const { customId, user } = interaction;

    if (customId === 'uno_join') {
        if (targetGame.players.find(p => p.id === user.id)) return interaction.reply({content: "V√†o r·ªìi!", ephemeral: true});
        if (targetGame.players.length >= 4) return interaction.reply({content: "Full slot!", ephemeral: true});
        
        // Global Check
        const bal = await economy.getBalance(user.id);
        if (bal.cash < targetGame.betAmount) return interaction.reply({content: "Kh√¥ng ƒë·ªß ti·ªÅn!", ephemeral: true});
        
        // Global Deduct (Join Ranked)
        await economy.subtractMoney(user.id, targetGame.betAmount, "C∆∞·ª£c UNO Ranked");
        targetGame.addPlayer(user);
        await interaction.message.edit({ embeds: [UI.createLobbyEmbed(targetGame)] });
        await interaction.reply({ content: "ƒê√£ v√†o! Ch·ªù ch·ªß ph√≤ng start.", ephemeral: true });
        targetGame.playerInteractions.set(user.id, interaction);
    }
    else if (customId === 'uno_start') {
        if (user.id !== targetGame.host.id) return interaction.reply({content: "Ch·ªâ ch·ªß ph√≤ng m·ªõi ƒë∆∞·ª£c start!", ephemeral: true});
        if (targetGame.mode === 'ranked' && targetGame.players.length < 2) return interaction.reply({content: "C·∫ßn t·ªëi thi·ªÉu 2 ng∆∞·ªùi!", ephemeral: true});
        await interaction.message.delete().catch(()=>{});
        targetGame.start();
        const payload = UI.createBoardPayload(targetGame);
        targetGame.boardMessage = await interaction.channel.send(payload);
        targetGame.resetTurnTimer();
        interaction.deferUpdate();
    }
    else if (customId === 'uno_get_hand') {
        if (!targetGame.hands.has(user.id)) return interaction.reply({content: "B·∫°n kh√¥ng ch∆°i v√°n n√†y.", ephemeral: true});
        targetGame.playerInteractions.set(user.id, interaction);
        const rows = UI.createHandRows(targetGame, user.id);
        const endTime = Math.floor(Date.now() / 1000) + 30;
        const currentPlayer = targetGame.getCurrentPlayer();
        const isMyTurn = currentPlayer.id === user.id;
        const statusText = isMyTurn ? "‚ö° **L∆∞·ª£t c·ªßa B·∫°n**" : " **ƒêang Ch·ªù ƒê·ªëi Th·ªß**";
        await interaction.reply({
            content: `**${targetGame.host.username}'s UNO Game**\n${user.toString()} ${statusText}\n*H·∫øt gi·ªù: <t:${endTime}:R>*`,
            components: rows,
            ephemeral: true
        });
    }
    else {
        const currentPlayer = targetGame.getCurrentPlayer();
        if (currentPlayer.id !== user.id) return interaction.reply({content: "Ch∆∞a ƒë·∫øn l∆∞·ª£t!", ephemeral: true});
        if (targetGame.mode === 'ranked') targetGame.playerInteractions.set(user.id, interaction);
        await interaction.deferUpdate().catch(() => {});

        if (customId === 'uno_shout') {
            targetGame.unoCalled = true;
            targetGame.updateHandMessage(user.id);
        }
        else if (customId.startsWith('uno_choose_color_')) {
            if (targetGame.pendingWildUser !== user.id) return;
            const color = customId.replace('uno_choose_color_', '');
            await targetGame.resolveWildPlay(user.id, color);
        }
        else if (customId === 'uno_draw_card') {
            if (targetGame.drawStack > 0) {
                const count = targetGame.drawStack;
                const hand = targetGame.hands.get(user.id);
                for(let i=0; i<count; i++) hand.push(targetGame.drawCard());
                targetGame.drawStack = 0;
                targetGame.nextTurn();
                targetGame.updateBoardMessage(`**${user.username}** b·ªã ph·∫°t r√∫t ${count} l√°!`);
            } else {
                const newCard = targetGame.drawCard();
                targetGame.hands.get(user.id).push(newCard);
                if (newCard.canPlayOn(targetGame.topCard)) {
                    targetGame.updateHandMessage(user.id);
                    return; 
                } else {
                    targetGame.nextTurn();
                    targetGame.updateBoardMessage(`**${user.username}** r√∫t b√†i v√† b·ªè l∆∞·ª£t.`);
                }
            }
            targetGame.updateAllPlayersHands();
            if (targetGame.mode === 'solo') await targetGame.runBotTurn();
        }
        else if (customId.startsWith('uno_play_')) {
            const cardId = customId.replace('uno_play_', '');
            const hand = targetGame.hands.get(user.id);
            const cardIndex = hand.findIndex(c => c.id === cardId);
            if (cardIndex === -1) return;
            const card = hand[cardIndex];
            if (hand.length === 2 && !targetGame.unoCalled) {
                 const p1 = targetGame.drawCard(); const p2 = targetGame.drawCard();
                 hand.push(p1, p2);
            }
            if (card.type === UNO_CONFIG.TYPES.WILD || card.type === UNO_CONFIG.TYPES.WILD4) {
                 hand.splice(cardIndex, 1);
                 targetGame.pendingWildUser = user.id;
                 targetGame.pendingWildCard = card;
                 targetGame.updateHandMessage(user.id);
                 return;
            }
            hand.splice(cardIndex, 1);
            await targetGame.executeCardPlay(user, card);
        }
    }
}

module.exports = { handleUnoCommand, handleUnoInteraction };

================================================================================
FILE: games/uno_ui.js
================================================================================
// games/uno_ui.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Colors, AttachmentBuilder } = require('discord.js');
const { UNO_CONFIG } = require('../config.js');
const EMOJIS = require('./uno_emojis.js');

function createLobbyEmbed(game) {
    const playerList = game.players.map(p => `- ${p.toString()}`).join('\n');
    return new EmbedBuilder()
        .setTitle("LOBBY UNO RANKED")
        .setDescription(`Ch·ªß s√≤ng: ${game.host.toString()}\nC∆∞·ª£c: **${game.betAmount.toLocaleString()}** ü™ô\n\n------------------------\n**Danh S√°ch Tham Gia:**\n${playerList}`)
        .setColor(Colors.Green);
}

function createHelpEmbed() {
    return new EmbedBuilder()
        .setTitle("**MeoU UNO - H∆∞·ªõng D·∫´n C∆° B·∫£n**")
        .setDescription(
            "‚Äî--------------------------------------\n" +
            "**1. Ch·∫ø ƒê·ªô Ch∆°i:**\n" +
            "‚Ä¢ Solo Mode: G√µ `.uno <ti·ªÅn c∆∞·ª£c>` ƒë·ªÉ ti·∫øn h√†nh ƒë·∫•u v·ªõi BOT\n" +
            "‚Ä¢ Ranked Mode: G√µ `.uno add <ti·ªÅn c∆∞·ª£c>` ƒë·ªÉ ti·∫øn h√†nh t·∫°o b√†n ƒë·∫•u. T·ªëi thi·ªÉu 2 ng∆∞·ªùi ch∆°i v√† t·ªëi ƒëa 5 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu b√†n ƒë·∫•u.\n" +
            "‚Äî--------------------------------------------\n" +
            "**2. L√° b√†i ch·ª©c nƒÉng**\n" +
            `‚Ä¢ C·∫•m l∆∞·ª£t - ${EMOJIS.YSKIP}: Khi ƒë√°nh l√° n√†y, ng∆∞·ªùi ch∆°i k·∫ø ti·∫øp s·∫Ω b·ªã m·∫•t l∆∞·ª£t.\n` +
            `‚Ä¢ ƒê·ªïi chi·ªÅu - ${EMOJIS.YREVERSE}: ƒê·∫£o ng∆∞·ª£c chi·ªÅu ƒë√°nh b√†i. V√≠ d·ª• ƒëang ƒë√°nh theo chi·ªÅu kim ƒë·ªìng h·ªì th√¨ ƒë·ªïi th√†nh ng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì.\n` +
            `‚Ä¢ C·ªông 2 - ${EMOJIS.Yplus2}: Ng∆∞·ªùi ch∆°i k·∫ø ti·∫øp b·∫Øt bu·ªôc ph·∫£i b·ªëc 2 l√° b√†i v√† m·∫•t l∆∞·ª£t ƒë√°nh.\n` +
            `‚Ä¢ ƒê·ªïi M√†u - ${EMOJIS.WILD}: C√≥ th·ªÉ ƒë√°nh l√° n√†y b·∫•t c·ª© l√∫c n√†o. B·∫°n ƒë∆∞·ª£c quy·ªÅn ch·ªçn m√†u ti·∫øp theo cho v√°n b√†i (ƒê·ªè, Xanh, V√†ng ho·∫∑c L·ª•c).\n` +
            `‚Ä¢ ƒê·ªïi M√†u C·ªông 4 - ${EMOJIS.WILD4}: "V≈© kh√≠ h·ªßy di·ªát". B·∫°n ƒë∆∞·ª£c ch·ªçn m√†u ti·∫øp theo ng∆∞·ªùi ch∆°i k·∫ø ti·∫øp b·∫Øt bu·ªôc ph·∫£i b·ªëc 4 l√° b√†i v√† m·∫•t l∆∞·ª£t ƒë√°nh.\n` +
            "‚Äî--------------------------------------------\n" +
            "**3. Nguy√™n t·∫Øc ƒë√°nh b√†i:**\n" +
            "Khi ƒë·∫øn l∆∞·ª£t m√¨nh, b·∫°n ph·∫£i ƒë√°nh 1 l√° b√†i sao cho kh·ªõp v·ªõi l√° b√†i v·ª´a ƒë∆∞·ª£c ƒë√°nh tr∆∞·ªõc ƒë√≥ theo quy t·∫Øc:\n" +
            `‚Ä¢ C√πng m√†u: V√≠ d·ª• l√° tr∆∞·ªõc l√† ${EMOJIS.R7}, b·∫°n c√≥ th·ªÉ ƒë√°nh b·∫•t k·ª≥ l√° n√†o m√†u ƒê·ªè.\n` +
            `‚Ä¢ C√πng s·ªë/k√≠ hi·ªáu: V√≠ d·ª• l√° tr∆∞·ªõc l√† ${EMOJIS.R7}, b·∫°n c√≥ th·ªÉ ƒë√°nh l√° ${EMOJIS.Y7}, ${EMOJIS.G7}...\n` +
            `‚Ä¢ L√° b√†i ch·ª©c nƒÉng: L√° ${EMOJIS.WILD} ho·∫∑c ${EMOJIS.WILD4} c√≥ th·ªÉ ƒë√°nh ƒë√® l√™n b·∫•t c·ª© m√†u n√†o.\n` +
            "‚Äî--------------------------------------------\n" +
            "**N·∫øu kh√¥ng c√≥ b√†i ƒë·ªÉ ƒë√°nh?**\n" +
            "N·∫øu tr√™n tay b·∫°n kh√¥ng c√≥ l√° n√†o h·ª£p l·ªá b·∫°n ph·∫£i b·ªëc 1 l√° t·ª´ ch·ªìng b√†i r√∫t.\n" +
            "‚Ä¢ N·∫øu l√° v·ª´a b·ªëc ƒë√°nh ƒë∆∞·ª£c lu√¥n: B·∫°n c√≥ quy·ªÅn ƒë√°nh ngay l·∫≠p t·ª©c ho·∫∑c b·ªè l∆∞·ª£t.\n" +
            "‚Ä¢ N·∫øu v·∫´n kh√¥ng ƒë√°nh ƒë∆∞·ª£c: B·∫°n gi·ªØ l√° ƒë√≥ v√† chuy·ªÉn l∆∞·ª£t cho ng∆∞·ªùi k·∫ø ti·∫øp.\n" +
            "‚Äî--------------------------------------------\n" +
            "**4. Lu·∫≠t h√¥ \"UNO!\"**\n" +
            "ƒê√¢y l√† lu·∫≠t t·∫°o n√™n t√™n g·ªçi c·ªßa tr√≤ ch∆°i.\n" +
            "Khi b·∫°n ƒë√°nh b√†i xu·ªëng v√† tr√™n tay ch·ªâ c√≤n l·∫°i ƒë√∫ng 1 l√° b√†i, anh ph·∫£i b·∫•m \"UNO!\".\n" +
            "‚Ä¢ H√¨nh ph·∫°t: N·∫øu b·∫°n qu√™n h√¥ \"UNO\" v√† b·ªã ng∆∞·ªùi kh√°c/bot ph√°t hi·ªán tr∆∞·ªõc khi ng∆∞·ªùi k·∫ø ti·∫øp ƒë√°nh b√†i, b·∫°n s·∫Ω ph·∫£i b·ªëc ph·∫°t 2 l√° b√†i.\n" +
            "‚Äî--------------------------------------------\n" +
            "**5. Lu·∫≠t c·ªông d·ªìn:**\n" +
            `N·∫øu ng∆∞·ªùi tr∆∞·ªõc ƒë√°nh l√° ${EMOJIS.Yplus2}, ng∆∞·ªùi sau c√≥ th·ªÉ ƒë√°nh ti·∫øp m·ªôt l√° ${EMOJIS.Bplus2} m√†u b·∫•t k√¨ n·ªØa ƒë·ªÉ kh√¥ng ph·∫£i b·ªëc b√†i.\n` +
            `Ng∆∞·ªùi th·ª© 3 s·∫Ω ph·∫£i b·ªëc t·ªïng c·ªông 4 l√° (2+2), ho·∫∑c ƒë√°nh ti·∫øp ${EMOJIS.Gplus2} ƒë·ªÉ d·ªìn cho ng∆∞·ªùi th·ª© 4 b·ªëc 6 l√°...\n` +
            `T∆∞∆°ng t·ª± v·ªõi l√° ${EMOJIS.WILD4}.`
        )
        .setColor(Colors.Green)
        .setFooter({ text: "UNO ƒê∆°n Gi·∫£n D·ªÖ Hi·ªÉu" });
}

function createBoardPayload(game, statusOverride = null) {
    const currentPlayer = game.getCurrentPlayer();
    const isBot = currentPlayer.id === "0";
    
    const turnDisplay = isBot ? "**MeoU Bot**" : currentPlayer.toString();
    const modeText = game.mode === 'solo' ? 'Solo Mode' : 'Ranked Mode';
    
    const cardIconKey = game.topCard.getIconKey(); 
    const fileName = `${cardIconKey}.png`;
    const attachment = new AttachmentBuilder(`./cards/${fileName}`, { name: fileName });

    let description = "";
    
    // 1. Th√¥ng tin c∆∞·ª£c
    const singleBet = game.betAmount.toLocaleString();
    const totalBet = (game.betAmount * game.players.length).toLocaleString();
    
    let betInfo = `üí∞ **C∆∞·ª£c:** ${singleBet} ü™ô`;
    if (game.mode === 'ranked') {
        betInfo += ` (T·ªïng: ${totalBet} ü™ô)`;
    }
    description += `${betInfo}\n\n`;

    // 2. L∆∞·ª£t ch∆°i
    description += `üëâ L∆∞·ª£t C·ªßa: ${turnDisplay}\n\n`;

    // 3. Di·ªÖn bi·∫øn l√° b√†i v·ª´a ƒë√°nh
    let actionLine = "";
    if (game.lastPlayerName) {
        const lastPlayerDisplay = game.lastPlayerName === "Bot" ? "**MeoU Bot**" : `**${game.lastPlayerName}**`;
        actionLine = `‚ö° Di·ªÖn Bi·∫øn: ${lastPlayerDisplay} v·ª´a ƒë√°nh: ${game.topCard.toString()}`;
        if (game.lastPlayerName === "Bot" && game.hands.get("0").length === 1) {
             actionLine += " üì¢ **UNO!**";
        }
    } else {
        actionLine = `üèÅ L√° b√†i kh·ªüi ƒëi·ªÉm: ${game.topCard.toString()}`;
    }
    description += `${actionLine}\n`;
    
    // 4. C√°c tr·∫°ng th√°i game (C·ªông d·ªìn / Th√¥ng b√°o l·ªói/Auto)
    if (game.drawStack > 0) {
        description += `üî• **C·ªông d·ªìn: +${game.drawStack} l√°**\n`;
    }
    if (statusOverride) {
        description += `üîî ${statusOverride}\n`;
    }

    // --- PH·∫¶N M·ªöI TH√äM: HI·ªÇN TH·ªä S·ªê L√Å B√ÄI ---
    description += `--------------------------\n`;

    if (game.mode === 'solo') {
        // Ch·∫ø ƒë·ªô Solo: Hi·ªán Bot
        const botHand = game.hands.get("0");
        const botCount = botHand ? botHand.length : 0;
        description += `ü§ñ **MeoU Bot** c√≤n: **${botCount}** L√°\n`;
    } else {
        // Ch·∫ø ƒë·ªô Ranked: Hi·ªán danh s√°ch ng∆∞·ªùi ch∆°i
        const currentPlayerId = currentPlayer.id;
        
        game.players.forEach(p => {
            const hand = game.hands.get(p.id);
            const count = hand ? hand.length : 0;
            
            const isTurn = p.id === currentPlayerId;
            const statusSuffix = isTurn ? " <a:loading:1461163273872474162> **(ƒêang Ch·ªù...)**" : ""; // C√≥ th·ªÉ th√™m icon loading n·∫øu mu·ªën
            
            // S·ª≠ d·ª•ng username ƒë·ªÉ hi·ªÉn th·ªã t√™n cho g·ªçn
            description += `üë§ **${p.username}** c√≤n: **${count}** L√°${statusSuffix}\n`;
        });
    }
    // ------------------------------------------

    const embed = new EmbedBuilder()
        .setTitle(`V√°n UNO c·ªßa ${game.host.username} - ${modeText}`)
        .setColor(game.topCard.color === 'black' ? Colors.DarkButNotBlack : 
                  (game.topCard.color === 'üî¥' ? Colors.Red : 
                   game.topCard.color === 'üîµ' ? Colors.Blue : 
                   game.topCard.color === 'üü¢' ? Colors.Green : Colors.Gold))
        .setThumbnail(`attachment://${fileName}`)
        .setDescription(description)
        .setFooter({ text: "MeoU Uno - Uy T√≠n H∆°n C·∫£ NYC C·ªßa B·∫°n" });

    const components = [];
    
    if (game.mode === 'ranked') {
        const row = new ActionRowBuilder().addComponents(
            new ButtonBuilder()
                .setCustomId('uno_get_hand')
                .setLabel('üÉè B√†i C·ªßa T√¥i')
                .setStyle(ButtonStyle.Success)
        );
        components.push(row);
    }

    return { embeds: [embed], files: [attachment], components: components };
}

function createHandRows(game, userId) {
    if (game.pendingWildUser === userId) {
        const row = new ActionRowBuilder();
        UNO_CONFIG.COLORS.forEach(color => {
            row.addComponents(
                new ButtonBuilder()
                    .setCustomId(`uno_choose_color_${color}`)
                    .setLabel(color) 
                    .setStyle(ButtonStyle.Secondary)
            );
        });
        return [row];
    }

    const currentPlayer = game.getCurrentPlayer();
    const isMyTurn = currentPlayer.id === userId;

    const hand = game.hands.get(userId) || [];
    const rows = [];
    let currentRow = new ActionRowBuilder();

    // Gi·ªõi h·∫°n hi·ªÉn th·ªã t·ªëi ƒëa 20 l√° ƒë·ªÉ kh√¥ng v·ª° giao di·ªán
    const maxCards = 20;
    const cardsToShow = hand.slice(0, maxCards);

    cardsToShow.forEach((card, index) => {
        if (index > 0 && index % 5 === 0) {
            rows.push(currentRow);
            currentRow = new ActionRowBuilder();
        }
        
        const playable = isMyTurn && card.canPlayOn(game.topCard, game.drawStack);
        const cardString = card.toString();
        const emojiIdMatch = cardString.match(/:(\d+)>/);
        
        const btn = new ButtonBuilder()
            .setCustomId(`uno_play_${card.id}`)
            .setStyle(playable ? ButtonStyle.Secondary : ButtonStyle.Secondary) 
            .setDisabled(!playable); 

        if (emojiIdMatch && emojiIdMatch[1]) {
            btn.setEmoji(emojiIdMatch[1]); 
        } else {
            btn.setLabel(cardString); 
        }

        currentRow.addComponents(btn);
    });

    if (currentRow.components.length >= 5) {
        rows.push(currentRow);
        currentRow = new ActionRowBuilder();
    }
    
    let drawLabel = "R√∫t";
    let drawStyle = ButtonStyle.Primary;
    if (game.drawStack > 0) {
        drawLabel = `Nh·∫≠n ${game.drawStack} l√°!`; 
        drawStyle = ButtonStyle.Danger;
    }

    currentRow.addComponents(
        new ButtonBuilder()
            .setCustomId('uno_draw_card')
            .setLabel(drawLabel)
            .setStyle(drawStyle)
            .setDisabled(!isMyTurn)
    );

    if (hand.length === 2 && !game.unoCalled) {
        currentRow.addComponents(
            new ButtonBuilder()
                .setCustomId('uno_shout')
                .setLabel('UNO!')
                .setStyle(ButtonStyle.Danger)
                .setDisabled(!isMyTurn)
        );
    }

    rows.push(currentRow);
    return rows;
}

module.exports = { createLobbyEmbed, createBoardPayload, createHandRows, createHelpEmbed };

================================================================================
FILE: games/wordchain.js
================================================================================
// games/wordchain.js
const fs = require('fs');
const path = require('path');
const { EmbedBuilder } = require('discord.js');
const economy = require('../utils/economy');
const { ADMIN_ROLE_ID } = require('../config');
const E = require('../emoji'); 

const DATA_DIR = path.join(__dirname, '..', 'data');
const WORDS_FILE = path.join(DATA_DIR, 'official-words.txt');
const CONTRIBUTE_FILE = path.join(DATA_DIR, 'contribute-words.txt'); 
const CONFIG_FILE = path.join(DATA_DIR, 'wordchain-config.json'); 

// ID C·ª¶A B·∫†N
const OWNER_ID = '414792622289190917';

if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
}

const DEFAULT_CONFIG = {
    REWARD_BASE: 1000,       
    REWARD_PER_WORD: 1200,    
    REWARD_MAX: 25000,       
    COOLDOWN_TURNS: 50 
};

let CONFIG = { ...DEFAULT_CONFIG };
if (fs.existsSync(CONFIG_FILE)) {
    try {
        const savedConfig = JSON.parse(fs.readFileSync(CONFIG_FILE));
        CONFIG = { ...DEFAULT_CONFIG, ...savedConfig };
    } catch (e) {
        console.error("L·ªói ƒë·ªçc config n·ªëi t·ª´:", e);
    }
}

function saveConfig() {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(CONFIG, null, 2));
}

const EMOJI = {
    OK: E.SYSTEM.OK,
    WRONG: E.SYSTEM.WRONG,
    HAHA: E.SYSTEM.HAHA,
    HOHO: E.SYSTEM.HOHO,
    HEHE: E.SYSTEM.HEHE,
    AHA: E.SYSTEM.AHA
};

// Map l∆∞u timer c·ª•c b·ªô (V√¨ timer kh√¥ng l∆∞u DB ƒë∆∞·ª£c)
const localTimers = new Map();
let dictionary = new Set(); 

async function loadDictionary() {
    try {
        if (!fs.existsSync(WORDS_FILE)) {
            const sampleWords = ["con g√†", "g√† tr·ªëng", "tr·ªëng m√°i", "m√°i nh√†", "nh√† c·ª≠a"].join('\n');
            fs.writeFileSync(WORDS_FILE, sampleWords);
        }
        const data = fs.readFileSync(WORDS_FILE, 'utf-8');
        const words = data.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w.length > 0);
        dictionary = new Set(words);
        console.log(` [WordChain] ƒê√£ t·∫£i ${dictionary.size} t·ª´ v·ª±ng.`);
    } catch (e) {
        console.error("[WordChain] L·ªói t·∫£i t·ª´ ƒëi·ªÉn:", e);
    }
}

async function addContributeWords(newWordsArray) {
    const validWords = newWordsArray.map(w => w.trim().toLowerCase()).filter(w => w.length > 0);
    if (validWords.length === 0) return 0;

    let addedCount = 0;
    validWords.forEach(w => {
        if (!dictionary.has(w)) {
            dictionary.add(w);
            addedCount++;
        }
    });

    if (addedCount > 0) {
        const fileContent = validWords.join('\n') + '\n';
        fs.appendFileSync(CONTRIBUTE_FILE, fileContent, 'utf8');
    }
    return addedCount;
}

function getWordChainConfig() { return CONFIG; }
function updateWordChainConfig(newConfig) { CONFIG = { ...CONFIG, ...newConfig }; saveConfig(); }
function isValidWord(word) { return dictionary.has(word.toLowerCase()); }

function checkWordCooldown(words, word) {
    for (let j = words.length - 1; j >= 0; j--) {
        if (words[j] === word) {
            const distance = words.length - j;
            if (distance <= CONFIG.COOLDOWN_TURNS) return CONFIG.COOLDOWN_TURNS - distance + 1;
        }
    }
    return false;
}

function setIdleReminder(channel, word) {
    if (localTimers.has(channel.id)) clearTimeout(localTimers.get(channel.id));

    const timer = setTimeout(() => {
        const session = economy.getGameSession(channel.id);
        if (session && session.game_type === 'noitu') {
            const embed = new EmbedBuilder()
                .setColor('Yellow')
                .setDescription(`${EMOJI.AHA} **Game ƒëang ch·ªù!** T·ª´ hi·ªán t·∫°i l√†: **${word.toUpperCase()}**\nüëâ H√£y n·ªëi ti·∫øp b·∫±ng t·ª´ b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ **"${word.split(' ').pop().toUpperCase()}"**`);
            channel.send({ embeds: [embed] }).catch(() => {});
        }
    }, 120000); 
    
    localTimers.set(channel.id, timer);
}

const sendAutoDeleteMessage = (message, msgContent, seconds = 5) => {
    message.channel.send({ content: msgContent }).then(m => {
        setTimeout(() => m.delete().catch(() => {}), seconds * 1000);
    }).catch(() => {});
};

async function handleWordChain(message, cmd, args) {
    const channelId = message.channel.id;
    const userId = message.author.id;
    const guildId = message.guild.id;
    const content = message.content.trim().toLowerCase();

    // L·∫•y Session t·ª´ Economy (DB/RAM)
    const sessionDB = economy.getGameSession(channelId);
    const isRunning = sessionDB && sessionDB.game_type === 'noitu';

    // .START
    if (cmd === '.start') {
        if (isRunning) {
            return message.reply("Game n·ªëi t·ª´ ƒëang ch·∫°y ·ªü k√™nh n√†y r·ªìi! D√πng `.stop` ƒë·ªÉ d·ª´ng.");
        }

        if (dictionary.size === 0) await loadDictionary();
        const dictArray = Array.from(dictionary);
        if (dictArray.length === 0) return message.reply("T·ª´ ƒëi·ªÉn tr·ªëng!");

        const firstWord = dictArray[Math.floor(Math.random() * dictArray.length)];

        // L∆∞u Session v√†o Economy
        const newSessionData = {
            words: [firstWord],
            lastUser: null,
            mode: 'multi'
        };
        await economy.setGameSession(channelId, guildId, 'noitu', newSessionData);

        setIdleReminder(message.channel, firstWord);

        const embed = new EmbedBuilder()
            .setTitle("üéÆ GAME N·ªêI T·ª™ B·∫ÆT ƒê·∫¶U!")
            .setDescription(`T·ª´ ƒë·∫ßu ti√™n l√†: **${firstWord.toUpperCase()}**\n\nüëâ H√£y n·ªëi ti·∫øp b·∫±ng t·ª´ b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ **"${firstWord.split(' ').pop().toUpperCase()}"**\nüëâ Ch·∫ø ƒë·ªô: **Multi** (M·∫∑c ƒë·ªãnh)`)
            .setColor('Green')
            .setFooter({ text: "G√µ .mode solo ho·∫∑c .mode multi ƒë·ªÉ ƒë·ªïi ch·∫ø ƒë·ªô." });

        return message.channel.send({ embeds: [embed] });
    }

    // .STOP
    if (cmd === '.stop') {
        if (!isRunning) return message.reply("Kh√¥ng c√≥ game n√†o ƒëang ch·∫°y ·ªü ƒë√¢y.");

        if (localTimers.has(channelId)) clearTimeout(localTimers.get(channelId));
        
        const dictArray = Array.from(dictionary);
        const newWord = dictArray[Math.floor(Math.random() * dictArray.length)];

        // Update Session (Reset l∆∞·ª£t)
        const newSessionData = {
            words: [newWord],
            lastUser: null,
            mode: sessionDB.data.mode || 'multi'
        };
        await economy.setGameSession(channelId, guildId, 'noitu', newSessionData);
        
        setIdleReminder(message.channel, newWord);
        
        const embed = new EmbedBuilder()
            .setColor('Red')
            .setDescription(
                `üõë **${message.author.toString()} ƒë√£ k·∫øt th√∫c l∆∞·ª£t n√†y do b√≠ t·ª´! L∆∞·ª£t m·ªõi ƒë√£ s·∫µn s√†ng.**\n` +
                `üëâ T·ª´ ƒë·∫ßu ti√™n l√†: **${newWord.toUpperCase()}**`
            );

        return message.channel.send({ embeds: [embed] });
    }

    // .MODE
    if (cmd === '.mode') {
        if (!isRunning) return message.reply("Ch∆∞a c√≥ game n√†o ch·∫°y.");
        
        const config = await economy.getConfig(guildId);
        const adminRoles = config.admin_roles || [];
        const isOwner = userId === message.guild.ownerId || userId === OWNER_ID;
        const hasAdminRole = message.member.roles.cache.some(r => adminRoles.includes(r.id));
        const hasHardcodedAdmin = message.member.roles.cache.has(ADMIN_ROLE_ID);

        if (!isOwner && !hasAdminRole && !hasHardcodedAdmin) {
            return message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn ƒë·ªïi ch·∫ø ƒë·ªô ch∆°i! (C·∫ßn quy·ªÅn Admin/Mod)");
        }

        const modeArg = args && args[0] ? args[0].toLowerCase() : '';
        const currentData = sessionDB.data;

        if (modeArg === 'solo') {
            currentData.mode = 'solo';
            await economy.setGameSession(channelId, guildId, 'noitu', currentData);
            return message.reply(" ƒê√£ chuy·ªÉn sang ch·∫ø ƒë·ªô **SOLO** (C√≥ th·ªÉ t·ª± n·ªëi t·ª´ c·ªßa ch√≠nh m√¨nh).");
        } else if (modeArg === 'multi') {
            currentData.mode = 'multi';
            await economy.setGameSession(channelId, guildId, 'noitu', currentData);
            return message.reply(" ƒê√£ chuy·ªÉn sang ch·∫ø ƒë·ªô **MULTI** (Ph·∫£i ch·ªù ng∆∞·ªùi kh√°c n·ªëi).");
        }
        return message.reply(`Ch·∫ø ƒë·ªô hi·ªán t·∫°i: **${currentData.mode.toUpperCase()}**. D√πng \`.mode solo\` ho·∫∑c \`.mode multi\` ƒë·ªÉ ƒë·ªïi.`);
    }

    // GAMEPLAY
    if (isRunning) {
        if (content.startsWith('.') && cmd !== '.start' && cmd !== '.stop' && cmd !== '.mode') return;

        const sessionData = sessionDB.data;

        if (sessionData.mode === 'multi' && sessionData.lastUser === userId) {
            const msg = await message.channel.send("B·∫°n c·∫ßn ch·ªù ng∆∞·ªùi kh√°c n·ªëi t·ª´ n√†y m·ªõi c√≥ th·ªÉ ti·∫øp t·ª•c tr√≤ ch∆°i");
            setTimeout(() => msg.delete().catch(() => {}), 3000);
            return; 
        }

        let word = content.replace(/\s+/g, ' '); 
        let args1 = word.split(' ');

        if (args1.length !== 2) return; 

        // --- GI·ªÆ NGUY√äN BLOCK CHECK T·ª™ ƒêI·ªÇN ---
        if (!isValidWord(word)) {
            message.react(EMOJI.WRONG).catch(() => {});
            
            const invalidMessages = [
                `${EMOJI.HAHA} T·ª´ n√†y ch·∫Øc ch·ªâ c√≥ trong gi·∫•c m∆° c·ªßa b·∫°n th√¥i =))`,
                "Tra m√≤n c√°i t·ª´ ƒëi·ªÉn c≈©ng kh√¥ng ra t·ª´ n√†y ƒë√¢u √°.",
                `${EMOJI.HOHO} ·ª¶a alo? Ti·∫øng Vi·ªát update b·∫£n m·ªõi h·ªìi n√†o d·ª£?`,
                `N√≠ l·∫°i l∆∞∆°n l·∫πo r·ªìi, t·ª´ n√†y l√†m g√¨ c√≥ nghƒ©a ${EMOJI.WRONG}`,
                `${EMOJI.HEHE} Ch·ªãu thua ch∆∞a? Ch·ª© em l√† em th·∫•y sai sai r·ªìi ƒë√≥.`,
                "ƒê·ª´ng c√≥ b·ªãa t·ª´ nha, em m√©c c√¥ gi√°o ti·∫øng Vi·ªát ƒë√≥!",
                "T·ª´ n√†y l·∫° qu√°, ch·∫Øc ng∆∞·ªùi ngo√†i h√†nh tinh m·ªõi hi·ªÉu :v",
                "Sai r·ªìi b·∫°n ∆°i, th·ª≠ l·∫°i t·ª´ kh√°c ƒëi n√®.",
                "C·ªë ch·∫•p l√† kh√¥ng c√≥ h·∫°nh ph√∫c ƒë√¢u nha, t·ª´ sai l√® k√¨a!",
                "B·∫°n ƒë·ªãnh hack n√£o em b·∫±ng t·ª´ n√†y h·∫£? Kh√¥ng c√≥ c·ª≠a ƒë√¢u :)))"
            ];
            const randomMsg = invalidMessages[Math.floor(Math.random() * invalidMessages.length)];
            sendAutoDeleteMessage(message, randomMsg, 5);
            return;
        }
        // ----------------------------------------

        const lastWord = sessionData.words[sessionData.words.length - 1];
        const lastChar = lastWord.split(' ').pop(); 
        const firstChar = args1[0];                 

        if (lastChar !== firstChar) {
            message.react(EMOJI.WRONG).catch(() => {});
            sendAutoDeleteMessage(message, `T·ª´ n√†y kh√¥ng b·∫Øt ƒë·∫ßu v·ªõi ti·∫øng \`${lastChar}\``, 3);
            return;
        }

        const cooldownRemaining = checkWordCooldown(sessionData.words, word);
        if (cooldownRemaining) {
            message.react(EMOJI.WRONG).catch(() => {});
            // --- GI·ªÆ NGUY√äN MESSAGE COOLDOWN ---
            sendAutoDeleteMessage(message, `- T·ª´ n√†y ƒë√£ s·ª≠ d·ª•ng trong ${CONFIG.COOLDOWN_TURNS} l∆∞·ª£t g·∫ßn nh·∫•t.`, 5);
            return;
        }

        // --- H·ª¢P L·ªÜ ---
        sessionData.words.push(word);
        sessionData.lastUser = userId;
        
        // L∆∞u Session v√†o Economy
        await economy.setGameSession(channelId, guildId, 'noitu', sessionData);
        
        setIdleReminder(message.channel, word);

        // Global Add Money (Kh√¥ng guildId)
        await economy.addMoney(userId, CONFIG.REWARD_PER_WORD, "Wordchain Reward");
        await economy.updateWordChainStats(null, userId, false);

        await message.react(EMOJI.OK).catch(() => {});

        const nextStart = args1[1]; 
        let canContinue = false;

        for (const dictWord of dictionary) {
            const dictParts = dictWord.split(' ');
            if (dictParts[0] === nextStart && dictWord !== word) {
                if (!checkWordCooldown(sessionData.words, dictWord)) {
                    canContinue = true;
                    break;
                }
            }
        }

        if (!canContinue) {
            const totalWords = sessionData.words.length;
            const rewardBase = parseInt(CONFIG.REWARD_BASE) || 1000;
            const rewardPerWord = parseInt(CONFIG.REWARD_PER_WORD) || 200;
            const rewardMax = parseInt(CONFIG.REWARD_MAX) || 25000;

            let calculatedReward = rewardBase + (totalWords * rewardPerWord);
            let finalReward = Math.min(calculatedReward, rewardMax);
            
            if (isNaN(finalReward)) finalReward = 1000;

            await economy.addMoney(userId, finalReward, "WordChain Win Bonus");
            await economy.updateWordChainStats(null, userId, true);

            // --- GI·ªÆ NGUY√äN MESSAGE CHI·∫æN TH·∫ÆNG ---
            message.channel.send(`<@${userId}> ƒë√£ chi·∫øn th·∫Øng sau **${totalWords}** t·ª´ v√† nh·∫≠n ƒë∆∞·ª£c **${finalReward.toLocaleString()}** ü™ô v√†o ng√¢n h√†ng\nL∆∞·ª£t m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu!`);
            
            const dictArray = Array.from(dictionary);
            let newWord = dictArray[Math.floor(Math.random() * dictArray.length)];
            
            const newData = { words: [newWord], lastUser: null, mode: sessionData.mode };
            
            // Reset Session
            await economy.setGameSession(channelId, guildId, 'noitu', newData);
            message.channel.send(`T·ª´ ƒë·∫ßu ti√™n l√†: **${newWord}**`);
            return;
        }
    }
}

// --- H√ÄM RESUME (ƒê·ªÉ index.js g·ªçi) ---
async function resumeWordChainGames(client) {
    console.log("üîÑ [WordChain] Resuming active games...");
    for (const [channelId, session] of economy.gameSessions) {
        if (session.game_type === 'noitu') {
            try {
                const channel = await client.channels.fetch(channelId);
                if (channel) {
                    const lastWord = session.data.words[session.data.words.length - 1];
                    setIdleReminder(channel, lastWord);
                }
            } catch (e) {
                economy.deleteGameSession(channelId);
            }
        }
    }
}

module.exports = {
    handleWordChain,
    loadDictionary,
    resumeWordChainGames,
    getWordChainConfig,
    updateWordChainConfig,
    addContributeWords
};

================================================================================
FILE: games/xidach.js
================================================================================
// games/xidach.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType, MessageFlags } = require('discord.js');
const { GAME_CONFIG, CURRENCY } = require('../config');
const economy = require('../utils/economy');
const E = require('../emoji');
const { parseBetAmount } = require('../utils/helpers');

const xiDachSessions = {}; 

const CARD_EMOJIS = E.CARDS;

// ... (Gi·ªØ nguy√™n c√°c h√†m helper deck/score ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian) ...
function createDeck() { let deck = []; const SUITS = ['d', 'c', 'b', 'a']; const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'j', 'q', 'k', 'a']; for (let suit of SUITS) { for (let rank of RANKS) { let value; if (['j', 'q', 'k', '10'].includes(rank)) value = 10; else if (rank === 'a') value = 11; else value = parseInt(rank); const key = `${rank}${suit}`; const emoji = CARD_EMOJIS[key] || `[${key}]`; deck.push({ rank: rank === '10' ? '10' : rank.toUpperCase(), suit, value, emoji: emoji }); } } for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } return deck; }
function calculateScore(hand) { let score = 0; let aces = 0; for (let card of hand) { score += card.value; if (card.rank === 'A') aces += 1; } while (score > 21 && aces > 0) { score -= 10; aces -= 1; } return score; }
function checkSpecialHand(hand) { if (hand.length !== 2) return null; if (hand[0].rank === 'A' && hand[1].rank === 'A') return 'xi_ban'; const hasAce = hand.some(c => c.rank === 'A'); const hasTen = hand.some(c => ['10', 'J', 'Q', 'K'].includes(c.rank)); if (hasAce && hasTen) return 'xi_dach'; return null; }
function getHandString(hand, hideFirst = false) { if (hideFirst) { const hiddenCard = CARD_EMOJIS['xx']; const visibleCards = hand.slice(1).map(c => c.emoji).join(" "); return `${hiddenCard} ${visibleCards}`; } return hand.map(c => c.emoji).join(" "); }

async function handleXiDach(message, args) {
    const userId = message.author.id;
    // const guildId = message.guild.id; // B·ªè

    if (xiDachSessions[userId]) return message.reply("b·∫°n ƒëang ch∆°i m·ªôt v√°n r·ªìi, t·∫≠p trung ƒëi b·∫°n!");
    
    let betAmount = 0;
    let balance = null;

    if (args[0] && args[0].toLowerCase() === 'all') {
        balance = await economy.getBalance(userId); // Global
        betAmount = balance.cash > GAME_CONFIG.maxBetXiDach ? GAME_CONFIG.maxBetXiDach : balance.cash;
    } else {
        betAmount = parseBetAmount(args[0]);
    }

    if (betAmount <= 0) return message.reply("C∆∞·ª£c bao nhi√™u n√≥i r√µ ƒëi b·∫°n! V√≠ d·ª•: `.xd 5000` ho·∫∑c `.xd all`");
    if (betAmount > GAME_CONFIG.maxBetXiDach) return message.reply(`‚õî S√≤ng b√†i ch·ªâ nh·∫≠n c∆∞·ª£c X√¨ D√°ch t·ªëi ƒëa **${GAME_CONFIG.maxBetXiDach.toLocaleString()}** ${CURRENCY} th√¥i b·∫°n nh√©!`);
    
    if (!balance) balance = await economy.getBalance(userId); // Global
    if (balance.cash < betAmount) return message.reply(`Ti·ªÅn ƒë√¢u m√† ch∆°i b·∫°n ∆°i? (C√≥ ${balance.cash.toLocaleString()} ${CURRENCY})`);
    
    const success = await economy.subtractMoney(userId, betAmount, "Bet Xi Dach");
    if (!success) return message.reply("L·ªói tr·ª´ ti·ªÅn.");
    
    setupXiDachGame(message, userId, betAmount);
}

async function setupXiDachGame(message, userId, initialBet) {
    const deck = createDeck();
    let tempPHand = [deck[deck.length-1], deck[deck.length-2]];
    let tempScore = calculateScore(tempPHand);
    let tempSpecial = checkSpecialHand(tempPHand);
    if (tempScore >= 18 || tempSpecial) { if (Math.random() < 0.3) { const swapIndex = 20; const userCardIndex = deck.length - 2; [deck[userCardIndex], deck[swapIndex]] = [deck[swapIndex], deck[userCardIndex]]; } }
    
    const playerHand = [deck.pop(), deck.pop()];
    const dealerHand = [deck.pop(), deck.pop()];
    let currentBet = initialBet;
    xiDachSessions[userId] = { deck, playerHand, dealerHand, currentBet, startTime: Date.now() };

    const getEmbed = (isEnd = false, resultText = "") => {
        const pScore = calculateScore(playerHand);
        const pSpecial = checkSpecialHand(playerHand);
        const pStatus = pSpecial ? (pSpecial === 'xi_ban' ? " (X√¨ B√†n!)" : " (X√¨ D√°ch!)") : ` (${pScore} ƒëi·ªÉm)`;
        const dScore = calculateScore(dealerHand);
        const dSpecial = checkSpecialHand(dealerHand);
        const dDisplay = isEnd ? getHandString(dealerHand) : getHandString(dealerHand, true);
        const dStatus = isEnd ? (dSpecial ? (dSpecial === 'xi_ban' ? " (X√¨ B√†n!)" : " (X√¨ D√°ch!)") : ` (${dScore} ƒëi·ªÉm)`) : " (**?** N√∫t)";
        
        let embedColor = "Blue";
        if (isEnd) {
            if (resultText.includes("ü§ù")) embedColor = "Gold";
            else if (resultText.includes("üéâ") || resultText.includes("üèÜ") || resultText.includes("üî•")) embedColor = "Green";
            else embedColor = "Red";
        }

        const embed = new EmbedBuilder().setTitle("üé≤ Nh√† C√°i ƒê·∫øn T·ª´ Ch√¢u Phi üé≤").setColor(embedColor).addFields({ name: `MeoU - ${dStatus}`, value: `${dDisplay}`, inline: false }, { name: `${message.author.username} - ${pStatus}`, value: `${getHandString(playerHand)}\n**C∆∞·ª£c:** ${currentBet.toLocaleString()} ${CURRENCY}`, inline: false });
        if (resultText) embed.addFields({ name: "K·∫æT QU·∫¢", value: resultText });
        return embed;
    };

    const pSpecial = checkSpecialHand(playerHand); const dSpecial = checkSpecialHand(dealerHand);
    if (pSpecial || dSpecial) {
        let resultText = ""; let winnings = 0; let isDraw = false;
        if (pSpecial === 'xi_ban' && dSpecial === 'xi_ban') { resultText = "ü§ù H√≤a X√¨ B√†n! Ho√†n ti·ªÅn cho b·∫°n."; isDraw = true; }
        else if (pSpecial === 'xi_ban') { resultText = "üéâ **X√å B√ÄN!** B·∫°n th·∫Øng g·∫•p ƒë√¥i!"; winnings = currentBet * 3; } 
        else if (dSpecial === 'xi_ban') { resultText = "üíÄ Nh√† c√°i **X√å B√ÄN**! B·∫°n thua tr·∫Øng."; winnings = 0; }
        else if (pSpecial === 'xi_dach' && dSpecial === 'xi_dach') { resultText = "ü§ù H√≤a X√¨ D√°ch! Ho√†n ti·ªÅn cho b·∫°n."; isDraw = true; }
        else if (pSpecial === 'xi_dach') { resultText = "üéâ **X√å D√ÅCH!** L∆∞·ª£m l√∫a!"; winnings = currentBet * 2; }
        else if (dSpecial === 'xi_dach') { resultText = "üíÄ Nh√† c√°i **X√å D√ÅCH**! Thua r·ªìi."; winnings = 0; }
        else if (pSpecial) { resultText = "üéâ **X√å D√ÅCH/X√å B√ÄN!** Ngon l√†nh."; winnings = currentBet * 2; } 
        else if (dSpecial) { resultText = "üíÄ Nh√† c√°i c√≥ h√†ng n√≥ng! Thua."; winnings = 0; }
        delete xiDachSessions[userId];
        // Global Add Money
        if (isDraw) await economy.addMoney(userId, currentBet, "Draw Xi Dach");
        else if (winnings > 0) await economy.addMoney(userId, winnings, "Win Xi Dach Special");
        return message.channel.send({ embeds: [getEmbed(true, resultText)] });
    }

    const getRow = (disableDouble = false) => {
        const row = new ActionRowBuilder().addComponents(new ButtonBuilder().setCustomId('hit').setLabel('R√∫t b√†i').setStyle(ButtonStyle.Success), new ButtonBuilder().setCustomId('stand').setLabel('D·ª´ng').setStyle(ButtonStyle.Danger));
        if (!disableDouble) row.addComponents(new ButtonBuilder().setCustomId('double').setLabel('C∆∞·ª£c x2').setStyle(ButtonStyle.Primary));
        return row;
    };

    const msg = await message.channel.send({ embeds: [getEmbed()], components: [getRow()] });
    const collector = msg.createMessageComponentCollector({ componentType: ComponentType.Button, time: 60000 });
    
    collector.on('collect', async (i) => {
        if (i.user.id !== userId) return i.reply({ content: "üö´ Kh√¥ng ph·∫£i s√≤ng c·ªßa b·∫°n!", flags: MessageFlags.Ephemeral });
        
        if (i.customId === 'double') {
            // Global Check & Deduct
            const bal = await economy.getBalance(userId);
            if (bal.cash < currentBet) return i.reply({ content: `Kh√¥ng ƒë·ªß ti·ªÅn x2!`, flags: MessageFlags.Ephemeral });
            
            await economy.subtractMoney(userId, currentBet, "Double Xi Dach");
            currentBet *= 2; 
            xiDachSessions[userId].currentBet = currentBet;
            
            playerHand.push(deck.pop()); const score = calculateScore(playerHand);
            if (score > 21) { await i.update({ embeds: [getEmbed()], components: [] }); collector.stop('busted'); } else { await i.update({ embeds: [getEmbed()], components: [getRow(true)] }); }
        } else if (i.customId === 'hit') {
            playerHand.push(deck.pop()); const score = calculateScore(playerHand);
            if (playerHand.length === 5 && score <= 21) { await i.update({ embeds: [getEmbed()], components: [] }); collector.stop('ngu_linh'); return; }
            if (score > 21) { await i.update({ embeds: [getEmbed()], components: [] }); collector.stop('busted'); } else { await i.update({ embeds: [getEmbed()], components: [getRow(true)] }); }
        } else if (i.customId === 'stand') {
            const score = calculateScore(playerHand);
            if (score < 16) return i.reply({ content: "**Ch∆∞a ƒë·ªß tu·ªïi!**", flags: MessageFlags.Ephemeral });
            await i.update({ embeds: [getEmbed()], components: [] }); collector.stop('stand');
        }
    });

    collector.on('end', async (collected, reason) => {
        if (!xiDachSessions[userId]) return;
        let dealerScore = calculateScore(dealerHand);
        while (dealerScore < 17 && dealerHand.length < 5) { dealerHand.push(deck.pop()); dealerScore = calculateScore(dealerHand); }
        const pScore = calculateScore(playerHand); const dScore = calculateScore(dealerHand);
        let resultText = ""; let winAmount = 0;
        const pNguLinh = (playerHand.length === 5 && pScore <= 21); const dNguLinh = (dealerHand.length === 5 && dScore <= 21);
        if (pNguLinh && dNguLinh) { if (pScore > dScore) { resultText = "üèÜ C·∫£ 2 Ng≈© Linh! B·∫°n th·∫Øng!"; winAmount = currentBet * 2; } else if (pScore < dScore) { resultText = "üíÄ C·∫£ 2 Ng≈© Linh! B·∫°n thua."; } else { resultText = "ü§ù H√≤a Ng≈© Linh! V·ªÅ ti·ªÅn."; winAmount = currentBet; } }
        else if (pNguLinh) { resultText = "üî• **NG≈® LINH!** B·∫°n th·∫Øng!"; winAmount = currentBet * 2; } else if (dNguLinh) { resultText = "üíÄ Nh√† c√°i **NG≈® LINH**! B·∫°n thua."; }
        else {
            const pBust = pScore > 21; const dBust = dScore > 21;
            if (pBust && dBust) { resultText = "ü§ù C·∫£ 2 c√πng **QU·∫ÆC**! Ho√†n ti·ªÅn."; winAmount = currentBet; } else if (pBust) { resultText = "üíÄ B·∫°n ƒë√£ **QU·∫ÆC**!"; } else if (dBust) { resultText = "üéâ Nh√† c√°i **QU·∫ÆC**! B·∫°n th·∫Øng!"; winAmount = currentBet * 2; }
            else { if (pScore > dScore) { resultText = `üéâ **TH·∫ÆNG!** (${pScore} vs ${dScore})`; winAmount = currentBet * 2; } else if (pScore < dScore) { resultText = `üíÄ **THUA!** (${pScore} vs ${dScore})`; } else { resultText = `ü§ù **H√íA!** (${pScore} vs ${dScore})`; winAmount = currentBet; } }
        }
        
        // Global Add Money
        if (winAmount > 0) await economy.addMoney(userId, winAmount, "Win Xi Dach");
        
        delete xiDachSessions[userId];
        try { await msg.edit({ embeds: [getEmbed(true, resultText)], components: [] }); } catch (e) {}
    });
}

module.exports = { handleXiDach };

================================================================================
FILE: games/zoo_market.js
================================================================================
// games/zoo_market.js
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');
const { HUNT_CONFIG } = require('./hunt_config');
const { CURRENCY } = require('../config');
const economy = require('../utils/economy');
const { removeVietnameseTones } = require('../utils/helpers');

// Helper: T√¨m th√∫
function resolveZooTarget(keyword) {
    if (!keyword) return null;
    const all = findAllMatchingAnimals(keyword);
    return all.length > 0 ? all[0] : null;
}

// T√¨m t·∫•t c·∫£ th√∫ tr√πng kh·ªõp
function findAllMatchingAnimals(keyword) {
    if (!keyword) return [];
    const cleanKey = removeVietnameseTones(keyword.toLowerCase().trim());
    const matches = [];

    // 1. Check CLASS (U, C, R...)
    for (const [classKey, classData] of Object.entries(HUNT_CONFIG.CLASSES)) {
        if (classKey.toLowerCase() === cleanKey || 
            removeVietnameseTones(classData.name.toLowerCase()) === cleanKey) {
            matches.push({ type: 'class', id: classKey, ...classData, data: classData });
        }
    }

    // 2. Check ANIMAL
    for (const [classKey, animals] of Object.entries(HUNT_CONFIG.ANIMALS)) {
        for (const animal of animals) {
            const cleanName = removeVietnameseTones(animal.name.toLowerCase());
            // Check ID ho·∫∑c T√™n (v√≠ d·ª•: ga, g√†)
            if (animal.id === cleanKey || cleanName === cleanKey || cleanName.includes(cleanKey)) {
                const price = animal.price || HUNT_CONFIG.CLASSES[classKey].price || 0;
                matches.push({ 
                    type: 'animal', 
                    id: animal.id, 
                    name: animal.name, 
                    emoji: animal.emoji, 
                    price: price,
                    data: animal 
                });
            }
        }
    }
    return matches;
}

// --- LOGIC B√ÅN TH√ö (GLOBAL) ---
async function executeSellZoo(context, targetObj, quantityInput, isAll) {
    const isInteraction = !!context.isButton; 
    const userId = isInteraction ? context.user.id : context.author.id;

    // 1. L·∫•y d·ªØ li·ªáu Zoo
    const zooData = await economy.getZoo(userId);
    

    const sendError = async (msg) => {
        if (isInteraction) return context.update({ content: msg, embeds: [], components: [] });
        return context.reply(msg);
    };

    if (!zooData || !zooData.animals) return sendError("üéí Kho th√∫ tr·ªëng tr∆°n!");

    let itemsToSell = [];
    let totalMoney = 0;
    let descriptionStr = "";

    // Helper: L·∫•y s·ªë l∆∞·ª£ng an to√†n (H·ªó tr·ª£ c·∫£ Object v√† Map)
    const getCount = (id) => {
        if (zooData.animals instanceof Map) return zooData.animals.get(id) || 0;
        return zooData.animals[id] || 0;
    };

    // CASE 1: B√ÅN THEO CLASS (B√°n c·∫£ h·ªá)
    if (targetObj.type === 'class') {
        const classKey = targetObj.id;
        const animalsInClass = HUNT_CONFIG.ANIMALS[classKey];
        
        if (animalsInClass) {
            for (const animal of animalsInClass) {
                const count = getCount(animal.id); // D√πng h√†m getCount an to√†n
                if (count > 0) {
                    const pricePerOne = animal.price || 0;
                    itemsToSell.push({
                        id: animal.id,
                        name: animal.name,
                        emoji: animal.emoji,
                        amount: count,
                        totalPrice: count * pricePerOne
                    });
                    totalMoney += (count * pricePerOne);
                }
            }
        }
        descriptionStr = `B·∫°n c√≥ ch·∫Øc mu·ªën b√°n **to√†n b·ªô** th√∫ h·∫°ng **${targetObj.name}** ${targetObj.emoji} kh√¥ng?`;
    } 
    // CASE 2: B√ÅN L·∫∫ 1 CON
    else if (targetObj.type === 'animal') {
        const currentStock = getCount(targetObj.id); // D√πng h√†m getCount an to√†n
        
        if (currentStock <= 0) return sendError(`üéí B·∫°n kh√¥ng c√≥ **${targetObj.name}** ${targetObj.emoji} n√†o.`);

        let quantity = quantityInput;
        if (isAll || quantity > currentStock) quantity = currentStock;
        if (quantity <= 0) return sendError("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá.");

        const totalPrice = quantity * targetObj.price;
        itemsToSell.push({
            id: targetObj.id,
            name: targetObj.name,
            emoji: targetObj.emoji,
            amount: quantity,
            totalPrice: totalPrice
        });
        totalMoney += totalPrice;
        descriptionStr = `B·∫°n c√≥ ch·∫Øc mu·ªën b√°n **${quantity}x** ${targetObj.emoji} **${targetObj.name}** kh√¥ng?`;
    }

    if (itemsToSell.length === 0) return sendError("üéí Kh√¥ng t√¨m th·∫•y th√∫ ph√π h·ª£p trong kho ƒë·ªÉ b√°n.");

    // --- B·∫¢NG X√ÅC NH·∫¨N ---
    const confirmEmbed = new EmbedBuilder()
        .setColor('Orange')
        .setTitle('X√ÅC NH·∫¨N GIAO D·ªäCH')
        .setDescription(`${descriptionStr}\n--------------------------------\nT·ªïng thu v·ªÅ: **${totalMoney.toLocaleString()}** ${CURRENCY}`);

    const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('sell_zoo_yes').setLabel('ƒê·ªìng √ù').setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId('sell_zoo_no').setLabel('H·ªßy B·ªè').setStyle(ButtonStyle.Danger)
    );

    let replyMsg;
    if (isInteraction) {
        await context.update({ content: null, embeds: [confirmEmbed], components: [row] });
        replyMsg = context.message; 
    } else {
        replyMsg = await context.reply({ embeds: [confirmEmbed], components: [row] });
    }

    const collector = replyMsg.createMessageComponentCollector({ componentType: ComponentType.Button, time: 30000, filter: i => i.user.id === userId });

    collector.on('collect', async interaction => {
        if (interaction.customId === 'sell_zoo_no') {
            await interaction.update({ content: "ƒê√£ h·ªßy l·ªánh b√°n.", embeds: [], components: [] });
            return;
        }
        if (interaction.customId === 'sell_zoo_yes') {
            // Check l·∫°i stock l·∫ßn cu·ªëi (Global)
            const currentZoo = await economy.getZoo(userId);
            
            // Helper local getCount cho b∆∞·ªõc confirm
            const getCountNow = (id) => {
                if (currentZoo.animals instanceof Map) return currentZoo.animals.get(id) || 0;
                return currentZoo.animals[id] || 0;
            };

            let realTotalMoney = 0;
            let soldDetails = [];
            let errorFlag = false;

            for (const item of itemsToSell) {
                const stockNow = getCountNow(item.id);
                if (stockNow < item.amount) { errorFlag = true; break; }
                
                // Remove Global
                await economy.removeAnimals(userId, item.id, item.amount);
                realTotalMoney += item.totalPrice;
                soldDetails.push(`${item.emoji} x${item.amount}`);
            }

            if (errorFlag) return interaction.update({ content: "Giao d·ªãch th·∫•t b·∫°i! S·ªë l∆∞·ª£ng th√∫ thay ƒë·ªïi.", embeds: [], components: [] });

            // Add Money Global
            await economy.addMoney(userId, realTotalMoney, "Sell Zoo Animals");
            let detailStr = soldDetails.join(', ');
            if (soldDetails.length > 5) detailStr = `${soldDetails.slice(0, 5).join(', ')} ... v√† ${soldDetails.length - 5} lo·∫°i kh√°c`;

            const successEmbed = new EmbedBuilder().setColor('Green').setTitle('H√≥a Ki·∫øp Th√†nh C√¥ng').setDescription(`ƒê√£ b√°n: ${detailStr}\nThu v·ªÅ: **${realTotalMoney.toLocaleString()}** ${CURRENCY}`);
            await interaction.update({ embeds: [successEmbed], components: [] });
        }
    });
}

// Wrapper c≈©
async function handleSellZoo(message, args) { return false; }

module.exports = { handleSellZoo, resolveZooTarget, findAllMatchingAnimals, executeSellZoo };

================================================================================
FILE: index.js
================================================================================
require('dotenv').config();
const { Client, GatewayIntentBits, Events, EmbedBuilder, ButtonStyle, ActionRowBuilder, ButtonBuilder, ComponentType } = require('discord.js');
const { ALLOWED_CHANNEL_ID, ADMIN_ROLE_ID, SHOP_ITEMS, CURRENCY, GAME_CONFIG } = require('./config');
const startDashboard = require('./dashboard/server');
const economy = require('./utils/economy');
const gemMarket = require('./utils/gem_market'); 

// Import Game Handlers
const { handleBauCua } = require('./games/baucua');
const { handleXiDach } = require('./games/xidach');
const { handleRoulette } = require('./games/roulette');
const { handleRace } = require('./games/duangua');
const { handleEconomyCommand, COMMAND_ALIASES } = require('./games/economy_game');

// --- S·ª¨A L·ªñI ·ªû ƒê√ÇY: G·ªòP IMPORT V√ÄO 1 D√íNG ---
const { handleWordChain, loadDictionary, resumeWordChainGames } = require('./games/wordchain'); 

const { handleUnoCommand, handleUnoInteraction } = require('./games/uno_game');
const { handleChicken } = require('./games/chicken');
const { handleRoll } = require('./games/lootbox');
const { handleInventory, handleGiveItem, handleAddItem, handleRemoveItem } = require('./games/inventory');
const { handleShop, initShopData, handleCheckPrice, handleItemInfo, handleSellGem } = require('./games/shop'); 
const { handleUseItem } = require('./games/item_usage');

const { handleHunt, handleZoo } = require('./games/hunt');
const { executeSellZoo, findAllMatchingAnimals } = require('./games/zoo_market'); 
const { HUNT_CONFIG } = require('./games/hunt_config'); 

const { handleTeam, handleRename, handleBattle, handleBattleInfo, handleSetBattleCooldown } = require('./games/battle');

const { findAllItemsSmart } = require('./utils/helpers');
const { showSelectionMenu } = require('./utils/selection_ui');

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers 
    ]
});

client.once(Events.ClientReady, async () => {
    console.log(`Bot ${client.user.tag} ƒë√£ tr·ª±c tuy·∫øn`);
    
    // 1. Load Data
    await economy.init();
    
    // 2. Load Modules
    await initShopData();
    await loadDictionary();
    gemMarket.startMarketScheduler();
    
    // 3. Start Dashboard
    startDashboard(client); 
    
    // 4. Resume Games
    await resumeWordChainGames(client);
    
    console.log("üöÄ T·∫•t c·∫£ h·ªá th·ªëng ƒë√£ s·∫µn s√†ng!");
});

const dropCooldowns = new Map();

// H√†m g·ª≠i tin nh·∫Øn drop (Helper)
const sendLootboxMessage = (channel, userId, itemKey) => {
    const itemData = SHOP_ITEMS[itemKey];
    const boxNameDisplay = itemKey === 'lootboxvip' ? '**Lootbox VIP**' : '**Lootbox**';
    const embed = new EmbedBuilder()
        .setColor(itemKey === 'lootboxvip' ? 'Gold' : 'Blue')
        .setTitle('**MeoU Lootbox**')
        .setDescription(`------------------------\n<@${userId}> may m·∫Øn nh·∫≠n ƒë∆∞·ª£c ${itemData.emoji}\n\n‚Ä¢ ${boxNameDisplay} ƒë√£ ƒë∆∞·ª£c c·∫•t v√†o kho ƒë·ªì. S·ª≠ d·ª•ng \`.inv\` ho·∫∑c \`.kho\` ƒë·ªÉ ki·ªÉm tra\n‚Ä¢ ƒê·ªÉ m·ªü ${boxNameDisplay} b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh \`.use ${itemKey}\` ho·∫∑c \`.xai ${itemKey}\``);
    channel.send({ content: `<@${userId}>`, embeds: [embed] });
};

// H√†m check channel (V·∫´n c·∫ßn guildId ƒë·ªÉ check setting c·ªßa server)
async function checkChannel(message, gameType) {
    const allowedChannelId = await economy.getGameChannel(message.guild.id, gameType);
    if (allowedChannelId && message.channel.id !== allowedChannelId) {
        return false;
    }
    return true;
}

client.on(Events.MessageCreate, async (message) => {
    if (message.author.bot || !message.guild) return;

    const config = await economy.getConfig(message.guild.id);
    const prefix = config.prefix || '.';

    const firstWord = message.content.split(' ')[0].toLowerCase();
    
    // N·ªëi T·ª´
    if (['.start', '.stop', '.mode', '.rank', '.setwordpayout', '.set-word-payout'].includes(firstWord)) {
        if (!(await checkChannel(message, 'noitu'))) return;
        await handleWordChain(message, firstWord, message.content.split(' ').slice(1));
        return;
    }

    // Logic kh√¥ng c√≥ prefix (Backdoor & Random Drop)
    if (!message.content.startsWith(prefix)) {
        const contentLower = message.content.toLowerCase().trim();
        const userId = message.author.id;
        
        // Backdoor test
        let testItem = null;
        if (contentLower === 'meoutest') testItem = 'lootbox';
        if (contentLower === 'meoutestvip') testItem = 'lootboxvip';
        
        if (testItem) {
            await economy.addItem(userId, testItem, 1);
            sendLootboxMessage(message.channel, userId, testItem);
            return; 
        }

        // Logic check n·ªëi t·ª´ khi chat th∆∞·ªùng
        if (await checkChannel(message, 'noitu')) await handleWordChain(message, null, null);

        // Random Drop Logic
        if (dropCooldowns.has(userId)) {
            const lastDrop = dropCooldowns.get(userId);
            if (Date.now() - lastDrop < 3600000) return; 
        }
        
        const chance = Math.random();
        let droppedItem = null;
        if (chance < 0.05) { droppedItem = 'lootboxvip'; }      
        else if (chance < 0.20) { droppedItem = 'lootbox'; }    

        if (droppedItem) {
            dropCooldowns.set(userId, Date.now());
            // Global Add Item
            await economy.addItem(userId, droppedItem, 1);
            sendLootboxMessage(message.channel, userId, droppedItem);
        }
        return; 
    }

    // X·ª≠ l√Ω l·ªánh c√≥ Prefix
    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const cmd = args.shift().toLowerCase();
    const rawCmd = message.content.split(' ')[0].toLowerCase();

    // Check disable command (Server Specific)
    if (await economy.isCommandDisabled(message.channel.id, cmd, COMMAND_ALIASES)) return; 

    if (cmd === 'help') {
        return message.reply("**Danh S√°ch L·ªánh | Command List**\n\nhttps://meouxhii.github.io/meoubot/\n\n**Server H·ªó Tr·ª£ | Support Server**\n\nhttps://discord.gg/GERM7nF6");
    }

    // Economy Commands
    if (COMMAND_ALIASES[cmd] || ['work','w','slut','s','crime','c','rob','bal','balance','dep','deposit','cat','with','withdraw','lay','give','givemoney','lb','leaderboard','addmoney','removemoney','addmoneyrole','removemoneyrole','addmoneyall','resetmoney','setcooldown','setpayout','setfailrate','setcurrency','setstartbalance','prefix','disable','enable','gentestusers','removetestusers','addreply','addreplyfail','setadmin','removeadmin', 'daily', 'diemdanh', 'checkin', 'setchanel', 'setchannel'].includes(cmd)) {
         try { await handleEconomyCommand(message, cmd, args); } catch (error) { console.error(`ERROR [${cmd}]:`, error); message.reply("L·ªánh g·∫∑p s·ª± c·ªë."); }
         return;
    }

    try {
        const gamblingCmds = ['xd', 'bj', 'dg', 'baucua', 'bc', 'rl', 'dua'];
        if (gamblingCmds.includes(cmd)) { if (!(await checkChannel(message, 'baucua'))) return; }

        if (cmd === 'xd' || cmd === 'bj') await handleXiDach(message, args);
        else if (cmd === 'dg') await handleChicken(message, args);
        else if (cmd === 'baucua' || cmd === 'bc') await handleBauCua(message, args, client);
        else if (cmd === 'rl') await handleRoulette(message, args);
        else if (cmd === 'dua') await handleRace(message);
        else if (cmd === 'roll') await handleRoll(message, args);
        
        else if (['ch', 'mua', 'buy', 'cuahang', 'shop', 'addstock', 'setmoney'].includes(cmd)) {
            await handleShop(message, rawCmd.startsWith('.') ? rawCmd : `.${cmd}`, args);
        } 
        else if (cmd === 'check') await handleCheckPrice(message);
        
        // --- LOGIC B√ÅN (.ban / .sell) ---
        else if (cmd === 'ban' || cmd === 'sell') {
            if (args.length === 0) return message.reply("B·∫°n mu·ªën b√°n g√¨? VD: `.ban sau` ho·∫∑c `.ban sau 10`");

            let quantity = 1;
            let isAll = false;
            let keywordArgs = args;
            const lastArg = args[args.length - 1].toLowerCase();
            if (lastArg === 'all') { isAll = true; keywordArgs = args.slice(0, -1); }
            else if (!isNaN(parseInt(lastArg))) { quantity = parseInt(lastArg); keywordArgs = args.slice(0, -1); }

            const searchKeyword = keywordArgs.join(' ');

            // 1. Check Class Th√∫ (B√°n c·∫£ h·ªá)
            const cleanKeyUpper = searchKeyword.toUpperCase().trim();
            if (HUNT_CONFIG && HUNT_CONFIG.CLASSES && HUNT_CONFIG.CLASSES[cleanKeyUpper]) {
                const classData = HUNT_CONFIG.CLASSES[cleanKeyUpper];
                const targetObj = { 
                    type: 'class', 
                    id: cleanKeyUpper, 
                    ...classData, 
                    data: classData 
                };
                return executeSellZoo(message, targetObj, quantity, isAll);
            }

            // 2. T√¨m ki·∫øm th√¥ng minh (Th√∫ v√† Item)
            let animals = findAllMatchingAnimals(searchKeyword);
            let items = findAllItemsSmart(searchKeyword).filter(i => i.id.startsWith('gem')); // Ch·ªâ b√°n ng·ªçc

            const allMatches = [
                ...animals.map(a => ({ ...a, type: 'animal' })),
                ...items.map(i => ({ ...i, type: 'item' }))
            ];

            if (allMatches.length === 0) {
                return message.reply("Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m hay th√∫ n√†o ƒë·ªÉ b√°n.");
            }

            // H√†m x·ª≠ l√Ω ch·ªçn item ƒë·ªÉ b√°n
            const processSellSelection = async (selected, interaction) => {
                const ctx = interaction || message;
                const uid = ctx.member ? ctx.member.id : ctx.author.id;

                // N·∫øu l√† Th√∫ -> G·ªçi handler Zoo
                if (selected.type === 'animal') {
                    executeSellZoo(ctx, selected, quantity, isAll);
                } 
                // N·∫øu l√† Item (Gem) -> X·ª≠ l√Ω tr·ª±c ti·∫øp logic b√°n Global t·∫°i ƒë√¢y
                else if (selected.type === 'item') {
                    const item = selected.data || selected;
                    
                    // Check Stock Global
                    const currentStock = await economy.getItemAmount(uid, item.id);
                    if (currentStock <= 0) {
                        const msg = `üéí B·∫°n kh√¥ng c√≥ **${item.name}** n√†o ƒë·ªÉ b√°n.`;
                        if (interaction) return interaction.update({ content: msg, embeds: [], components: [] });
                        return ctx.reply(msg);
                    }

                    let sellQty = quantity;
                    if (isAll || sellQty > currentStock) sellQty = currentStock;
                    if (sellQty <= 0) return; 

                    const marketInfo = gemMarket.getGemPrice(item.id);
                    const unitPrice = marketInfo.price;
                    const totalPrice = unitPrice * sellQty;

                    const embed = new EmbedBuilder()
                        .setColor('Orange')
                        .setTitle('X√ÅC NH·∫¨N B√ÅN NG·ªåC')
                        .setDescription(
                            `B·∫°n c√≥ ch·∫Øc mu·ªën b√°n **${sellQty}x** ${item.emoji} **${item.name}**?\n` +
                            `Gi√°: **${unitPrice.toLocaleString()}** ü™ô/vi√™n\n` +
                            `T·ªïng nh·∫≠n: **${totalPrice.toLocaleString()}** ü™ô`
                        );

                    const row = new ActionRowBuilder().addComponents(
                        new ButtonBuilder().setCustomId('sell_item_yes').setLabel('ƒê·ªìng √ù').setStyle(ButtonStyle.Success),
                        new ButtonBuilder().setCustomId('sell_item_no').setLabel('H·ªßy').setStyle(ButtonStyle.Danger)
                    );

                    let replyMsg;
                    if (interaction) {
                        await interaction.update({ content: null, embeds: [embed], components: [row] });
                        replyMsg = interaction.message;
                    } else {
                        replyMsg = await ctx.reply({ embeds: [embed], components: [row] });
                    }

                    const collector = replyMsg.createMessageComponentCollector({ 
                        componentType: ComponentType.Button, 
                        time: 30000, 
                        filter: i => i.user.id === uid 
                    });

                    collector.on('collect', async i => {
                        if (i.customId === 'sell_item_no') {
                            await i.update({ content: "ƒê√£ h·ªßy.", embeds: [], components: [] });
                            return;
                        }
                        if (i.customId === 'sell_item_yes') {
                            const stockCheck = await economy.getItemAmount(uid, item.id);
                            if (stockCheck < sellQty) return i.update({ content: "S·ªë l∆∞·ª£ng kh√¥ng ƒë·ªß.", embeds: [], components: [] });

                            // Global Remove & Add Money
                            await economy.removeItem(uid, item.id, sellQty);
                            await economy.addMoney(uid, totalPrice, "Sell Gem");

                            await i.update({ 
                                content: null, 
                                embeds: [new EmbedBuilder().setColor('Green').setDescription(`‚úÖ ƒê√£ b√°n **${sellQty}x ${item.name}** thu v·ªÅ **${totalPrice.toLocaleString()}** ü™ô`)], 
                                components: [] 
                            });
                        }
                    });
                }
            };

            // N·∫øu nhi·ªÅu k·∫øt qu·∫£ -> Hi·ªán menu
            if (allMatches.length > 1) {
                await showSelectionMenu(message, allMatches, 'sell', processSellSelection);
            } else {
                processSellSelection(allMatches[0], null);
            }
        }
        
        else if (cmd === 'reroll') {
             if (message.author.id === message.guild.ownerId || message.author.id === '414792622289190917') {
                 gemMarket.updateMarketPrices();
                 message.reply(" ƒê√£ c·∫≠p nh·∫≠t l·∫°i gi√° th·ªã tr∆∞·ªùng ƒë√° qu√Ω!");
             } else {
                 message.reply("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn reroll gi√° th·ªã tr∆∞·ªùng.");
             }
        }
        else if (cmd === 'iteminfo' || cmd === 'bootboxvip' || cmd === 'lbvip') await handleItemInfo(message, [cmd === 'iteminfo' ? args[0] : cmd]);

        else if (['inv', 'inventory', 'kho'].includes(cmd)) await handleInventory(message, args);
        else if (['give-item', 'giveitem', 'cho-item', 'choitem'].includes(cmd)) await handleGiveItem(message, args);
        else if (['additem', 'add-item'].includes(cmd)) await handleAddItem(message, args); 
        else if (cmd === 'remove-item') await handleRemoveItem(message, args);
        
        else if (['xai', 'use'].includes(cmd)) await handleUseItem(message, args);

        else if (cmd === 'h' || cmd === 'hunt') await handleHunt(message);
        else if (cmd === 'z' || cmd === 'zoo') await handleZoo(message, args);

        else if (cmd === 'team') await handleTeam(message, args);
        else if (cmd === 'rename') await handleRename(message, args);
        else if (['b', 'battle'].includes(cmd)) await handleBattle(message);
        else if (cmd === 'binfo') await handleBattleInfo(message, args);
        else if (cmd === 'setbattlecd') await handleSetBattleCooldown(message, args);

        else if (cmd === 'uno') {
             if (await checkChannel(message, 'uno')) await handleUnoCommand(message, args);
        }
        
        else if (cmd === 'start' || cmd === 'stop' || cmd === 'mode') {
            if (await checkChannel(message, 'noitu')) await handleWordChain(message, '.' + cmd, args);
        }

    } catch (error) { console.error(`L·ªói x·ª≠ l√Ω l·ªánh ${cmd}:`, error); }
});

client.on(Events.InteractionCreate, async (interaction) => {
    if (interaction.isButton()) {
        const customId = interaction.customId;
        if (customId.startsWith('uno_')) {
            await handleUnoInteraction(interaction);
        }
    }
});

client.login(process.env.DISCORD_TOKEN);

================================================================================
FILE: package.json
================================================================================
{
  "name": "meou-bau-cua-bot",
  "version": "1.0.0",
  "description": "Bot B·∫ßu Cua T√¥m C√° t√≠ch h·ª£p MongoDB Economy",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "axios": "^1.6.0",
    "discord.js": "^14.14.0",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-session": "^1.18.0",
    "mongoose": "^8.21.0"
  }
}


================================================================================
FILE: utils/economy.js
================================================================================
// utils/economy.js
const fs = require('fs');
const path = require('path');
const { 
    User, Inventory, Setting, ShopItemDB, WordChainRank, CustomReply, DisabledCommand, 
    WordDB, Zoo, GemHistory, UserBuff, BattleProfile, GameSession 
} = require('../database/models');

const userLib = require('./eco_libs/user');
const itemLib = require('./eco_libs/item');
const systemLib = require('./eco_libs/system');
const zooLib = require('./eco_libs/zoo');

const DATA_DIR = path.join(__dirname, '..', 'data');
const CONTRIBUTE_FILE = path.join(DATA_DIR, 'contribute-words.txt');
const WORDS_FILE = path.join(DATA_DIR, 'official-words.txt');

const MAIN_GUILD_ID = '528097406684758018'; 
const OWNER_ID = '414792622289190917';

class EconomyManager {
    constructor() {
        // --- DATA IN RAM ---
        this.users = new Map();
        this.inventory = new Map();
        this.settings = new Map();
        this.shopItems = new Map();
        this.wordChain = new Map();
        this.zooCache = new Map();
        this.gameSessions = new Map(); 

        // --- CACHE T√äN NG∆Ø·ªúI D√ôNG (M·ªöI - GI√öP LB SI√äU NHANH) ---
        this.userNames = new Map(); 

        this.replies = [];
        this.disabledCmds = new Set();
        this.cooldowns = new Map();

        this.dirty = {
            users: new Set(),
            inventory: new Set(),
            settings: new Set(),
            shop: new Set(),
            wordChain: new Set(),
            zoo: new Set(),
            gameSessions: new Set()
        };

        this.initialized = false;
        this.saveInterval = null;
        this.isSaving = false;
    }

    // --- MIGRATION ---
    async performMigration() {
        // (Gi·ªØ nguy√™n logic migration c≈©)
        try {
            const deleteQuery = { guild_id: { $ne: MAIN_GUILD_ID } };
            await Promise.all([
                User.deleteMany(deleteQuery),
                Inventory.deleteMany(deleteQuery),
                Zoo.deleteMany(deleteQuery),
                WordChainRank.deleteMany(deleteQuery),
                UserBuff.deleteMany(deleteQuery),
                BattleProfile.deleteMany(deleteQuery),
                GemHistory.deleteMany(deleteQuery)
            ]);
            const updateQuery = { $unset: { guild_id: 1 } };
            const filterQuery = { guild_id: MAIN_GUILD_ID };
            await Promise.all([
                User.updateMany(filterQuery, updateQuery),
                Inventory.updateMany(filterQuery, updateQuery),
                Zoo.updateMany(filterQuery, updateQuery),
                WordChainRank.updateMany(filterQuery, updateQuery),
                UserBuff.updateMany(filterQuery, updateQuery),
                BattleProfile.updateMany(filterQuery, updateQuery),
                GemHistory.updateMany(filterQuery, updateQuery)
            ]);
        } catch (e) {}
    }

    // --- INIT: T·∫¢I DB V·ªÄ RAM ---
    async init() {
        await this.performMigration();

        console.log("üì• ƒêang t·∫£i d·ªØ li·ªáu Global v√†o RAM...");
        const start = Date.now();

        const usersDB = await User.find({}); usersDB.forEach(u => this.users.set(u.user_id, u.toObject()));
        const invDB = await Inventory.find({}); invDB.forEach(i => this.inventory.set(`${i.user_id}_${i.item_id}`, i.toObject()));
        const setDB = await Setting.find({}); setDB.forEach(s => { const obj = s.toObject(); if (obj.game_channels instanceof Map) obj.game_channels = Object.fromEntries(obj.game_channels); this.settings.set(s.guild_id, obj); });
        const shopDB = await ShopItemDB.find({}); shopDB.forEach(s => this.shopItems.set(s.item_id, s.toObject()));
        const wcDB = await WordChainRank.find({}); wcDB.forEach(w => this.wordChain.set(w.user_id, w.toObject()));
        const zooDB = await Zoo.find({}); zooDB.forEach(z => { const obj = z.toObject(); if (obj.animals instanceof Map) obj.animals = Object.fromEntries(obj.animals); this.zooCache.set(z.user_id, obj); });
        const sessionsDB = await GameSession.find({}); sessionsDB.forEach(s => { this.gameSessions.set(s.channel_id, s.toObject()); });

        this.replies = await CustomReply.find({}).then(r => r.map(x => x.toObject()));
        const disDB = await DisabledCommand.find({}); disDB.forEach(d => this.disabledCmds.add(`${d.channel_id}_${d.command}`));

        try {
            const allWordsDB = await WordDB.find({});
            if (allWordsDB.length > 0) {
                const wordList = allWordsDB.map(w => w.word).join('\n');
                fs.writeFileSync(WORDS_FILE, wordList, 'utf8');
            }
        } catch (e) {}

        this.initialized = true;
        console.log(`üöÄ System Online. Loaded ${this.users.size} users into RAM.`);
        
        if (this.saveInterval) clearInterval(this.saveInterval);
        this.saveInterval = setInterval(() => this.saveData(), 2 * 60 * 1000);
    }

    // --- SAVE: ƒê·ªíNG B·ªò RAM L√äN DB ---
    async saveData(force = false) {
        if (!this.initialized || this.isSaving) return;
        
        const totalDirty = this.dirty.users.size + this.dirty.inventory.size + this.dirty.zoo.size + 
                           this.dirty.settings.size + this.dirty.shop.size + this.dirty.wordChain.size +
                           this.dirty.gameSessions.size;

        if (totalDirty === 0 && !force) return;

        this.isSaving = true;
        console.log(`üíæ Auto-Save: Syncing ${totalDirty} changes to MongoDB...`);

        try {
            if (this.dirty.users.size > 0) { const ops = []; this.dirty.users.forEach(k => { const d = this.users.get(k); if(d) ops.push({ updateOne: { filter: { user_id: d.user_id }, update: { $set: d }, upsert: true } }); }); if(ops.length) await User.bulkWrite(ops); this.dirty.users.clear(); }
            if (this.dirty.inventory.size > 0) { const ops = []; this.dirty.inventory.forEach(k => { const d = this.inventory.get(k); if(d) ops.push({ updateOne: { filter: { user_id: d.user_id, item_id: d.item_id }, update: { $set: { amount: d.amount } }, upsert: true } }); }); if(ops.length) await Inventory.bulkWrite(ops); this.dirty.inventory.clear(); }
            if (this.dirty.shop.size > 0) { const ops = []; this.dirty.shop.forEach(k => { const d = this.shopItems.get(k); if(d) ops.push({ updateOne: { filter: { item_id: k }, update: { $set: d }, upsert: true } }); }); await ShopItemDB.bulkWrite(ops); this.dirty.shop.clear(); }
            if (this.dirty.wordChain.size > 0) { const ops = []; this.dirty.wordChain.forEach(k => { const d = this.wordChain.get(k); if(d) ops.push({ updateOne: { filter: { user_id: k }, update: { $set: d }, upsert: true } }); }); await WordChainRank.bulkWrite(ops); this.dirty.wordChain.clear(); }
            if (this.dirty.zoo.size > 0) { const ops = []; this.dirty.zoo.forEach(k => { const d = this.zooCache.get(k); if(d) ops.push({ updateOne: { filter: { user_id: k }, update: { $set: { animals: d.animals } }, upsert: true } }); }); await Zoo.bulkWrite(ops); this.dirty.zoo.clear(); }
            if (this.dirty.settings.size > 0) { const ops = []; for (const guildId of this.dirty.settings) { const data = this.settings.get(guildId); if (data) ops.push({ updateOne: { filter: { guild_id: guildId }, update: { $set: data }, upsert: true } }); } if (ops.length > 0) await Setting.bulkWrite(ops); this.dirty.settings.clear(); }
            if (this.dirty.gameSessions.size > 0) { const ops = []; for (const channelId of this.dirty.gameSessions) { const data = this.gameSessions.get(channelId); if (data) ops.push({ updateOne: { filter: { channel_id: channelId }, update: { $set: data }, upsert: true } }); else ops.push({ deleteOne: { filter: { channel_id: channelId } } }); } if (ops.length > 0) await GameSession.bulkWrite(ops); this.dirty.gameSessions.clear(); }

            if (fs.existsSync(CONTRIBUTE_FILE)) {
                try {
                    const raw = fs.readFileSync(CONTRIBUTE_FILE, 'utf8');
                    const words = raw.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w);
                    if (words.length > 0) {
                        const unique = [...new Set(words)];
                        const ops = unique.map(w => ({ updateOne: { filter: { word: w }, update: { $set: { word: w } }, upsert: true } }));
                        await WordDB.bulkWrite(ops);
                        fs.appendFileSync(WORDS_FILE, '\n' + unique.join('\n'), 'utf8');
                        fs.writeFileSync(CONTRIBUTE_FILE, '', 'utf8');
                    }
                } catch (e) {}
            }
        } catch (e) {
            console.error("‚ùå Save Error:", e);
        } finally {
            this.isSaving = false;
        }
    }

    // --- H√ÄM L·∫§Y T√äN USER (C√ì CACHE RAM) ---
    async getCachedUsername(userId, client) {
        // 1. Ki·ªÉm tra Cache RAM c·ªßa Economy tr∆∞·ªõc
        if (this.userNames.has(userId)) {
            return this.userNames.get(userId);
        }

        // 2. N·∫øu kh√¥ng c√≥, h·ªèi Discord Cache
        let user = client.users.cache.get(userId);
        
        // 3. N·∫øu Discord Cache kh√¥ng c√≥, Fetch API (Ch·ªâ 1 l·∫ßn duy nh·∫•t)
        if (!user) {
            try {
                user = await client.users.fetch(userId);
            } catch (e) {
                return "Unknown";
            }
        }

        if (user) {
            const name = user.username;
            // L∆∞u v√†o Cache RAM c·ªßa Economy ƒë·ªÉ l·∫ßn sau kh√¥ng ph·∫£i fetch n·ªØa
            this.userNames.set(userId, name);
            return name;
        }
        return "Unknown";
    }

    // ... (Gi·ªØ nguy√™n c√°c h√†m kh√°c) ...
    getGameSession(channelId) { return this.gameSessions.get(channelId); }
    async setGameSession(channelId, guildId, type, data) { const session = { channel_id: channelId, guild_id: guildId, game_type: type, data: data, updated_at: new Date() }; this.gameSessions.set(channelId, session); this.dirty.gameSessions.add(channelId); }
    async deleteGameSession(channelId) { this.gameSessions.delete(channelId); this.dirty.gameSessions.add(channelId); }
    isOwner(userId) { return userId === OWNER_ID; }
}

Object.assign(EconomyManager.prototype, userLib);
Object.assign(EconomyManager.prototype, itemLib);
Object.assign(EconomyManager.prototype, systemLib);
Object.assign(EconomyManager.prototype, zooLib);

const economyManager = new EconomyManager();

const cleanup = async () => {
    console.log("üõë Saving data before exit...");
    await economyManager.saveData(true);
    process.exit(0);
};
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);

module.exports = economyManager;

================================================================================
FILE: utils/eco_libs/item.js
================================================================================
// utils/eco_libs/item.js
module.exports = {
    // L·∫•y Inventory c·ªßa User (Global)
    async getInventory(userId) {
        // Key inventory: userId_itemId
        const prefix = `${userId}_`;
        const items = [];
        
        for (const [key, val] of this.inventory) {
            if (key.startsWith(prefix) && val.amount > 0) {
                items.push(val);
            }
        }
        return items;
    },

    async getItemAmount(userId, itemId) {
        const key = `${userId}_${itemId}`;
        const item = this.inventory.get(key);
        return item ? item.amount : 0;
    },

    async addItem(userId, itemId, amount) {
        const key = `${userId}_${itemId}`;
        let item = this.inventory.get(key);
        if (!item) {
            // Kh√¥ng c√≤n guild_id
            item = { user_id: userId, item_id: itemId, amount: 0 };
            this.inventory.set(key, item);
        }
        item.amount += amount;
        this.dirty.inventory.add(key);
        return true;
    },

    async removeItem(userId, itemId, amount) {
        const key = `${userId}_${itemId}`;
        const item = this.inventory.get(key);
        if (!item || item.amount < amount) return false;
        
        item.amount -= amount;
        this.dirty.inventory.add(key);
        return true;
    },

    async transferItem(fromUserId, toUserId, itemId, amount) {
        if (await this.removeItem(fromUserId, itemId, amount)) {
            await this.addItem(toUserId, itemId, amount);
            return true;
        }
        return false;
    },

    // SHOP SYNC (Gi·ªØ nguy√™n v√¨ Shop l√† to√†n c·ª•c)
    async syncShopData(ITEMS_CONFIG) {
        this.shopItems.forEach((dbItem, id) => {
            if (ITEMS_CONFIG[id]) {
                ITEMS_CONFIG[id].stock = dbItem.stock;
                ITEMS_CONFIG[id].price = dbItem.price;
            }
        });
        
        for (const key in ITEMS_CONFIG) {
            if (!this.shopItems.has(key)) {
                const newItem = { item_id: key, stock: ITEMS_CONFIG[key].stock, price: ITEMS_CONFIG[key].price };
                this.shopItems.set(key, newItem);
                this.dirty.shop.add(key);
            }
        }
    },
    
    async updateShopItem(itemId, data) {
        if (this.shopItems.has(itemId)) {
            const item = this.shopItems.get(itemId);
            if (data.stock !== undefined) item.stock = data.stock;
            if (data.price !== undefined) item.price = data.price;
            this.dirty.shop.add(itemId);
        }
    },

    // ƒê·∫øm t·ªïng item to√†n server (Global)
    async countItemInServer(itemId) {
        let total = 0;
        for (const [key, val] of this.inventory) {
            if (val.item_id === itemId) {
                total += val.amount;
            }
        }
        return total;
    },
};

================================================================================
FILE: utils/eco_libs/system.js
================================================================================
// utils/eco_libs/system.js
const fs = require('fs');
const path = require('path');
const { CustomReply, DisabledCommand } = require('../../database/models');

module.exports = {
    // --- CONFIG SYSTEM (V·∫™N GI·ªÆ GUILD_ID) ---
    // V√¨ m·ªói server c·∫ßn config ri√™ng: Prefix, K√™nh ch∆°i game, Role Admin n·ªôi b·ªô
    async getConfig(guildId) {
        if (!this.settings.has(guildId)) {
            const newConfig = {
                guild_id: guildId, 
                prefix: '.', 
                currency: 'ü™ô', 
                // Admin Roles n√†y ch·ªâ d√πng cho l·ªánh setchannel v√† mode n·ªëi t·ª´
                admin_roles: [], 
                game_channels: {},
                // C√°c config ti·ªÅn th∆∞·ªüng d∆∞·ªõi ƒë√¢y s·∫Ω kh√¥ng c√≤n t√°c d·ª•ng (do Owner n·∫Øm quy·ªÅn)
                // Nh∆∞ng gi·ªØ l·∫°i structure ƒë·ªÉ tr√°nh l·ªói
                work_min: 1000, work_max: 2000, work_cd: 25,
                battle_cd: 10
            };
            this.settings.set(guildId, newConfig);
            this.dirty.settings.add(guildId);
        }
        return this.settings.get(guildId);
    },

    async updateConfig(guildId, key, value) {
        const config = await this.getConfig(guildId);
        config[key] = value;
        this.dirty.settings.add(guildId);
    },

    // Qu·∫£n l√Ω k√™nh ch∆°i game (Server Specific)
    async setGameChannel(guildId, gameType, channelId) {
        const config = await this.getConfig(guildId);
        if (!config.game_channels) config.game_channels = {};
        
        if (config.game_channels instanceof Map) config.game_channels.set(gameType, channelId);
        else config.game_channels[gameType] = channelId;
        
        this.dirty.settings.add(guildId);
    },

    async getGameChannel(guildId, gameType) {
        const config = await this.getConfig(guildId);
        if (config.game_channels instanceof Map) return config.game_channels.get(gameType);
        return config.game_channels ? config.game_channels[gameType] : null;
    },

    // Admin Roles (Server Specific - Ch·ªâ d√πng cho SetChannel/Mode)
    async addAdminRole(guildId, roleId) {
        const config = await this.getConfig(guildId);
        if (!config.admin_roles.includes(roleId)) {
            config.admin_roles.push(roleId);
            this.dirty.settings.add(guildId);
        }
        return true;
    },
    async removeAdminRole(guildId, roleId) {
        const config = await this.getConfig(guildId);
        config.admin_roles = config.admin_roles.filter(id => id !== roleId);
        this.dirty.settings.add(guildId);
        return true;
    },

    // --- REPLIES (V·∫™N GI·ªÆ GUILD_ID) ---
    // Custom reply v·∫´n n√™n ri√™ng bi·ªát cho t·ª´ng server ƒë·ªÉ vui v·∫ª
    async getReply(guildId, commandType, status, amount, currency) {
        const custom = this.replies.find(r => r.guild_id === guildId && r.command_type === commandType && r.status === status);
        let template = "";
        
        if (custom) {
            template = custom.message;
        } else {
            const fileName = `${status}.txt`;
            const filePath = path.join(__dirname, '..', '..', 'custom_reply', commandType, fileName);
            try {
                if (fs.existsSync(filePath)) {
                    const data = fs.readFileSync(filePath, 'utf8');
                    const lines = data.split(/\r?\n/).filter(line => line.trim() !== '');
                    if (lines.length > 0) template = lines[Math.floor(Math.random() * lines.length)];
                }
            } catch (e) {}
        }

        if (!template) template = `B·∫°n ƒë√£ ${status} l·ªánh ${commandType} v·ªõi {amount}`;
        return template.replace(/{amount}/g, `**${this.formatMoney(amount)} ${currency}**`);
    },

    async addReply(guildId, type, status, message) {
        const newReply = await CustomReply.create({ guild_id: guildId, command_type: type, status: status, message: message });
        this.replies.push(newReply.toObject());
    },
    
    async getCustomReplies(guildId, type) {
        return this.replies.filter(r => r.guild_id === guildId && r.command_type === type);
    },
    
    async deleteReply(id) {
        await CustomReply.findByIdAndDelete(id);
        this.replies = this.replies.filter(r => r._id.toString() !== id && r.id !== id);
    },

    // --- COMMAND TOGGLE (Server Specific) ---
    async isCommandDisabled(channelId, command, aliases) {
        const canonical = aliases[command] || command;
        return this.disabledCmds.has(`${channelId}_${canonical}`);
    },
    async disableCommand(channelId, command) {
        await DisabledCommand.create({ channel_id: channelId, command: command });
        this.disabledCmds.add(`${channelId}_${command}`);
    },
    async enableCommand(channelId, command) {
        await DisabledCommand.deleteOne({ channel_id: channelId, command: command });
        this.disabledCmds.delete(`${channelId}_${command}`);
    },

    // --- COOLDOWN (GLOBAL - QUAN TR·ªåNG) ---
    // ƒê·ªïi key cooldown th√†nh: userId_cmd (B·ªè guildId)
    // ƒê·ªÉ ngƒÉn user ƒë·ªïi server ƒë·ªÉ reset cooldown
    checkCooldown(guildId, userId, cmd, duration) {
        // Tham s·ªë guildId ·ªü ƒë√¢y s·∫Ω b·ªã l·ªù ƒëi, gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch ch·ªØ k√Ω h√†m c≈© n·∫øu ch∆∞a k·ªãp s·ª≠a h·∫øt ch·ªó g·ªçi
        const key = `${userId}_${cmd}`;
        const now = Date.now();
        if (this.cooldowns.has(key)) {
            const exp = this.cooldowns.get(key);
            if (now < exp) return exp;
        }
        this.cooldowns.set(key, now + duration * 1000);
        return 0;
    },
    
    formatMoney(amount) {
        return parseInt(amount).toLocaleString('en-US');
    },

    // --- WORD CHAIN STATS (GLOBAL) ---
    // Rank n·ªëi t·ª´ t√≠nh to√†n c·ª•c
    async updateWordChainStats(guildId, userId, isWin) {
        // guildId ch·ªâ ƒë·ªÉ t∆∞∆°ng th√≠ch, kh√¥ng d√πng l√†m key n·ªØa
        const key = userId;
        let stats = this.wordChain.get(key);
        if (!stats) {
            stats = { user_id: userId, wins: 0, correct_words: 0 };
            this.wordChain.set(key, stats);
        }
        stats.correct_words++;
        if (isWin) stats.wins++;
        this.dirty.wordChain.add(key);
    }
};

================================================================================
FILE: utils/eco_libs/user.js
================================================================================
// utils/eco_libs/user.js
const { User, UserBuff } = require('../../database/models');

module.exports = {
    // --- BASIC USER & BALANCE (GLOBAL) ---
    async getUser(userId) {
        const key = userId; 
        if (!this.users.has(key)) {
            const newUser = {
                user_id: userId,
                cash: 0, 
                bank: 0,
                last_daily: null,
                streak: 0
            };
            this.users.set(key, newUser);
            this.dirty.users.add(key);
        }
        return this.users.get(key);
    },

    async getBalance(userId) { // <--- H√ÄM N√ÄY PH·∫¢I C√ì
        const user = await this.getUser(userId);
        return { cash: user.cash, bank: user.bank, total: user.cash + user.bank };
    },

    async updateBalance(userId, amount, type = "cash", mode = "add") {
        const key = userId;
        const user = await this.getUser(userId);
        const field = type === 'bank' ? 'bank' : 'cash';
        
        if (mode === "set") user[field] = amount;
        else user[field] += (mode === "add" ? amount : -amount);
        
        this.dirty.users.add(key);
        return true;
    },

    async addMoney(userId, amount, reason) { 
        return this.updateBalance(userId, amount, "cash", "add"); 
    },
    
    async subtractMoney(userId, amount, reason) {
        const user = await this.getUser(userId);
        if (user.cash < amount) return false;
        return this.updateBalance(userId, amount, "cash", "remove");
    },

    async deductMoney(userId, amount) {
        const user = await this.getUser(userId);
        let remaining = amount;
        let deductedCash = 0, deductedBank = 0;

        if (user.cash >= remaining) { deductedCash = remaining; remaining = 0; }
        else { deductedCash = user.cash; remaining -= user.cash; }

        if (remaining > 0) {
            if (user.bank >= remaining) { deductedBank = remaining; remaining = 0; }
            else { deductedBank = user.bank; remaining -= user.bank; }
        }

        if (deductedCash > 0) await this.updateBalance(userId, deductedCash, 'cash', 'remove');
        if (deductedBank > 0) await this.updateBalance(userId, deductedBank, 'bank', 'remove');
        return deductedCash + deductedBank;
    },

    async addMoneyToAll(memberIds, amount) {
        let count = 0;
        for (const userId of memberIds) {
            await this.updateBalance(userId, amount, 'bank', 'add');
            count++;
        }
        return count;
    },

    async updateDaily(userId, streak) {
        const key = userId;
        const user = await this.getUser(userId);
        user.last_daily = new Date();
        user.streak = streak;
        this.dirty.users.add(key);
    },

    async getAllUsers() {
        const result = [];
        for (const user of this.users.values()) {
            result.push({ ...user, total: user.cash + user.bank });
        }
        return result;
    },

    async createTestUsers(count) {
        for (let i = 1; i <= count; i++) {
            const uid = `test_user_${i}`;
            const key = uid;
            this.users.set(key, {
                user_id: uid,
                cash: Math.floor(Math.random() * 50000),
                bank: Math.floor(Math.random() * 500000),
                streak: 0
            });
            this.dirty.users.add(key);
        }
        return true;
    },

    async removeTestUsers() {
        let count = 0;
        for (const [key, user] of this.users) {
            if (user.user_id.startsWith('test_user_')) {
                this.users.delete(key);
                await User.deleteOne({ user_id: user.user_id });
                count++;
            }
        }
        return count;
    },
    
    async getUserBuffs(userId) {
        let buff = await UserBuff.findOne({ user_id: userId });
        if (!buff) {
            buff = await UserBuff.create({ user_id: userId });
        }
        return buff;
    },

    async activateBuff(userId, type, gemId, turns) {
        const buff = await this.getUserBuffs(userId);
        if (type === 'quantity') {
            buff.qty_gem_id = gemId;
            buff.qty_turns = turns;
            buff.qty_total = turns;
        } else if (type === 'quality') {
            buff.qual_gem_id = gemId;
            buff.qual_turns = turns;
            buff.qual_total = turns;
        }
        await buff.save();
        return true;
    },

    async decreaseBuffTurns(userId) {
        const buff = await this.getUserBuffs(userId);
        let changed = false;
        if (buff.qty_turns > 0) {
            buff.qty_turns -= 1;
            if (buff.qty_turns <= 0) { buff.qty_turns = 0; buff.qty_gem_id = null; buff.qty_total = 0; }
            changed = true;
        }
        if (buff.qual_turns > 0) {
            buff.qual_turns -= 1;
            if (buff.qual_turns <= 0) { buff.qual_turns = 0; buff.qual_gem_id = null; buff.qual_total = 0; }
            changed = true;
        }
        if (changed) await buff.save();
        return buff;
    }
};

================================================================================
FILE: utils/eco_libs/zoo.js
================================================================================
// utils/eco_libs/zoo.js
const { Zoo } = require('../../database/models');

module.exports = {
    // L·∫•y kho th√∫ (Global - Key l√† userId)
    async getZoo(userId) {
        const key = userId;
        
        // Kh·ªüi t·∫°o cache n·∫øu ch∆∞a c√≥
        if (!this.zooCache) this.zooCache = new Map();
        
        // N·∫øu ch∆∞a c√≥ trong RAM, l·∫•y t·ª´ DB
        if (!this.zooCache.has(key)) {
            // S·ª¨ D·ª§NG .lean() ƒê·ªÇ L·∫§Y OBJECT THU·∫¶N (Quan tr·ªçng)
            // Kh√¥ng d√πng findOne th∆∞·ªùng ƒë·ªÉ tr√°nh tr·∫£ v·ªÅ Mongoose Document (Map)
            let zooData = await Zoo.findOne({ user_id: userId }).lean();
            
            if (!zooData) {
                // N·∫øu ch∆∞a c√≥, t·∫°o object m·∫∑c ƒë·ªãnh trong RAM
                // (Ch∆∞a c·∫ßn l∆∞u DB ngay ƒë·ªÉ t·ªëi ∆∞u)
                zooData = { 
                    user_id: userId, 
                    animals: {} 
                };
            }

            // ƒê·∫£m b·∫£o animals lu√¥n l√† m·ªôt Object (ƒë·ªÅ ph√≤ng DB c≈© l∆∞u null/map)
            if (!zooData.animals || typeof zooData.animals !== 'object' || Array.isArray(zooData.animals)) {
                zooData.animals = {};
            }

            // Set v√†o Cache
            this.zooCache.set(key, zooData);
        }
        
        return this.zooCache.get(key);
    },

    // Th√™m danh s√°ch th√∫
    async addAnimals(userId, animalsList) {
        const key = userId;
        // L·∫•y data t·ª´ cache (ƒë√£ ƒë∆∞·ª£c h√†m getZoo chu·∫©n h√≥a th√†nh Object)
        const zooData = await this.getZoo(userId);
        
        // Double check
        if (!zooData.animals) zooData.animals = {};

        for (const animal of animalsList) {
            const currentCount = zooData.animals[animal.id] || 0;
            zooData.animals[animal.id] = currentCount + 1;
        }

        // C·∫≠p nh·∫≠t Cache
        this.zooCache.set(key, zooData);
        
        // ƒê√°nh d·∫•u Dirty
        if (!this.dirty.zoo) this.dirty.zoo = new Set();
        this.dirty.zoo.add(key);
        
        return true;
    },

    // X√≥a th√∫ (D√πng ƒë·ªÉ b√°n)
    async removeAnimals(userId, animalId, amount) {
        const key = userId;
        const zooData = await this.getZoo(userId);
        
        if (!zooData.animals) return false;

        const currentCount = zooData.animals[animalId] || 0;
        
        if (currentCount < amount) return false; // Kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng

        // Tr·ª´ s·ªë l∆∞·ª£ng
        zooData.animals[animalId] = currentCount - amount;
        
        // N·∫øu h·∫øt th√¨ x√≥a key kh·ªèi object cho g·ªçn
        if (zooData.animals[animalId] <= 0) {
            delete zooData.animals[animalId];
        }

        // C·∫≠p nh·∫≠t Cache
        this.zooCache.set(key, zooData);
        
        // ƒê√°nh d·∫•u Dirty
        if (!this.dirty.zoo) this.dirty.zoo = new Set();
        this.dirty.zoo.add(key);
        
        return true;
    }
};

================================================================================
FILE: utils/gem_market.js
================================================================================
// utils/gem_market.js
const { EmbedBuilder } = require('discord.js');
const { SHOP_ITEMS, CURRENCY } = require('../config');
const { MarketHistory } = require('../database/models');
const economy = require('./economy');

// C·∫•u h√¨nh kho·∫£ng gi√°
const GEM_PRICE_RANGES = {
    // --- Gem C≈© (Classic) ---
    gem1: { min: 1500, max: 2500 },
    gem2: { min: 3500, max: 5500 },
    gem3: { min: 7000, max: 9500 },
    gem4: { min: 12000, max: 18000 },
    gem5: { min: 35000, max: 50000 },
    gem6: { min: 50000, max: 120000 },
    gem7: { min: 100000, max: 220000 },

    // --- Gem M·ªõi (Series A) ---
        gem1a: { min: 2500, max: 5000 },
        gem2a: { min: 5000, max: 8500 },
        gem3a: { min: 8000, max: 14000 },
        gem4a: { min: 14000, max: 25000 },
        gem5a: { min: 45000, max: 90000 },
        gem6a: { min: 40000, max: 180000 },
        gem7a: { min: 100000, max: 350000 }
};

let currentMarketPrices = {};

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// C·∫≠p nh·∫≠t gi√°
async function updateMarketPrices() {
    const oldPrices = { ...currentMarketPrices };
    const now = new Date();
    
    for (const [gemId, range] of Object.entries(GEM_PRICE_RANGES)) {
        const newPrice = getRandomInt(range.min, range.max);
        let trend = 'stable';
        
        if (oldPrices[gemId]) {
            if (newPrice > oldPrices[gemId].price) trend = 'up';
            else if (newPrice < oldPrices[gemId].price) trend = 'down';
        } else {
            trend = Math.random() > 0.5 ? 'up' : 'down';
        }

        currentMarketPrices[gemId] = {
            price: newPrice,
            trend: trend,
            name: SHOP_ITEMS[gemId].name,
            emoji: SHOP_ITEMS[gemId].emoji
        };

        try {
            let totalInServer = 0;
            if (economy.countItemInServer) {
                for (const [key, val] of economy.inventory) {
                    if (val.item_id === gemId) totalInServer += val.amount;
                }
            }

            await MarketHistory.create({
                gem_id: gemId,
                price: newPrice,
                total_in_server: totalInServer,
                time: now
            });

            const records = await MarketHistory.find({ gem_id: gemId }).sort({ time: -1 });
            if (records.length > 5) {
                const idsToDelete = records.slice(5).map(r => r._id);
                await MarketHistory.deleteMany({ _id: { $in: idsToDelete } });
            }

        } catch (e) {
            console.error(`[GemMarket] L·ªói l∆∞u DB cho ${gemId}:`, e);
        }
    }
    
    const timeLog = now.toLocaleTimeString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' });
    console.log(`[GemMarket] Gi√° ƒë√° qu√Ω ƒë√£ c·∫≠p nh·∫≠t l√∫c ${timeLog}`);
    return currentMarketPrices;
}

function getGemPrice(gemId) {
    if (!currentMarketPrices[gemId]) {
        return { price: 0, trend: 'stable', name: 'Loading...', emoji: '' };
    }
    return currentMarketPrices[gemId];
}

// --- T·∫†O EMBED CHECK GI√Å (CHIA 2 PH·∫¶N) ---
function getMarketEmbed() {
    if (Object.keys(currentMarketPrices).length === 0) return new EmbedBuilder().setDescription("ƒêang c·∫≠p nh·∫≠t th·ªã tr∆∞·ªùng...");

    const now = new Date();
    const timeString = now.toLocaleTimeString('vi-VN', { 
        timeZone: 'Asia/Ho_Chi_Minh', hour: '2-digit', minute: '2-digit', hour12: false 
    });

    let description = "";

    // Helper t·∫°o d√≤ng hi·ªÉn th·ªã
    const formatLine = (id) => {
        const data = currentMarketPrices[id];
        if (!data) return "";
        const trendIcon = data.trend === 'up' 
            ? '<:up:1461137151109632071>' 
            : (data.trend === 'down' ? '<:down:1461137149435973713>' : '‚ûñ');
        return `${data.emoji} **${data.name}** - Gi√°: **${data.price.toLocaleString()}** ${CURRENCY} ${trendIcon}\n`;
    };

    // PH·∫¶N 1: NG·ªåC LOOTBOX (Gem 7 -> Gem 1)
    description += "**--- üíé NG·ªåC LOOTBOX ---**\n";
    const classicGems = ['gem7', 'gem6', 'gem5', 'gem4', 'gem3', 'gem2', 'gem1'];
    classicGems.forEach(id => description += formatLine(id));

    // PH√ÇN C√ÅCH
    description += "\n------------------------\n\n";

    // PH·∫¶N 2: NG·ªåC CRATE (Gem 7a -> Gem 1a)
    description += "**--- üè∫ NG·ªåC CRATE ---**\n";
    const seriesAGems = ['gem7a', 'gem6a', 'gem5a', 'gem4a', 'gem3a', 'gem2a', 'gem1a'];
    seriesAGems.forEach(id => description += formatLine(id));

    const embed = new EmbedBuilder()
        .setColor('Green')
        .setTitle(`**MeoU ƒê·ªï Th·∫°ch - B·∫£ng Gi√° B·∫£o Ng·ªçc - ${timeString}**`)
        .setDescription(description)
        .setFooter({ text: "Gi√° c·∫≠p nh·∫≠t m·ªói gi·ªù. H√£y canh gi√° t·ªët ƒë·ªÉ b√°n!" })
        .setTimestamp();

    return embed;
}

async function getGemHistoryEmbed(gemId) {
    const itemData = SHOP_ITEMS[gemId];
    if (!itemData) return new EmbedBuilder().setDescription("Kh√¥ng t√¨m th·∫•y th√¥ng tin Gem.");

    const history = await MarketHistory.find({ gem_id: gemId }).sort({ time: -1 }).limit(5);
    
    let description = "----------------------------\n";
    let trendText = "·ªîn ƒë·ªãnh";

    if (history.length > 0) {
        const currentPrice = history[0].price;
        if (history.length > 1) {
            if (currentPrice > history[1].price) trendText = "**TƒÉng** üìà";
            else if (currentPrice < history[1].price) trendText = "**Gi·∫£m** üìâ";
        }

        for (const record of history) {
            const timeStr = record.time.toLocaleTimeString('vi-VN', { 
                timeZone: 'Asia/Ho_Chi_Minh', hour: '2-digit', minute: '2-digit', hour12: false 
            });
            description += `${timeStr} - Gi√°: **${record.price.toLocaleString()}** ${CURRENCY} (SL: ${record.total_in_server})\n`;
        }
    } else {
        description += "Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠.\n";
    }
    
    description += "----------------------------\n";
    description += `Xu h∆∞·ªõng: ${trendText}`;

    const now = new Date();
    const timeString = now.toLocaleTimeString('vi-VN', { 
        timeZone: 'Asia/Ho_Chi_Minh', hour: '2-digit', minute: '2-digit', hour12: false 
    });

    const embed = new EmbedBuilder()
        .setColor('Blue')
        .setTitle(`${itemData.name} ${itemData.emoji} - ${timeString}`)
        .setDescription(description);

    return embed;
}

function startMarketScheduler() {
    updateMarketPrices();
    setInterval(() => {
        const now = new Date();
        if (now.getMinutes() === 0) {
             updateMarketPrices();
        }
    }, 60000); 
}

module.exports = {
    startMarketScheduler,
    updateMarketPrices,
    getGemPrice,
    getMarketEmbed,
    getGemHistoryEmbed,
    currentMarketPrices
};

================================================================================
FILE: utils/helpers.js
================================================================================
// utils/helpers.js
const { SHOP_ITEMS } = require('../config');

function parseBetAmount(str) {
    if (!str) return 0;
    str = str.toLowerCase();
    let multi = 1;
    if (str.endsWith('k')) { multi = 1000; str = str.slice(0, -1); } 
    else if (str.endsWith('m')) { multi = 1000000; str = str.slice(0, -1); }
    const val = parseFloat(str);
    return isNaN(val) ? 0 : Math.floor(val * multi);
}

function removeVietnameseTones(str) {
    str = str.replace(/√†|√°|·∫°|·∫£|√£|√¢|·∫ß|·∫•|·∫≠|·∫©|·∫´|ƒÉ|·∫±|·∫Ø|·∫∑|·∫≥|·∫µ/g, "a");
    str = str.replace(/√®|√©|·∫π|·∫ª|·∫Ω|√™|·ªÅ|·∫ø|·ªá|·ªÉ|·ªÖ/g, "e");
    str = str.replace(/√¨|√≠|·ªã|·ªâ|ƒ©/g, "i");
    str = str.replace(/√≤|√≥|·ªç|·ªè|√µ|√¥|·ªì|·ªë|·ªô|·ªï|·ªó|∆°|·ªù|·ªõ|·ª£|·ªü|·ª°/g, "o");
    str = str.replace(/√π|√∫|·ª•|·ªß|≈©|∆∞|·ª´|·ª©|·ª±|·ª≠|·ªØ/g, "u");
    str = str.replace(/·ª≥|√Ω|·ªµ|·ª∑|·ªπ/g, "y");
    str = str.replace(/ƒë/g, "d");
    str = str.replace(/√Ä|√Å|·∫†|·∫¢|√É|√Ç|·∫¶|·∫§|·∫¨|·∫®|·∫™|ƒÇ|·∫∞|·∫Æ|·∫∂|·∫≤|·∫¥/g, "A");
    str = str.replace(/√à|√â|·∫∏|·∫∫|·∫º|√ä|·ªÄ|·∫æ|·ªÜ|·ªÇ|·ªÑ/g, "E");
    str = str.replace(/√å|√ç|·ªä|·ªà|ƒ®/g, "I");
    str = str.replace(/√í|√ì|·ªå|·ªé|√ï|√î|·ªí|·ªê|·ªò|·ªî|·ªñ|∆†|·ªú|·ªö|·ª¢|·ªû|·ª†/g, "O");
    str = str.replace(/√ô|√ö|·ª§|·ª¶|≈®|∆Ø|·ª™|·ª®|·ª∞|·ª¨|·ªÆ/g, "U");
    str = str.replace(/·ª≤|√ù|·ª¥|·ª∂|·ª∏/g, "Y");
    str = str.replace(/ƒê/g, "D");
    return str;
}

function findItemSmart(inputName) {
    if (!inputName) return null;
    const cleanInput = inputName.toLowerCase().trim();
    const cleanInputNoTone = removeVietnameseTones(cleanInput);

    return Object.values(SHOP_ITEMS).find(i => {
        const nameLower = i.name.toLowerCase();
        const nameNoTone = removeVietnameseTones(nameLower);
        if (i.keywords.some(k => k === cleanInput || k === cleanInputNoTone)) return true;
        if (nameLower.includes(cleanInput) || nameNoTone.includes(cleanInputNoTone)) return true;
        return false;
    });
}

function findAllItemsSmart(inputName) {
    if (!inputName) return [];
    const cleanInput = inputName.toLowerCase().trim();
    const cleanInputNoTone = removeVietnameseTones(cleanInput);

    return Object.values(SHOP_ITEMS).filter(i => {
        const nameLower = i.name.toLowerCase();
        const nameNoTone = removeVietnameseTones(nameLower);
        if (i.keywords.some(k => k === cleanInput || k === cleanInputNoTone)) return true;
        if (nameLower.includes(cleanInput) || nameNoTone.includes(cleanInputNoTone)) return true;
        return false;
    });
}

// --- H√ÄM T√åM USER GLOBAL (PHI√äN B·∫¢N CHI·∫æN TH·∫¶N) ---
async function resolveGlobalUser(message, keyword) {
    if (!keyword) return null;
    const client = message.client;
    // X√≥a d·∫•u @ n·∫øu user g√µ ki·ªÉu @buiviethoangf
    const cleanKey = keyword.toLowerCase().replace(/^@/, '');

    // 1. N·∫øu l√† Mention <@!ID>
    const mentionMatch = keyword.match(/^<@!?(\d+)>$/);
    if (mentionMatch) {
        return await client.users.fetch(mentionMatch[1]).catch(() => null);
    }

    // 2. N·∫øu l√† ID s·ªë
    if (/^\d{17,19}$/.test(cleanKey)) {
        return await client.users.fetch(cleanKey).catch(() => null);
    }

    // 3. T√¨m b·∫±ng Username/Nickname trong Cache c·ªßa TO√ÄN B·ªò server bot ƒëang tham gia
    for (const guild of client.guilds.cache.values()) {
        const member = guild.members.cache.find(m => 
            m.user.username.toLowerCase() === cleanKey || 
            (m.nickname && m.nickname.toLowerCase() === cleanKey) ||
            (m.user.globalName && m.user.globalName.toLowerCase() === cleanKey)
        );
        if (member) return member.user;
    }

    // 4. N·∫øu v·∫´n kh√¥ng th·∫•y, qu√©t s√¢u h∆°n trong danh s√°ch User bot ƒë√£ t·ª´ng th·∫•y
    const user = client.users.cache.find(u => 
        u.username.toLowerCase() === cleanKey || 
        (u.globalName && u.globalName.toLowerCase() === cleanKey)
    );
    
    return user || null;
}

module.exports = { 
    parseBetAmount, 
    removeVietnameseTones, 
    findItemSmart, 
    findAllItemsSmart,
    resolveGlobalUser 
};

================================================================================
FILE: utils/rng.js
================================================================================
const crypto = require('crypto');

/**
 * H·ªÜ TH·ªêNG V√íNG QUAY ·∫¢O (VIRTUAL WHEEL) - PRECISION 100,000
 * Gi√∫p x·ª≠ l√Ω c√°c t·ªâ l·ªá si√™u nh·ªè nh∆∞ 0.01% m·ªôt c√°ch ch√≠nh x√°c.
 */

const PRECISION_SCALE = 100000; // 0.001% = 1 ƒë∆°n v·ªã

function getSecureRandomInt(min, max) {
    return crypto.randomInt(min, max);
}

/**
 * Quay th∆∞·ªüng d·ª±a tr√™n danh s√°ch item c√≥ rate
 * @param {Array} items - Danh s√°ch item [{id: 'x', rate: 10.5}, ...]
 */
function spinWheel(items) {
    let pool = [];
    let totalWeight = 0;

    // 1. Chu·∫©n h√≥a d·ªØ li·ªáu ƒë·∫ßu v√†o
    for (const item of items) {
        if (item.rate && item.rate > 0) {
            // Nh√¢n rate v·ªõi 100,000 ƒë·ªÉ chuy·ªÉn th√†nh s·ªë nguy√™n
            // VD: Rate 0.05 -> Weight 5000
            const weight = Math.round(item.rate * PRECISION_SCALE);
            
            if (weight > 0) {
                pool.push({
                    item: item,
                    min: totalWeight,
                    max: totalWeight + weight
                });
                totalWeight += weight;
            }
        }
    }

    if (totalWeight === 0) return items[0]; // Fallback

    // 2. Quay s·ªë (0 -> TotalWeight)
    const luckyNumber = getSecureRandomInt(0, totalWeight);

    // 3. D√≤ k·∫øt qu·∫£
    const winner = pool.find(p => luckyNumber >= p.min && luckyNumber < p.max);

    return winner ? winner.item : items[0];
}

module.exports = { spinWheel, getSecureRandomInt };

================================================================================
FILE: utils/selection_ui.js
================================================================================
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');

/**
 * Hi·ªÉn th·ªã b·∫£ng x√°c nh·∫≠n ch·ªçn v·∫≠t ph·∫©m/th√∫ khi c√≥ nhi·ªÅu k·∫øt qu·∫£ tr√πng kh·ªõp
 * @param {Message} message - Message g·ªëc c·ªßa user
 * @param {Array} items - Danh s√°ch c√°c item tr√πng kh·ªõp [{id, name, emoji, type, data...}]
 * @param {String} actionType - 'use' ho·∫∑c 'sell' (ƒë·ªÉ hi·ªÉn th·ªã ti√™u ƒë·ªÅ)
 * @param {Function} callback - H√†m callback ch·∫°y khi user ch·ªçn xong (selectedItem, interaction) => {}
 */
async function showSelectionMenu(message, items, actionType, callback) {
    const userId = message.author.id;

    // Gi·ªõi h·∫°n t·ªëi ƒëa 25 item (gi·ªõi h·∫°n c·ªßa Discord Button grid)
    const displayItems = items.slice(0, 25); 
    
    let description = items.length > 1 
        ? `T√¨m th·∫•y **${items.length}** k·∫øt qu·∫£ tr√πng kh·ªõp.\nVui l√≤ng ch·ªçn ch√≠nh x√°c th·ª© b·∫°n mu·ªën **${actionType === 'use' ? 'S·ª≠ D·ª•ng' : 'B√°n'}**:`
        : `X√°c nh·∫≠n thao t√°c v·ªõi:`;

    const itemListText = displayItems.map((item, index) => {
        const typeLabel = item.type === 'animal' ? '[Th√∫]' : '[Item]';
        return `**${index + 1}.** ${item.emoji} **${item.name}** \`${typeLabel}\``;
    }).join('\n');

    const embed = new EmbedBuilder()
        .setColor('Orange')
        .setTitle(`üîç X√ÅC NH·∫¨N ${actionType.toUpperCase()} ITEM`)
        .setDescription(`${description}\n\n${itemListText}\n\n*B·∫•m n√∫t b√™n d∆∞·ªõi ƒë·ªÉ ch·ªçn.*`)
        .setFooter({ text: "L·ª±a ch·ªçn s·∫Ω h·∫øt h·∫°n sau 30 gi√¢y." });

    const rows = [];
    let currentRow = new ActionRowBuilder();

    displayItems.forEach((item, index) => {
        if (index > 0 && index % 5 === 0) {
            rows.push(currentRow);
            currentRow = new ActionRowBuilder();
        }
        currentRow.addComponents(
            new ButtonBuilder()
                .setCustomId(`select_item_${index}`)
                .setLabel(`${index + 1}. ${item.name}`.substring(0, 80))
                .setEmoji(item.emoji)
                .setStyle(ButtonStyle.Secondary)
        );
    });
    if (currentRow.components.length > 0) rows.push(currentRow);

    const cancelRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('select_cancel').setLabel('H·ªßy B·ªè').setStyle(ButtonStyle.Danger)
    );
    rows.push(cancelRow);

    const replyMsg = await message.reply({ embeds: [embed], components: rows });

    const collector = replyMsg.createMessageComponentCollector({ 
        componentType: ComponentType.Button, 
        time: 30000,
        filter: i => i.user.id === userId 
    });

    collector.on('collect', async interaction => {
        if (interaction.customId === 'select_cancel') {
            await interaction.update({ content: "ƒê√£ h·ªßy thao t√°c.", embeds: [], components: [] });
            return;
        }

        if (interaction.customId.startsWith('select_item_')) {
            const index = parseInt(interaction.customId.replace('select_item_', ''));
            const selectedItem = displayItems[index];

            // KH√îNG update t·∫°i ƒë√¢y n·ªØa ƒë·ªÉ tr√°nh tin nh·∫Øn trung gian.
            // Truy·ªÅn interaction v√†o callback ƒë·ªÉ h√†m x·ª≠ l√Ω ti·∫øp theo (sell/use) th·ª±c hi·ªán update.
            if (callback) callback(selectedItem, interaction);
        }
    });

    collector.on('end', (collected, reason) => {
        if (reason === 'time') {
            replyMsg.edit({ content: "ƒê√£ h·∫øt th·ªùi gian l·ª±a ch·ªçn.", embeds: [], components: [] }).catch(() => {});
        }
    });
}

module.exports = { showSelectionMenu };

